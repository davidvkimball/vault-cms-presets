/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultCMSPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  projectRoot: "",
  configFilePath: "",
  contentTypes: [],
  frontmatterProperties: {},
  attachmentHandlingMode: "subfolder",
  attachmentFolderName: void 0,
  preset: "vanilla",
  presetName: "",
  presetsRepo: "davidvkimball/vault-cms-presets",
  enableWYSIWYG: false,
  enabledPlugins: [],
  disabledPlugins: [],
  theme: "",
  basesCMSConfig: {
    views: []
  },
  astroComposerConfig: {
    customContentTypes: [],
    defaultTemplate: "",
    configFilePath: "",
    terminalProjectRootPath: ""
  },
  seoConfig: {
    titleProperty: "title",
    descriptionProperty: void 0,
    scanDirectories: "",
    useFilenameAsTitle: false,
    useFilenameAsSlug: true,
    enableMDXSupport: false
  },
  commanderConfig: {
    pageHeaderCommands: []
  },
  propertyOverFileName: {
    propertyKey: "title"
  },
  imageInserter: {
    valueFormat: "[[attachments/{image-url}]]",
    insertFormat: "[[attachments/{image-url}]]"
  },
  imageManager: {},
  homeBase: {},
  explorerFocus: {},
  ignoreConfig: {
    gitIgnoreConfigured: false,
    viteIgnoreConfigured: false
  },
  runWizardOnStartup: true,
  wizardCompleted: false
};

// src/ui/SettingsTab.ts
var import_obsidian28 = require("obsidian");

// src/ui/SetupWizardModal.ts
var import_obsidian24 = require("obsidian");

// src/utils/ImageManagerConfig.ts
var import_obsidian = require("obsidian");
var ImageManagerConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async loadConfig() {
    var _a;
    const pluginId = "image-manager";
    try {
      const plugins = this.app.plugins;
      const imageManagerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (imageManagerPlugin && imageManagerPlugin.settings) {
        return imageManagerPlugin.settings;
      }
    } catch (error) {
      console.warn("Failed to load Image Manager config from plugin API:", error);
    }
    return await this.loadConfigFallback();
  }
  async loadConfigFallback() {
    const pluginId = "image-manager";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      try {
        const existingData = JSON.parse(await this.app.vault.read(dataFile));
        return existingData;
      } catch (error) {
        console.warn("Failed to parse existing Image Manager data.json:", error);
        return {};
      }
    }
    return {};
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "image-manager";
    try {
      const plugins = this.app.plugins;
      const imageManagerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (imageManagerPlugin && imageManagerPlugin.settings) {
        const pluginSettings = imageManagerPlugin.settings;
        Object.assign(pluginSettings, config);
        if (typeof imageManagerPlugin.saveSettings === "function") {
          await imageManagerPlugin.saveSettings();
          console.debug("ImageManagerConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Image Manager config:", error);
      try {
        await this.saveConfigFallback(config);
      } catch (fallbackError) {
        console.error("Failed to save Image Manager config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "image-manager";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Image Manager data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    if (dataFile && dataFile instanceof import_obsidian.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(mergedData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
};

// src/utils/HomeBaseConfig.ts
var import_obsidian2 = require("obsidian");
var HomeBaseConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async loadConfig() {
    var _a;
    const pluginId = "home-base";
    try {
      const plugins = this.app.plugins;
      const homeBasePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (homeBasePlugin && homeBasePlugin.settings) {
        return homeBasePlugin.settings;
      }
    } catch (error) {
      console.warn("Failed to load Home Base config from plugin API:", error);
    }
    return await this.loadConfigFallback();
  }
  async loadConfigFallback() {
    const pluginId = "home-base";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      try {
        const existingData = JSON.parse(await this.app.vault.read(dataFile));
        return existingData;
      } catch (error) {
        console.warn("Failed to parse existing Home Base data.json:", error);
        return {};
      }
    }
    return {};
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "home-base";
    try {
      const plugins = this.app.plugins;
      const homeBasePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (homeBasePlugin && homeBasePlugin.settings) {
        const pluginSettings = homeBasePlugin.settings;
        Object.assign(pluginSettings, config);
        if (typeof homeBasePlugin.saveSettings === "function") {
          await homeBasePlugin.saveSettings();
          console.debug("HomeBaseConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Home Base config:", error);
      try {
        await this.saveConfigFallback(config);
      } catch (fallbackError) {
        console.error("Failed to save Home Base config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "home-base";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Home Base data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    if (dataFile && dataFile instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian2.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(mergedData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
};

// src/utils/ExplorerFocusConfig.ts
var import_obsidian3 = require("obsidian");
var ExplorerFocusConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(config) {
    var _a;
    const pluginId = "explorer-focus";
    try {
      const plugins = this.app.plugins;
      const explorerFocusPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (explorerFocusPlugin && explorerFocusPlugin.settings) {
        console.debug("ExplorerFocusConfig: Using plugin.settings API");
        const settings = explorerFocusPlugin.settings;
        for (const [key, value] of Object.entries(config)) {
          settings[key] = value;
        }
        if (typeof explorerFocusPlugin.saveSettings === "function") {
          await explorerFocusPlugin.saveSettings();
          console.debug("ExplorerFocusConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("ExplorerFocusConfig: Plugin API not available, using fallback file method");
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Explorer Focus config:", error);
      await this.saveConfigFallback(config);
    }
  }
  async loadConfig() {
    const pluginId = "explorer-focus";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian3.TFile) {
        const content = await this.app.vault.read(dataFile);
        return JSON.parse(content);
      }
    } catch (error) {
      console.warn("Failed to load Explorer Focus config:", error);
    }
    return null;
  }
  async saveConfigFallback(config) {
    const pluginId = "explorer-focus";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian3.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing explorer-focus data.json:", error);
      }
    }
    const mergedData = {
      ...existingData,
      ...config
    };
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(mergedData, null, 2);
    if (dataFile instanceof import_obsidian3.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("ExplorerFocusConfig: Successfully saved explorer-focus config via fallback");
  }
};

// src/utils/CommanderConfig.ts
var import_obsidian4 = require("obsidian");
var CommanderConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  generateCommanderConfig(enableWYSIWYG) {
    const config = {
      pageHeaderCommands: []
    };
    return config;
  }
  /**
   * Enable/disable the editing toolbar plugin (not via commander button)
   * When enabled, the toolbar will be available via its own "Show/hide toolbar" command
   */
  async toggleEditingToolbarCommand(app, enable) {
    var _a;
    console.debug(`CommanderConfig: toggleEditingToolbarCommand called with enable=${enable}`);
    try {
      const plugins = app.plugins;
      if (!plugins) {
        console.warn("CommanderConfig: Plugins API not available");
        return;
      }
      const editingToolbarPlugin = (_a = plugins.plugins) == null ? void 0 : _a["editing-toolbar"];
      if (!editingToolbarPlugin) {
        console.warn("CommanderConfig: Editing Toolbar plugin not found");
        return;
      }
      console.debug(`CommanderConfig: Editing Toolbar plugin found, enabled=${editingToolbarPlugin.enabled}`);
      console.debug(`CommanderConfig: Plugin settings available:`, !!editingToolbarPlugin.settings);
      if (editingToolbarPlugin.settings) {
        console.debug(`CommanderConfig: Current cMenuVisibility:`, editingToolbarPlugin.settings.cMenuVisibility);
      }
      if (editingToolbarPlugin.settings && typeof editingToolbarPlugin.saveSettings === "function") {
        console.debug("CommanderConfig: Using plugin.saveSettings() method");
        const oldValue = editingToolbarPlugin.settings.cMenuVisibility;
        editingToolbarPlugin.settings.cMenuVisibility = enable;
        console.debug(`CommanderConfig: Set cMenuVisibility from ${oldValue} to ${enable}`);
        await editingToolbarPlugin.saveSettings();
        console.debug("CommanderConfig: Successfully saved editing-toolbar via plugin.saveSettings()");
        console.debug("CommanderConfig: Dispatching editingToolbar-NewCommand event");
        window.dispatchEvent(new Event("editingToolbar-NewCommand"));
        if (enable) {
          console.debug("CommanderConfig: Waiting for settings to persist...");
          await new Promise((resolve6) => setTimeout(resolve6, 500));
          if (typeof editingToolbarPlugin.loadSettings === "function") {
            console.debug("CommanderConfig: Reloading editing toolbar plugin settings");
            await editingToolbarPlugin.loadSettings();
          }
          if (typeof editingToolbarPlugin.refresh === "function") {
            console.debug("CommanderConfig: Refreshing editing toolbar plugin");
            editingToolbarPlugin.refresh();
          }
        }
        return;
      } else {
        console.debug("CommanderConfig: Plugin saveSettings not available, using fallback");
      }
      await this.toggleEditingToolbarCommandFallback(app, enable);
    } catch (error) {
      console.error("CommanderConfig: Failed to toggle editing toolbar plugin:", error);
      try {
        await this.toggleEditingToolbarCommandFallback(app, enable);
      } catch (fallbackError) {
        console.error("CommanderConfig: Failed to toggle editing toolbar via fallback:", fallbackError);
      }
    }
  }
  async toggleEditingToolbarCommandFallback(app, enable) {
    const pluginId = "editing-toolbar";
    const configDir = app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian4.TFile) {
      try {
        existingData = JSON.parse(await app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing editing-toolbar data.json, starting fresh:", error);
        existingData = {};
      }
    }
    existingData.cMenuVisibility = enable;
    if (dataFile instanceof import_obsidian4.TFile) {
      await app.vault.modify(dataFile, JSON.stringify(existingData, null, 2));
      console.debug("CommanderConfig: Successfully saved editing-toolbar via file modify");
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
            throw error;
          }
        }
      }
      try {
        await app.vault.create(pluginDataPath, JSON.stringify(existingData, null, 2));
        console.debug("CommanderConfig: Successfully created editing-toolbar data.json");
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian4.TFile) {
            await app.vault.modify(retryFile, JSON.stringify(existingData, null, 2));
            console.debug("CommanderConfig: Successfully saved editing-toolbar via retry modify");
          } else {
            await new Promise((resolve6) => setTimeout(resolve6, 200));
            const retryFile2 = app.vault.getAbstractFileByPath(pluginDataPath);
            if (retryFile2 instanceof import_obsidian4.TFile) {
              await app.vault.modify(retryFile2, JSON.stringify(existingData, null, 2));
              console.debug("CommanderConfig: Successfully saved editing-toolbar via delayed retry modify");
            } else {
              throw error;
            }
          }
        } else {
          throw error;
        }
      }
    }
  }
  /**
   * Get the current visibility of the editing toolbar
   */
  async getEditingToolbarVisibility(app) {
    var _a;
    try {
      const plugins = app.plugins;
      const editingToolbarPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["editing-toolbar"];
      if (editingToolbarPlugin == null ? void 0 : editingToolbarPlugin.settings) {
        return editingToolbarPlugin.settings.cMenuVisibility;
      }
      const configDir = app.vault.configDir;
      const pluginDataPath = `${configDir}/plugins/editing-toolbar/data.json`;
      const dataFile = app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian4.TFile) {
        const existingData = JSON.parse(await app.vault.read(dataFile));
        return existingData.cMenuVisibility;
      }
    } catch (error) {
      console.warn("CommanderConfig: Failed to get editing toolbar visibility:", error);
    }
    return void 0;
  }
  async saveConfig(config) {
    const pluginId = "cmdr";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian4.TFile) {
        const existingData = JSON.parse(await this.app.vault.read(dataFile));
        const existingPageHeader = existingData.pageHeader || [];
        const toolbarCommand = {
          id: "editing-toolbar:hide-show-menu",
          icon: "lucide-chevrons-up-down",
          name: "Toggle editing toolbar",
          mode: "desktop"
        };
        const filteredPageHeader = existingPageHeader.filter(
          (cmd) => cmd.id !== "editing-toolbar:hide-show-menu"
        );
        if (config.pageHeaderCommands.length > 0) {
          filteredPageHeader.push(toolbarCommand);
        }
        const mergedData = {
          ...existingData,
          pageHeader: filteredPageHeader
        };
        await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
      }
    } catch (error) {
      console.error("Failed to save Commander config:", error);
    }
  }
};

// src/ui/wizard/WizardStateManager.ts
var WizardStateManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.commanderConfigurator = new CommanderConfigurator(plugin.app);
    const settings = plugin.settings;
    this.state = this.initializeState(settings);
  }
  initializeState(settings) {
    var _a, _b;
    const savedProjectDetection = settings.projectRoot && settings.configFilePath ? {
      projectRoot: settings.projectRoot,
      configFilePath: settings.configFilePath,
      vaultLocation: "content"
    } : void 0;
    let attachmentHandlingMode = settings.attachmentHandlingMode;
    let attachmentFolderName = settings.attachmentFolderName;
    if (!attachmentHandlingMode) {
      const vault = this.plugin.app.vault;
      const obsidianConfig = vault.config;
      if (obsidianConfig == null ? void 0 : obsidianConfig.attachmentFolderPath) {
        const folderPath = obsidianConfig.attachmentFolderPath;
        if (folderPath === "./") {
          attachmentHandlingMode = "same-folder";
        } else if (folderPath.startsWith("./")) {
          attachmentHandlingMode = "subfolder";
          attachmentFolderName = folderPath.substring(2);
        } else {
          attachmentHandlingMode = "specified-folder";
          attachmentFolderName = folderPath;
        }
      }
    }
    return {
      currentStep: 0,
      projectDetection: savedProjectDetection,
      contentTypes: settings.contentTypes || [],
      frontmatterProperties: settings.frontmatterProperties || {},
      defaultContentTypeId: settings.defaultContentTypeId,
      attachmentHandlingMode: attachmentHandlingMode || "subfolder",
      attachmentFolderName,
      preset: settings.preset || "vanilla",
      presetName: settings.presetName || "",
      presetsRepo: settings.presetsRepo || "davidvkimball/vault-cms-presets",
      enableWYSIWYG: (_a = settings.enableWYSIWYG) != null ? _a : false,
      enableMdxSupport: settings.enableMdxSupport,
      enabledPlugins: settings.enabledPlugins || [],
      disabledPlugins: settings.disabledPlugins || [],
      theme: settings.theme || "",
      basesCMSConfig: settings.basesCMSConfig || { views: [] },
      astroComposerConfig: settings.astroComposerConfig || {
        customContentTypes: [],
        defaultTemplate: "",
        configFilePath: "",
        terminalProjectRootPath: ""
      },
      seoConfig: settings.seoConfig || {
        titleProperty: "title",
        scanDirectories: "",
        useFilenameAsTitle: false,
        useFilenameAsSlug: true,
        enableMDXSupport: (_b = settings.enableMdxSupport) != null ? _b : false
      },
      commanderConfig: settings.commanderConfig || { pageHeaderCommands: [] },
      propertyOverFileName: settings.propertyOverFileName || { propertyKey: "title" },
      imageInserter: settings.imageInserter || { valueFormat: "[[attachments/{image-url}]]", insertFormat: "[[attachments/{image-url}]]" },
      imageManager: settings.imageManager || {},
      homeBase: settings.homeBase || {},
      explorerFocus: settings.explorerFocus || {},
      ignoreConfig: settings.ignoreConfig || { gitIgnoreConfigured: false, viteIgnoreConfigured: false }
    };
  }
  getState() {
    return this.state;
  }
  updateState(updates) {
    this.state = { ...this.state, ...updates };
  }
  setState(updates) {
    this.state = { ...this.state, ...updates };
  }
  nextStep() {
    this.state.currentStep++;
  }
  previousStep() {
    if (this.state.currentStep > 0) {
      this.state.currentStep--;
    }
  }
  canGoNext(totalSteps) {
    return this.state.currentStep < totalSteps - 1;
  }
  canGoPrevious() {
    return this.state.currentStep > 0;
  }
  getProgress(totalSteps) {
    if (totalSteps === 0) return 0;
    return (this.state.currentStep + 1) / totalSteps * 100;
  }
  async refreshState() {
    var _a;
    const settings = this.plugin.settings;
    if (settings.projectRoot && settings.configFilePath) {
      this.state.projectDetection = {
        projectRoot: settings.projectRoot,
        configFilePath: settings.configFilePath,
        vaultLocation: "content"
      };
    } else {
      this.state.projectDetection = void 0;
    }
    this.state.contentTypes = settings.contentTypes || [];
    this.state.frontmatterProperties = settings.frontmatterProperties || {};
    this.state.defaultContentTypeId = settings.defaultContentTypeId;
    if (settings.attachmentHandlingMode) {
      this.state.attachmentHandlingMode = settings.attachmentHandlingMode;
      this.state.attachmentFolderName = settings.attachmentFolderName;
    } else {
      const vault = this.plugin.app.vault;
      const obsidianConfig = vault.config;
      if (obsidianConfig == null ? void 0 : obsidianConfig.attachmentFolderPath) {
        const folderPath = obsidianConfig.attachmentFolderPath;
        if (folderPath === "./") {
          this.state.attachmentHandlingMode = "same-folder";
          this.state.attachmentFolderName = void 0;
        } else if (folderPath.startsWith("./")) {
          this.state.attachmentHandlingMode = "subfolder";
          this.state.attachmentFolderName = folderPath.substring(2);
        } else {
          this.state.attachmentHandlingMode = "specified-folder";
          this.state.attachmentFolderName = folderPath;
        }
      } else {
        this.state.attachmentHandlingMode = "subfolder";
        this.state.attachmentFolderName = void 0;
      }
    }
    this.state.preset = settings.preset || "vanilla";
    this.state.presetName = settings.presetName || "";
    this.state.presetsRepo = settings.presetsRepo || "vaultcms/vault-cms-presets";
    const actualVisibility = await this.commanderConfigurator.getEditingToolbarVisibility(this.plugin.app);
    if (actualVisibility !== void 0) {
      this.state.enableWYSIWYG = actualVisibility;
    } else {
      this.state.enableWYSIWYG = (_a = settings.enableWYSIWYG) != null ? _a : false;
    }
    this.state.enableMdxSupport = settings.enableMdxSupport;
    this.state.enabledPlugins = settings.enabledPlugins || [];
    this.state.disabledPlugins = settings.disabledPlugins || [];
    this.state.theme = settings.theme || "";
    this.state.basesCMSConfig = settings.basesCMSConfig || { views: [] };
    this.state.astroComposerConfig = settings.astroComposerConfig || {
      customContentTypes: [],
      defaultTemplate: "",
      configFilePath: "",
      terminalProjectRootPath: ""
    };
    this.state.seoConfig = settings.seoConfig || {
      titleProperty: "title",
      scanDirectories: "",
      useFilenameAsTitle: false,
      useFilenameAsSlug: true
    };
    this.state.commanderConfig = settings.commanderConfig || { pageHeaderCommands: [] };
    this.state.propertyOverFileName = settings.propertyOverFileName || { propertyKey: "title" };
    this.state.imageInserter = settings.imageInserter || { valueFormat: "[[attachments/{image-url}]]", insertFormat: "[[attachments/{image-url}]]" };
    this.state.explorerFocus = settings.explorerFocus || {};
    if (!this.state.imageManager || Object.keys(this.state.imageManager).length === 0) {
      try {
        const imageManagerConfigurator = new ImageManagerConfigurator(this.plugin.app);
        const loadedConfig = await imageManagerConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.imageManager = loadedConfig;
        } else {
          this.state.imageManager = settings.imageManager || {};
        }
      } catch (error) {
        console.warn("Failed to load Image Manager config during refresh:", error);
        this.state.imageManager = settings.imageManager || {};
      }
    } else {
      this.state.imageManager = settings.imageManager || {};
    }
    if (!this.state.homeBase || Object.keys(this.state.homeBase).length === 0) {
      try {
        const homeBaseConfigurator = new HomeBaseConfigurator(this.plugin.app);
        const loadedConfig = await homeBaseConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.homeBase = loadedConfig;
        } else {
          this.state.homeBase = settings.homeBase || {};
        }
      } catch (error) {
        console.warn("Failed to load Home Base config during refresh:", error);
        this.state.homeBase = settings.homeBase || {};
      }
    } else {
      this.state.homeBase = settings.homeBase || {};
    }
    if (!this.state.explorerFocus || Object.keys(this.state.explorerFocus).length === 0) {
      try {
        const explorerFocusConfigurator = new ExplorerFocusConfigurator(this.plugin.app);
        const loadedConfig = await explorerFocusConfigurator.loadConfig();
        if (loadedConfig && Object.keys(loadedConfig).length > 0) {
          this.state.explorerFocus = loadedConfig;
        } else {
          this.state.explorerFocus = settings.explorerFocus || {};
        }
      } catch (error) {
        console.warn("Failed to load Explorer Focus config during refresh:", error);
        this.state.explorerFocus = settings.explorerFocus || {};
      }
    } else {
      this.state.explorerFocus = settings.explorerFocus || {};
    }
  }
  buildFinalSettings() {
    var _a, _b, _c;
    const settings = this.plugin.settings;
    settings.projectRoot = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) || "";
    settings.configFilePath = ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath) || "";
    settings.contentTypes = this.state.contentTypes;
    settings.frontmatterProperties = this.state.frontmatterProperties;
    settings.defaultContentTypeId = this.state.defaultContentTypeId;
    settings.attachmentHandlingMode = this.state.attachmentHandlingMode;
    settings.attachmentFolderName = this.state.attachmentFolderName;
    settings.preset = this.state.preset;
    settings.presetName = this.state.presetName || "";
    settings.presetsRepo = this.state.presetsRepo || "davidvkimball/vault-cms-presets";
    settings.enableWYSIWYG = this.state.enableWYSIWYG;
    settings.enableMdxSupport = (_c = this.state.enableMdxSupport) != null ? _c : false;
    settings.enabledPlugins = this.state.enabledPlugins;
    settings.disabledPlugins = this.state.disabledPlugins;
    settings.theme = this.state.theme;
    settings.basesCMSConfig = this.state.basesCMSConfig;
    settings.astroComposerConfig = this.state.astroComposerConfig;
    settings.seoConfig = this.state.seoConfig;
    settings.commanderConfig = this.state.commanderConfig;
    settings.propertyOverFileName = this.state.propertyOverFileName;
    const settingsRecord = settings;
    if (settingsRecord.uiTweaker) {
      delete settingsRecord.uiTweaker;
    }
    if (settingsRecord.tabBarCommands) {
      delete settingsRecord.tabBarCommands;
    }
    settings.imageInserter = this.state.imageInserter;
    settings.imageManager = this.state.imageManager;
    settings.homeBase = this.state.homeBase;
    settings.explorerFocus = this.state.explorerFocus;
    settings.ignoreConfig = this.state.ignoreConfig;
  }
};

// src/ui/wizard/BaseWizardStep.ts
var BaseWizardStep = class {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    this.app = app;
    this.containerEl = containerEl;
    this.state = state;
    this.onNext = onNext;
    this.onBack = onBack;
    this.onCancel = onCancel;
  }
};

// src/ui/wizard/WelcomeStep.ts
function setCssProps(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var WelcomeStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Welcome to Vault CMS setup" });
    containerEl.createEl("p", {
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: "This wizard will help you configure your Vault CMS setup. We'll guide you through:"
    });
    const list = containerEl.createEl("ul");
    list.createEl("li", { text: "Detecting your Astro project structure" });
    list.createEl("li", { text: "Identifying your content types" });
    list.createEl("li", { text: "Mapping frontmatter properties" });
    list.createEl("li", { text: "Configuring plugins and themes" });
    list.createEl("li", { text: "Setting up Bases CMS views" });
    list.createEl("li", { text: "Configuring Astro Composer and SEO plugins" });
    containerEl.createEl("p", {
      text: "Choose an option to continue:"
    });
    const buttonContainer = containerEl.createDiv("wizard-welcome-buttons");
    setCssProps(buttonContainer, {
      display: "flex",
      gap: "10px",
      marginTop: "20px"
    });
    const getStartedBtn = buttonContainer.createEl("button", {
      text: "Get started",
      cls: "mod-button mod-cta"
    });
    getStartedBtn.addEventListener("click", () => {
      this.onNext();
    });
    const selectPresetBtn = buttonContainer.createEl("button", {
      text: "Select preset",
      cls: "mod-button"
    });
    selectPresetBtn.addEventListener("click", () => {
      this.onCancel();
      const appWithSetting = this.app;
      if (appWithSetting.setting && typeof appWithSetting.setting.open === "function") {
        appWithSetting.setting.open();
        if (typeof appWithSetting.setting.openTabById === "function") {
          appWithSetting.setting.openTabById("vault-cms");
        }
      }
    });
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Welcome";
  }
  getDescription() {
    return "Introduction to Vault CMS setup";
  }
};

// src/ui/wizard/ProjectDetectionStep.ts
var import_obsidian6 = require("obsidian");
var path4 = __toESM(require("path"), 1);
var fs4 = __toESM(require("fs"), 1);

// src/utils/ProjectDetector.ts
var path = __toESM(require("path"), 1);
var fs = __toESM(require("fs"), 1);
var ProjectDetector = class {
  constructor(app) {
    this.app = app;
  }
  detectProject() {
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return null;
    }
    const configResult = this.searchUpwardForConfig(vaultPath);
    if (!configResult) {
      return null;
    }
    const vaultLocation = this.detectVaultLocation(vaultPath, configResult.projectRoot);
    return {
      projectRoot: configResult.projectRoot,
      configFilePath: configResult.configFilePath,
      vaultLocation
    };
  }
  /**
   * Search upward from the vault path to find an Astro config file.
   * This allows the vault to be anywhere within the Astro project structure.
   * Bias towards src/config.ts if it exists alongside a root config file.
   */
  searchUpwardForConfig(startPath) {
    const rootConfigFileNames = [
      "astro.config.mjs",
      "astro.config.ts",
      "astro.config.js",
      "astro.config.mts",
      "astro.config.cjs"
    ];
    const srcConfigFileName = "src/config.ts";
    let currentDir = path.resolve(startPath);
    const root = path.parse(currentDir).root;
    while (currentDir !== root) {
      const srcConfigPath = path.join(currentDir, srcConfigFileName);
      try {
        if (fs.existsSync(srcConfigPath) && fs.statSync(srcConfigPath).isFile()) {
          return {
            projectRoot: currentDir,
            configFilePath: srcConfigPath
          };
        }
      } catch (e) {
      }
      for (const fileName of rootConfigFileNames) {
        const configPath = path.join(currentDir, fileName);
        try {
          if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {
            return {
              projectRoot: currentDir,
              configFilePath: configPath
            };
          }
        } catch (e) {
        }
      }
      const parentDir = path.dirname(currentDir);
      if (parentDir === currentDir) {
        break;
      }
      currentDir = parentDir;
    }
    return null;
  }
  /**
   * Determine vault location relative to the detected project root.
   */
  detectVaultLocation(vaultPath, projectRoot) {
    const normalizedVaultPath = path.normalize(vaultPath);
    const normalizedProjectRoot = path.normalize(projectRoot);
    if (!normalizedVaultPath.startsWith(normalizedProjectRoot)) {
      return "root";
    }
    const relativePath = path.relative(normalizedProjectRoot, normalizedVaultPath);
    const pathParts = relativePath.split(path.sep).filter((part) => part.length > 0);
    const contentIndex = pathParts.findIndex((part) => part.toLowerCase() === "content");
    if (contentIndex > 0) {
      const parentIndex = contentIndex - 1;
      if (parentIndex >= 0 && pathParts[parentIndex].toLowerCase() === "src") {
        return "content";
      }
    }
    const srcIndex = pathParts.findIndex((part) => part.toLowerCase() === "src");
    if (srcIndex >= 0 && srcIndex < pathParts.length - 1) {
      const nextPart = pathParts[srcIndex + 1];
      if (nextPart.toLowerCase() === "content") {
        return "nested-content";
      }
    }
    return "root";
  }
};

// src/utils/MdxDetector.ts
var path2 = __toESM(require("path"), 1);
var fs2 = __toESM(require("fs"), 1);
var MdxDetector = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Detect if MDX files are present in the content folders
   * Scans all content type folders (posts, pages, etc.) for .mdx files
   */
  detectMdxUsage(projectDetection, contentTypes) {
    console.debug("MdxDetector.detectMdxUsage: called with", {
      projectRoot: projectDetection == null ? void 0 : projectDetection.projectRoot,
      vaultLocation: projectDetection == null ? void 0 : projectDetection.vaultLocation,
      contentTypesCount: contentTypes == null ? void 0 : contentTypes.length
    });
    if (!projectDetection) {
      console.debug("MdxDetector: No projectDetection, returning false");
      return false;
    }
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    console.debug("MdxDetector: vaultPath =", vaultPath);
    if (!vaultPath) {
      console.debug("MdxDetector: No vaultPath, returning false");
      return false;
    }
    const projectRoot = projectDetection.projectRoot;
    let projectRootPath;
    if (path2.isAbsolute(projectRoot)) {
      projectRootPath = projectRoot;
    } else {
      projectRootPath = path2.resolve(vaultPath, projectRoot);
    }
    console.debug("MdxDetector: projectRootPath =", projectRootPath);
    let contentBasePath;
    if (projectDetection.vaultLocation === "content") {
      contentBasePath = vaultPath;
    } else if (projectDetection.vaultLocation === "nested-content") {
      contentBasePath = path2.resolve(vaultPath, "..");
    } else {
      contentBasePath = path2.join(projectRootPath, "src", "content");
    }
    console.debug("MdxDetector: contentBasePath =", contentBasePath);
    console.debug("MdxDetector: vaultLocation =", projectDetection.vaultLocation);
    console.debug("MdxDetector: contentTypes to scan =", contentTypes.map((ct) => `${ct.name} (${ct.folder})`));
    for (const contentType of contentTypes) {
      let contentTypePath;
      if (contentType.folder.startsWith("src/content/")) {
        contentTypePath = path2.join(projectRootPath, contentType.folder);
      } else {
        contentTypePath = path2.join(contentBasePath, contentType.folder);
      }
      console.debug("MdxDetector: scanning", contentTypePath, "(enabled:", contentType.enabled, ")");
      try {
        if (fs2.existsSync(contentTypePath) && fs2.statSync(contentTypePath).isDirectory()) {
          const foundMdx = this.scanDirectoryForMdx(contentTypePath);
          console.debug("MdxDetector: found MDX in", contentTypePath, "=", foundMdx);
          if (foundMdx) {
            return true;
          }
        } else {
          console.debug("MdxDetector: path does not exist or is not a directory:", contentTypePath, "exists:", fs2.existsSync(contentTypePath));
        }
      } catch (error) {
        console.debug("MdxDetector: error scanning", contentTypePath, error);
        continue;
      }
    }
    console.debug("MdxDetector: no MDX files found");
    return false;
  }
  /**
   * Recursively scan a directory for .mdx files
   */
  scanDirectoryForMdx(dirPath) {
    try {
      const entries = fs2.readdirSync(dirPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path2.join(dirPath, entry.name);
        if (entry.isFile() && entry.name.endsWith(".mdx")) {
          return true;
        }
        if (entry.isDirectory()) {
          if (this.scanDirectoryForMdx(fullPath)) {
            return true;
          }
        }
      }
    } catch (e) {
      return false;
    }
    return false;
  }
};

// src/utils/ContentTypeDetector.ts
var import_obsidian5 = require("obsidian");
var path3 = __toESM(require("path"), 1);
var fs3 = __toESM(require("fs"), 1);
var ContentTypeDetector = class {
  constructor(app) {
    this.app = app;
  }
  detectContentTypes(projectDetection) {
    const contentFolder = this.findContentDirectory(projectDetection);
    if (!contentFolder) {
      return this.detectContentTypesFromVaultRoot();
    }
    const contentTypes = [];
    const folders = this.getTopLevelFolders(contentFolder);
    for (const folder of folders) {
      const contentType = this.detectContentType(folder);
      if (contentType) {
        contentTypes.push(contentType);
      }
    }
    return contentTypes;
  }
  /**
   * Find the src/content directory regardless of where the vault is located.
   * Handles cases where vault is at:
   * - src level (need to go into src/content)
   * - src/content level (already there)
   * - src/content/post level (vault is inside a content type, can't access parent, return null to use fallback)
   */
  findContentDirectory(projectDetection) {
    if (!projectDetection || !projectDetection.projectRoot) {
      return null;
    }
    const vault = this.app.vault;
    const adapter = vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return null;
    }
    let projectRoot;
    if (path3.isAbsolute(projectDetection.projectRoot)) {
      projectRoot = projectDetection.projectRoot;
    } else {
      projectRoot = path3.resolve(vaultPath, projectDetection.projectRoot);
    }
    const expectedContentPath = path3.join(projectRoot, "src", "content");
    if (!fs3.existsSync(expectedContentPath) || !fs3.statSync(expectedContentPath).isDirectory()) {
      return null;
    }
    const vaultRoot = vault.getRoot();
    if (!(vaultRoot instanceof import_obsidian5.TFolder)) {
      return null;
    }
    const vaultNormalized = path3.resolve(vaultPath).toLowerCase();
    const contentNormalized = path3.resolve(expectedContentPath).toLowerCase();
    if (contentNormalized.startsWith(vaultNormalized)) {
      const relativePath = path3.relative(path3.resolve(vaultPath), path3.resolve(expectedContentPath));
      const normalizedRelativePath = relativePath.split(path3.sep).join("/");
      const pathParts = normalizedRelativePath.split("/").filter((part) => part.length > 0);
      if (pathParts.length === 0) {
        return vaultRoot;
      }
      let currentFolder = vaultRoot;
      for (const part of pathParts) {
        if (!currentFolder.children) {
          return null;
        }
        const child = currentFolder.children.find((c) => c instanceof import_obsidian5.TFolder && c.name === part);
        if (!(child instanceof import_obsidian5.TFolder)) {
          return null;
        }
        currentFolder = child;
      }
      return currentFolder;
    }
    return null;
  }
  /**
   * Fallback: detect content types from vault root (old behavior)
   * This is used when we can't find src/content, e.g., when vault is inside a content type folder
   */
  detectContentTypesFromVaultRoot() {
    const vault = this.app.vault;
    const root = vault.getRoot();
    if (!(root instanceof import_obsidian5.TFolder)) {
      return [];
    }
    const contentTypes = [];
    const folders = this.getTopLevelFolders(root);
    for (const folder of folders) {
      const contentType = this.detectContentType(folder);
      if (contentType) {
        contentTypes.push(contentType);
      }
    }
    return contentTypes;
  }
  getTopLevelFolders(folder) {
    const folders = [];
    if (!folder.children) {
      return folders;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian5.TFolder) {
        const configDir = this.app.vault.configDir;
        if (!child.name.startsWith(".") && child.name !== "bases" && child.name !== "_bases" && child.name !== "node_modules" && child.name !== configDir) {
          folders.push(child);
        }
      }
    }
    return folders;
  }
  detectContentType(folder) {
    const name = this.capitalizeFirst(folder.name);
    return {
      id: `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
      name,
      folder: folder.path,
      // Use vault-relative path instead of just the folder name
      fileOrganization: "file",
      enabled: true,
      // Enable all discovered content types by default
      indexFileName: "index"
    };
  }
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
};

// src/ui/wizard/ProjectDetectionStep.ts
function setCssProps2(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var ProjectDetectionStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.detected = false;
    this.projectRootDisplay = null;
    this.configFileDisplay = null;
    this.projectDetector = new ProjectDetector(app);
    this.mdxDetector = new MdxDetector(app);
    this.contentTypeDetector = new ContentTypeDetector(app);
  }
  async display() {
    var _a, _b;
    console.debug("ProjectDetectionStep.display: called");
    const { containerEl } = this;
    containerEl.empty();
    const hasSavedValues = ((_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot) && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath);
    console.debug("ProjectDetectionStep.display: hasSavedValues =", hasSavedValues);
    console.debug("ProjectDetectionStep.display: current enableMdxSupport =", this.state.enableMdxSupport);
    if (!hasSavedValues) {
      containerEl.createEl("h2", { text: "Project detection" });
      containerEl.createEl("p", {
        // False positive: "Astro" is a proper noun (framework name) and should be capitalized
        // eslint-disable-next-line obsidianmd/ui/sentence-case
        text: "Detecting your Astro project structure..."
      });
      const result = this.projectDetector.detectProject();
      console.debug("ProjectDetectionStep.display: detection result =", result);
      if (result) {
        const relativeProjectRoot = this.toRelativePath(result.projectRoot);
        const relativeConfigFilePath = this.toRelativePath(result.configFilePath);
        this.state.projectDetection = {
          projectRoot: relativeProjectRoot,
          configFilePath: relativeConfigFilePath,
          vaultLocation: result.vaultLocation
        };
        console.debug("ProjectDetectionStep.display: set projectDetection =", this.state.projectDetection);
        this.detected = true;
      } else {
        this.detected = false;
      }
    } else {
      console.debug("ProjectDetectionStep.display: using saved projectDetection =", this.state.projectDetection);
      this.detected = true;
    }
    if (this.state.projectDetection && (this.detected || hasSavedValues)) {
      await new Promise((resolve6) => setTimeout(resolve6, 500));
      containerEl.empty();
      containerEl.createEl("h2", { text: "Project detected" });
      containerEl.createEl("p", {
        // eslint-disable-next-line obsidianmd/ui/sentence-case
        text: 'Project structure detected successfully. You can modify the paths below if needed, then click "Next" to continue.'
      });
      const projectRootSetting = new import_obsidian6.Setting(containerEl).setName("Project root").setDesc("Select the folder containing your Astro project root");
      this.projectRootDisplay = projectRootSetting.descEl.createDiv({
        text: this.state.projectDetection.projectRoot || "No folder selected",
        cls: "vault-cms-path-display"
      });
      setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
      projectRootSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          const selectedPath = this.selectFolder();
          if (selectedPath) {
            this.state.projectDetection.projectRoot = selectedPath;
            if (this.projectRootDisplay) {
              this.projectRootDisplay.textContent = selectedPath;
              setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
            }
            this.detected = false;
          }
        })();
      }));
      const configFileSetting = new import_obsidian6.Setting(containerEl).setName("Config file").setDesc("Select your Astro config file (astro.config.mjs, astro.config.js, src/config.ts, etc.)");
      this.configFileDisplay = configFileSetting.descEl.createDiv({
        text: this.state.projectDetection.configFilePath || "No file selected",
        cls: "vault-cms-path-display"
      });
      setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
      configFileSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          var _a2;
          const defaultPath = ((_a2 = this.state.projectDetection) == null ? void 0 : _a2.projectRoot) || this.getVaultPath();
          const selectedPath = this.selectConfigFile(defaultPath);
          if (selectedPath) {
            this.state.projectDetection.configFilePath = selectedPath;
            if (this.configFileDisplay) {
              this.configFileDisplay.textContent = selectedPath;
              setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
            }
            this.detected = false;
          }
        })();
      }));
      let autoDetectedMdx = false;
      if (this.state.projectDetection) {
        try {
          console.debug("ProjectDetectionStep: Starting MDX detection");
          console.debug("ProjectDetectionStep: projectDetection =", this.state.projectDetection);
          console.debug("ProjectDetectionStep: existing contentTypes =", this.state.contentTypes.length);
          let contentTypesToUse = this.state.contentTypes;
          if (contentTypesToUse.length === 0) {
            console.debug("ProjectDetectionStep: No content types in state, detecting now...");
            contentTypesToUse = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
            console.debug("ProjectDetectionStep: Detected content types =", contentTypesToUse.length, contentTypesToUse.map((ct) => `${ct.name} (${ct.folder}, enabled: ${ct.enabled})`));
          } else {
            console.debug("ProjectDetectionStep: Using existing content types =", contentTypesToUse.map((ct) => `${ct.name} (${ct.folder}, enabled: ${ct.enabled})`));
          }
          if (contentTypesToUse.length > 0) {
            console.debug("ProjectDetectionStep: Calling mdxDetector.detectMdxUsage...");
            autoDetectedMdx = this.mdxDetector.detectMdxUsage(
              this.state.projectDetection,
              contentTypesToUse
            );
            console.debug("ProjectDetectionStep: MDX detection result =", autoDetectedMdx);
          } else {
            console.debug("ProjectDetectionStep: No content types to scan");
          }
        } catch (error) {
          console.error("ProjectDetectionStep: MDX detection failed:", error);
          autoDetectedMdx = false;
        }
      } else {
        console.debug("ProjectDetectionStep: No projectDetection, skipping MDX detection");
      }
      if (this.state.enableMdxSupport === void 0) {
        this.state.enableMdxSupport = autoDetectedMdx;
        console.debug("ProjectDetectionStep: Set enableMdxSupport to", autoDetectedMdx, "based on auto-detection");
      } else {
        console.debug("ProjectDetectionStep: enableMdxSupport already set to", this.state.enableMdxSupport, ", skipping auto-detection overwrite");
      }
      const mdxSetting = new import_obsidian6.Setting(containerEl).setName("MDX file support").setDesc("Enable MDX file support for Astro Composer, Property Over File Name, SEO, and UI Tweaker plugins.");
      mdxSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableMdxSupport) != null ? _a2 : false).onChange((value) => {
          this.state.enableMdxSupport = value;
        });
        if (autoDetectedMdx && this.state.enableMdxSupport) {
          const autoDetectMsg = mdxSetting.descEl.createDiv({
            text: "MDX files detected in content folders",
            cls: "vault-cms-auto-detect-msg"
          });
          setCssProps2(autoDetectMsg, {
            color: "var(--text-muted)",
            fontSize: "0.9em",
            marginTop: "4px"
          });
        }
      });
    } else {
      containerEl.empty();
      containerEl.createEl("h2", { text: "Project detection failed" });
      containerEl.createEl("p", {
        // False positive: "Astro" is a proper noun (framework name) and should be capitalized
        // eslint-disable-next-line obsidianmd/ui/sentence-case
        text: "Could not detect Astro project structure. Please select your Astro project root and config file manually."
      });
      if (!this.state.projectDetection) {
        this.state.projectDetection = {
          projectRoot: "",
          configFilePath: "",
          vaultLocation: "root"
        };
      }
      const projectRootSetting = new import_obsidian6.Setting(containerEl).setName("Project root").setDesc("Select the folder containing your Astro project root");
      this.projectRootDisplay = projectRootSetting.descEl.createDiv({
        text: this.state.projectDetection.projectRoot || "No folder selected",
        cls: "vault-cms-path-display"
      });
      if (this.state.projectDetection.projectRoot) {
        setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
      } else {
        setCssProps2(this.projectRootDisplay, { color: "var(--text-muted)" });
      }
      projectRootSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          const selectedPath = this.selectFolder();
          if (selectedPath) {
            this.state.projectDetection.projectRoot = selectedPath;
            if (this.projectRootDisplay) {
              this.projectRootDisplay.textContent = selectedPath;
              setCssProps2(this.projectRootDisplay, { color: "var(--text-normal)" });
            }
          }
        })();
      }));
      const configFileSetting = new import_obsidian6.Setting(containerEl).setName("Config file").setDesc("Select your Astro config file (astro.config.mjs, astro.config.js, src/config.ts, etc.)");
      this.configFileDisplay = configFileSetting.descEl.createDiv({
        text: this.state.projectDetection.configFilePath || "No file selected",
        cls: "vault-cms-path-display"
      });
      if (this.state.projectDetection.configFilePath) {
        setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
      } else {
        setCssProps2(this.configFileDisplay, { color: "var(--text-muted)" });
      }
      configFileSetting.addButton((button) => button.setButtonText("Browse...").setCta().onClick(() => {
        (() => {
          var _a2;
          const defaultPath = ((_a2 = this.state.projectDetection) == null ? void 0 : _a2.projectRoot) || this.getVaultPath();
          const selectedPath = this.selectConfigFile(defaultPath);
          if (selectedPath) {
            this.state.projectDetection.configFilePath = selectedPath;
            if (this.configFileDisplay) {
              this.configFileDisplay.textContent = selectedPath;
              setCssProps2(this.configFileDisplay, { color: "var(--text-normal)" });
            }
          }
        })();
      }));
      let autoDetectedMdx = false;
      if (this.state.projectDetection && this.state.projectDetection.projectRoot && this.state.projectDetection.configFilePath) {
        try {
          const detectedContentTypes = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
          if (detectedContentTypes.length > 0) {
            autoDetectedMdx = this.mdxDetector.detectMdxUsage(
              this.state.projectDetection,
              detectedContentTypes
            );
          }
        } catch (e) {
          autoDetectedMdx = false;
        }
      }
      if (this.state.enableMdxSupport === void 0) {
        this.state.enableMdxSupport = autoDetectedMdx;
        console.debug("ProjectDetectionStep (manual): Set enableMdxSupport to", autoDetectedMdx, "based on auto-detection");
      } else {
        console.debug("ProjectDetectionStep (manual): enableMdxSupport already set to", this.state.enableMdxSupport, ", skipping auto-detection overwrite");
      }
      const mdxSetting = new import_obsidian6.Setting(containerEl).setName("MDX file support").setDesc("Enable MDX file support for Astro Composer, Property Over File Name, SEO, and UI Tweaker plugins.");
      mdxSetting.addToggle((toggle) => {
        var _a2;
        toggle.setValue((_a2 = this.state.enableMdxSupport) != null ? _a2 : false).onChange((value) => {
          this.state.enableMdxSupport = value;
        });
        if (autoDetectedMdx && this.state.enableMdxSupport) {
          const autoDetectMsg = mdxSetting.descEl.createDiv({
            text: "MDX files detected in content folders",
            cls: "vault-cms-auto-detect-msg"
          });
          setCssProps2(autoDetectMsg, {
            color: "var(--text-muted)",
            fontSize: "0.9em",
            marginTop: "4px"
          });
        }
      });
    }
  }
  /**
   * Open native folder picker dialog
   */
  selectFolder() {
    var _a, _b, _c;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      let defaultPath = ((_c = this.state.projectDetection) == null ? void 0 : _c.projectRoot) || vaultPath;
      if (defaultPath && !path4.isAbsolute(defaultPath)) {
        defaultPath = path4.resolve(vaultPath, defaultPath);
      }
      const result = dialog.showOpenDialogSync({
        title: "Select Astro Project Root Folder",
        defaultPath,
        properties: ["openDirectory"]
      });
      if (result && result.length > 0) {
        const absolutePath = path4.normalize(result[0]);
        return this.toRelativePath(absolutePath);
      }
    } catch (error) {
      console.error("Error opening folder picker:", error);
      new import_obsidian6.Notice("Unable to open folder picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Open native file picker dialog for config file
   */
  selectConfigFile(defaultPath) {
    var _a, _b, _c;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      let startPath = defaultPath || vaultPath;
      if (!defaultPath && ((_c = this.state.projectDetection) == null ? void 0 : _c.configFilePath)) {
        const configPath = this.state.projectDetection.configFilePath;
        if (path4.isAbsolute(configPath)) {
          startPath = path4.dirname(configPath);
        } else {
          startPath = path4.dirname(path4.resolve(vaultPath, configPath));
        }
      } else if (defaultPath && !path4.isAbsolute(defaultPath)) {
        startPath = path4.resolve(vaultPath, defaultPath);
        if (path4.extname(startPath)) {
          startPath = path4.dirname(startPath);
        }
      } else if (defaultPath && path4.isAbsolute(defaultPath)) {
        if (path4.extname(defaultPath)) {
          startPath = path4.dirname(defaultPath);
        } else {
          startPath = defaultPath;
        }
      }
      const result = dialog.showOpenDialogSync({
        title: "Select Astro Config File",
        defaultPath: startPath,
        filters: [
          { name: "Astro Config Files", extensions: ["ts", "mjs", "js", "mts", "cjs"] },
          { name: "All Files", extensions: ["*"] }
        ],
        properties: ["openFile"]
      });
      if (result && result.length > 0) {
        const absolutePath = path4.normalize(result[0]);
        return this.toRelativePath(absolutePath);
      }
    } catch (error) {
      console.error("Error opening file picker:", error);
      new import_obsidian6.Notice("Unable to open file picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (vaultPath) {
      if (vaultPath.startsWith("/") || /^[A-Z]:/.test(vaultPath)) {
        return vaultPath.replace(/\\/g, "/");
      }
      return vaultPath.replace(/\\/g, "/");
    }
    return "/";
  }
  /**
   * Convert absolute path to relative path from vault root
   */
  toRelativePath(absolutePath) {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return absolutePath;
    }
    const vaultNormalized = vaultPath.replace(/\\/g, "/").replace(/\/$/, "");
    const absoluteNormalized = absolutePath.replace(/\\/g, "/").replace(/\/$/, "");
    if (absoluteNormalized.startsWith(vaultNormalized)) {
      const relative4 = absoluteNormalized.slice(vaultNormalized.length);
      const trimmedRelative = relative4.startsWith("/") ? relative4.slice(1) : relative4;
      return trimmedRelative || ".";
    }
    try {
      const vaultParts = vaultNormalized.split("/").filter((p) => p);
      const absoluteParts = absoluteNormalized.split("/").filter((p) => p);
      let commonLength = 0;
      while (commonLength < vaultParts.length && commonLength < absoluteParts.length && vaultParts[commonLength] === absoluteParts[commonLength]) {
        commonLength++;
      }
      const upLevels = vaultParts.length - commonLength;
      const relativeParts = absoluteParts.slice(commonLength);
      const relative4 = (upLevels > 0 ? "../".repeat(upLevels) : "") + relativeParts.join("/");
      return relative4 || absolutePath;
    } catch (e) {
      return absolutePath;
    }
  }
  validate() {
    var _a, _b;
    if (this.detected) {
      return true;
    }
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    const configFilePath = (_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath;
    if (!projectRoot || !configFilePath) {
      return false;
    }
    try {
      const vaultPath = this.getVaultPath();
      const resolvedProjectRoot = path4.isAbsolute(projectRoot) ? projectRoot : path4.join(vaultPath, projectRoot);
      const resolvedConfigFilePath = path4.isAbsolute(configFilePath) ? configFilePath : path4.join(vaultPath, configFilePath);
      if (!fs4.existsSync(resolvedProjectRoot) || !fs4.statSync(resolvedProjectRoot).isDirectory()) {
        return false;
      }
      if (!fs4.existsSync(resolvedConfigFilePath) || !fs4.statSync(resolvedConfigFilePath).isFile()) {
        return false;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  getTitle() {
    return "Project detection";
  }
  getDescription() {
    return "Detect Astro project structure";
  }
};

// src/ui/wizard/ContentTypeStep.ts
var import_obsidian8 = require("obsidian");

// src/utils/AstroComposerConfig.ts
var import_obsidian7 = require("obsidian");

// src/utils/PathResolver.ts
var path5 = __toESM(require("path"), 1);
var PathResolver = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Get the folder path from vault root to the content type folder.
   * This is used by Bases CMS filters and Astro Composer folder settings.
   * 
   * Examples:
   * - Vault at src level, content type "docs": returns "content/docs"
   * - Vault at src/content level, content type "docs": returns "docs"
   * - Vault at src/content/post level, content type "docs": returns "../docs" (if accessible) or "docs" (if vault is the content type folder)
   * 
   * @param folderName The content type folder name (e.g., "docs", "posts")
   * @param projectDetection Project detection result with project root and vault location
   * @returns Path from vault root to content type folder, or null if cannot be determined
   */
  getFolderPathFromVaultRoot(folderName, projectDetection) {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    const file = this.app.vault.getAbstractFileByPath(folderName);
    if (file) {
      return folderName;
    }
    if (projectDetection && projectDetection.projectRoot && vaultPath) {
      const projectRoot = path5.isAbsolute(projectDetection.projectRoot) ? projectDetection.projectRoot : path5.resolve(vaultPath, projectDetection.projectRoot);
      let contentTypeAbsolutePath;
      if (folderName.startsWith("src/content/") || folderName.includes("/src/content/")) {
        contentTypeAbsolutePath = path5.resolve(projectRoot, folderName);
      } else {
        contentTypeAbsolutePath = path5.resolve(projectRoot, "src", "content", folderName);
      }
      const vaultAbsolutePath = path5.resolve(vaultPath);
      const relativePath = path5.relative(vaultAbsolutePath, contentTypeAbsolutePath);
      if (!relativePath.startsWith("..") && !path5.isAbsolute(relativePath)) {
        return relativePath.split(path5.sep).join("/") || ".";
      }
    }
    return folderName;
  }
  /**
   * Get the folder path from project root to the content type folder.
   * This is always "src/content/{folderName}" relative to project root.
   * 
   * @param folderName The content type folder name (e.g., "docs", "posts")
   * @returns Path from project root (e.g., "src/content/docs")
   */
  getFolderPathFromProjectRoot(folderName) {
    return `src/content/${folderName}`;
  }
  /**
   * Get the folder path for Astro Composer, which needs the path relative to vault root
   * but should work correctly regardless of vault location.
   * 
   * @param folderName The content type folder name
   * @param projectDetection Project detection result
   * @returns Path from vault root to content type folder
   */
  getAstroComposerFolderPath(folderName, projectDetection) {
    return this.getFolderPathFromVaultRoot(folderName, projectDetection);
  }
  /**
   * Get the folder path for Bases CMS filter, which needs to match files
   * in the content type folder regardless of vault location.
   * 
   * @param folderName The content type folder name
   * @param projectDetection Project detection result
   * @returns Path from vault root to content type folder (for use in file.folder.startsWith filter)
   */
  getBasesCMSFolderPath(folderName, projectDetection) {
    return this.getFolderPathFromVaultRoot(folderName, projectDetection);
  }
};

// src/utils/AstroComposerConfig.ts
var AstroComposerConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
  }
  configureAstroComposer(contentTypes, frontmatterProperties, projectRoot, configFilePath, defaultContentTypeId, projectDetection, enableMdxSupport) {
    this.frontmatterProperties = frontmatterProperties;
    this.contentTypes = contentTypes;
    const config = {
      customContentTypes: [],
      defaultTemplate: "",
      configFilePath: this.relativePath(configFilePath),
      terminalProjectRootPath: this.relativePath(projectRoot),
      showMdxFilesInExplorer: enableMdxSupport != null ? enableMdxSupport : false
    };
    const defaultContentType = defaultContentTypeId ? contentTypes.find((ct) => ct.id === defaultContentTypeId && ct.enabled) : null;
    const otherContentTypes = contentTypes.filter((ct) => ct.enabled && (!defaultContentTypeId || ct.id !== defaultContentTypeId));
    if (defaultContentType) {
      const props = frontmatterProperties[defaultContentType.id];
      let linkBasePath = defaultContentType.linkBasePath;
      if (linkBasePath === void 0 || linkBasePath === "") {
        const pathParts = defaultContentType.folder.split("/").filter((p) => p.length > 0);
        const folderName = pathParts[pathParts.length - 1] || defaultContentType.folder;
        linkBasePath = `/${folderName}/`;
      }
      const folderPath = this.pathResolver.getAstroComposerFolderPath(defaultContentType.folder, projectDetection);
      config.customContentTypes.push({
        id: defaultContentType.id,
        name: defaultContentType.name,
        folder: folderPath,
        template: (props == null ? void 0 : props.template) || this.generateTemplate(props),
        enabled: true,
        linkBasePath,
        creationMode: defaultContentType.fileOrganization,
        indexFileName: defaultContentType.indexFileName || "index"
      });
      config.postsFolder = folderPath;
      config.postsCreationMode = defaultContentType.fileOrganization;
      config.postsIndexFileName = defaultContentType.indexFileName || "index";
      config.defaultTemplate = (props == null ? void 0 : props.template) || this.generateTemplate(props);
    }
    for (const contentType of otherContentTypes) {
      const props = frontmatterProperties[contentType.id];
      let linkBasePath = contentType.linkBasePath;
      if (linkBasePath === void 0 || linkBasePath === "") {
        const pathParts = contentType.folder.split("/").filter((p) => p.length > 0);
        const folderName = pathParts[pathParts.length - 1] || contentType.folder;
        linkBasePath = `/${folderName}/`;
      }
      const folderPath = this.pathResolver.getAstroComposerFolderPath(contentType.folder, projectDetection);
      config.customContentTypes.push({
        id: contentType.id,
        name: contentType.name,
        folder: folderPath,
        // Use template from props if available, otherwise generate
        template: (props == null ? void 0 : props.template) || this.generateTemplate(props),
        enabled: true,
        linkBasePath,
        creationMode: contentType.fileOrganization,
        indexFileName: contentType.indexFileName || "index"
      });
    }
    return Promise.resolve(config);
  }
  generateTemplate(props) {
    if (props == null ? void 0 : props.template) {
      return props.template;
    }
    if (!props) {
      return '---\ntitle: "{{title}}"\n---\n';
    }
    let template = "---\n";
    template += `${props.titleProperty || "title"}: "{{title}}"
`;
    if (props.dateProperty) {
      template += `${props.dateProperty}: {{date}}
`;
    }
    if (props.descriptionProperty) {
      template += `${props.descriptionProperty}: ""
`;
    }
    if (props.tagsProperty) {
      template += `${props.tagsProperty}: []
`;
    }
    if (props.draftProperty) {
      const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
      template += `${props.draftProperty}: ${draftValue}
`;
    }
    template += "---\n";
    return template;
  }
  getCreationModeFromAttachmentHandling(mode) {
    return mode === "same-folder" ? "folder" : "file";
  }
  relativePath(inputPath) {
    if (!inputPath.startsWith("/") && !/^[A-Z]:/.test(inputPath)) {
      return inputPath;
    }
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (!vaultPath) {
      return inputPath;
    }
    const vaultNormalized = vaultPath.replace(/\\/g, "/").replace(/\/$/, "");
    const absoluteNormalized = inputPath.replace(/\\/g, "/").replace(/\/$/, "");
    if (absoluteNormalized.startsWith(vaultNormalized)) {
      const relative4 = absoluteNormalized.slice(vaultNormalized.length);
      return relative4.startsWith("/") ? relative4.slice(1) : relative4;
    }
    return inputPath;
  }
  async saveConfig(config) {
    var _a, _b;
    try {
      const plugins = this.app.plugins;
      const astroComposerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["astro-composer"];
      if (!astroComposerPlugin) {
        console.warn("AstroComposerConfig: Astro Composer plugin not found, using fallback file method");
        await this.saveConfigFallback(config);
        return;
      }
      if (!astroComposerPlugin.settings) {
        console.warn("AstroComposerConfig: Astro Composer plugin settings not available, using fallback file method");
        await this.saveConfigFallback(config);
        return;
      }
      const pluginSettings = astroComposerPlugin.settings;
      if (config.defaultTemplate) {
        pluginSettings.defaultTemplate = config.defaultTemplate;
      }
      if (config.pageTemplate) {
        pluginSettings.pageTemplate = config.pageTemplate;
      }
      if (config.postsFolder) {
        pluginSettings.postsFolder = config.postsFolder;
      }
      if (config.postsCreationMode) {
        pluginSettings.creationMode = config.postsCreationMode;
      }
      if (config.postsIndexFileName) {
        pluginSettings.indexFileName = config.postsIndexFileName;
      }
      if (config.enablePages !== void 0) {
        pluginSettings.enablePages = config.enablePages;
      }
      if (config.pagesFolder) {
        pluginSettings.pagesFolder = config.pagesFolder;
      }
      if (config.pagesCreationMode) {
        pluginSettings.pagesCreationMode = config.pagesCreationMode;
      }
      if (config.pagesIndexFileName) {
        pluginSettings.pagesIndexFileName = config.pagesIndexFileName;
      }
      if (config.configFilePath) {
        pluginSettings.configFilePath = config.configFilePath;
      }
      if (config.terminalProjectRootPath) {
        pluginSettings.terminalProjectRootPath = config.terminalProjectRootPath;
      }
      if (config.configFilePath && config.terminalProjectRootPath) {
        pluginSettings.enableOpenTerminalCommand = true;
        pluginSettings.enableOpenConfigFileCommand = true;
        pluginSettings.enableTerminalRibbonIcon = true;
        pluginSettings.enableConfigRibbonIcon = true;
      }
      if (config.showMdxFilesInExplorer !== void 0) {
        pluginSettings.showMdxFilesInExplorer = config.showMdxFilesInExplorer;
        console.debug("AstroComposerConfig: Set showMdxFilesInExplorer to", config.showMdxFilesInExplorer);
      } else {
        console.debug("AstroComposerConfig: showMdxFilesInExplorer is undefined, not updating");
      }
      if (!Array.isArray(pluginSettings.contentTypes)) {
        pluginSettings.contentTypes = [];
      }
      for (const newType of config.customContentTypes) {
        const contentType = (_b = this.contentTypes) == null ? void 0 : _b.find((ct) => ct.id === newType.id);
        const props = contentType && this.frontmatterProperties ? this.frontmatterProperties[contentType.id] : void 0;
        const shouldEnableUnderscorePrefix = (props == null ? void 0 : props.hasDraftStatus) === true && !(props == null ? void 0 : props.draftProperty);
        const contentTypes = pluginSettings.contentTypes || [];
        const existingIndex = contentTypes.findIndex(
          (ct) => ct.name === newType.name && ct.folder === newType.folder
        );
        if (existingIndex >= 0) {
          const existingEntry = contentTypes[existingIndex];
          contentTypes[existingIndex] = {
            ...existingEntry,
            name: newType.name,
            folder: newType.folder,
            linkBasePath: newType.linkBasePath,
            template: newType.template,
            enabled: newType.enabled,
            creationMode: newType.creationMode,
            indexFileName: newType.indexFileName,
            enableUnderscorePrefix: shouldEnableUnderscorePrefix
          };
        } else {
          contentTypes.push({
            id: newType.id,
            name: newType.name,
            folder: newType.folder,
            linkBasePath: newType.linkBasePath,
            template: newType.template,
            enabled: newType.enabled,
            creationMode: newType.creationMode,
            indexFileName: newType.indexFileName,
            ignoreSubfolders: false,
            enableUnderscorePrefix: shouldEnableUnderscorePrefix
          });
        }
      }
      pluginSettings.customContentTypes = this.mergeCustomContentTypes(
        pluginSettings.customContentTypes || [],
        config.customContentTypes || []
      );
      if (typeof astroComposerPlugin.saveSettings === "function") {
        await astroComposerPlugin.saveSettings();
        console.debug("AstroComposerConfig: Successfully saved via plugin.saveSettings()");
      } else {
        console.warn("AstroComposerConfig: Plugin saveSettings not available, using fallback");
        await this.saveConfigFallback(config);
      }
    } catch (error) {
      console.error("Failed to save Astro Composer config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    var _a;
    const pluginId = "astro-composer";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian7.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Astro Composer data.json, starting fresh:", error);
        existingData = {};
      }
    }
    if (config.defaultTemplate) existingData.defaultTemplate = config.defaultTemplate;
    if (config.pageTemplate) existingData.pageTemplate = config.pageTemplate;
    if (config.postsFolder) existingData.postsFolder = config.postsFolder;
    if (config.postsCreationMode) existingData.creationMode = config.postsCreationMode;
    if (config.postsIndexFileName) existingData.indexFileName = config.postsIndexFileName;
    if (config.enablePages !== void 0) existingData.enablePages = config.enablePages;
    if (config.pagesFolder) existingData.pagesFolder = config.pagesFolder;
    if (config.pagesCreationMode) existingData.pagesCreationMode = config.pagesCreationMode;
    if (config.pagesIndexFileName) existingData.pagesIndexFileName = config.pagesIndexFileName;
    if (config.configFilePath) existingData.configFilePath = config.configFilePath;
    if (config.terminalProjectRootPath) existingData.terminalProjectRootPath = config.terminalProjectRootPath;
    if (config.showMdxFilesInExplorer !== void 0) existingData.showMdxFilesInExplorer = config.showMdxFilesInExplorer;
    if (config.configFilePath && config.terminalProjectRootPath) {
      existingData.enableOpenTerminalCommand = true;
      existingData.enableOpenConfigFileCommand = true;
      existingData.enableTerminalRibbonIcon = true;
      existingData.enableConfigRibbonIcon = true;
    }
    if (!Array.isArray(existingData.contentTypes)) {
      existingData.contentTypes = [];
    }
    for (const newType of config.customContentTypes) {
      const contentType = (_a = this.contentTypes) == null ? void 0 : _a.find((ct) => ct.id === newType.id);
      const props = contentType && this.frontmatterProperties ? this.frontmatterProperties[contentType.id] : void 0;
      const shouldEnableUnderscorePrefix = (props == null ? void 0 : props.hasDraftStatus) === true && !(props == null ? void 0 : props.draftProperty);
      const contentTypes = existingData.contentTypes || [];
      const existingIndex = contentTypes.findIndex(
        (ct) => ct.name === newType.name && ct.folder === newType.folder
      );
      if (existingIndex >= 0) {
        const existingEntry = contentTypes[existingIndex];
        contentTypes[existingIndex] = {
          ...existingEntry,
          name: newType.name,
          folder: newType.folder,
          linkBasePath: newType.linkBasePath,
          template: newType.template,
          enabled: newType.enabled,
          creationMode: newType.creationMode,
          indexFileName: newType.indexFileName,
          enableUnderscorePrefix: shouldEnableUnderscorePrefix
        };
      } else {
        contentTypes.push({
          id: newType.id,
          name: newType.name,
          folder: newType.folder,
          linkBasePath: newType.linkBasePath,
          template: newType.template,
          enabled: newType.enabled,
          creationMode: newType.creationMode,
          indexFileName: newType.indexFileName,
          ignoreSubfolders: false,
          enableUnderscorePrefix: shouldEnableUnderscorePrefix
        });
      }
    }
    existingData.customContentTypes = this.mergeCustomContentTypes(
      existingData.customContentTypes || [],
      config.customContentTypes || []
    );
    if (dataFile && dataFile instanceof import_obsidian7.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(existingData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        await this.app.vault.createFolder(pluginDir);
      }
      await this.app.vault.create(pluginDataPath, JSON.stringify(existingData, null, 2));
    }
  }
  mergeCustomContentTypes(existing, newTypes) {
    const merged = [...existing];
    for (const newType of newTypes) {
      const existingIndex = merged.findIndex((ct) => ct.id === newType.id);
      if (existingIndex >= 0) {
        merged[existingIndex] = { ...merged[existingIndex], ...newType };
      } else {
        merged.push(newType);
      }
    }
    return merged;
  }
};

// src/ui/wizard/ContentTypeStep.ts
function setCssProps3(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var FolderNameSuggest = class extends import_obsidian8.AbstractInputSuggest {
  constructor(app, inputEl, mode) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.mode = mode;
  }
  getSuggestions(inputStr) {
    const suggestions = [];
    const lowerInput = inputStr.toLowerCase();
    if (this.mode === "subfolder") {
      if ("attachments".toLowerCase().includes(lowerInput)) {
        suggestions.push("attachments");
      }
      const allFiles = this.app.vault.getAllLoadedFiles();
      const folderNames = /* @__PURE__ */ new Set();
      for (const file of allFiles) {
        if (file instanceof import_obsidian8.TFolder) {
          const folderName = file.name;
          if (folderName.toLowerCase().includes(lowerInput) && folderName !== "attachments") {
            folderNames.add(folderName);
          }
        }
      }
      suggestions.push(...Array.from(folderNames).slice(0, 10));
    } else {
      const allFiles = this.app.vault.getAllLoadedFiles();
      const paths = /* @__PURE__ */ new Set();
      for (const file of allFiles) {
        if (file instanceof import_obsidian8.TFolder) {
          const path7 = file.path;
          if (path7.toLowerCase().includes(lowerInput)) {
            paths.add(path7);
          }
        }
      }
      suggestions.push(...Array.from(paths).slice(0, 10));
    }
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    el.setText(suggestion);
  }
  selectSuggestion(suggestion) {
    this.inputEl.value = suggestion;
    this.inputEl.trigger("input");
    this.close();
  }
};
var ContentTypeStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.detected = false;
    this.contentTypeDetector = new ContentTypeDetector(app);
    this.astroComposerConfigurator = new AstroComposerConfigurator(app);
  }
  /**
   * Import content types from Astro Composer data.json if it exists
   * First tries plugin API, then falls back to file reading
   */
  async importFromAstroComposer() {
    var _a;
    try {
      const plugins = this.app.plugins;
      console.debug("ContentTypeStep: Checking plugins API:", !!plugins);
      if (plugins) {
        const astroComposerPlugin = (_a = plugins.plugins) == null ? void 0 : _a["astro-composer"];
        console.debug("ContentTypeStep: Astro Composer plugin found:", !!astroComposerPlugin);
        if (astroComposerPlugin) {
          console.debug("ContentTypeStep: Plugin settings available:", !!astroComposerPlugin.settings);
          console.debug("ContentTypeStep: Plugin settings keys:", astroComposerPlugin.settings ? Object.keys(astroComposerPlugin.settings) : "none");
          if (astroComposerPlugin.settings) {
            const contentTypes = astroComposerPlugin.settings.contentTypes;
            console.debug("ContentTypeStep: contentTypes from plugin:", contentTypes ? `Array with ${contentTypes.length} items` : "not found");
            if (Array.isArray(contentTypes) && contentTypes.length > 0) {
              console.debug("ContentTypeStep: Importing", contentTypes.length, "content types from Astro Composer (via plugin API)");
              const importedTypes2 = contentTypes.map((ct) => ({
                id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
                name: ct.name || this.capitalizeFirst(ct.folder),
                folder: ct.folder,
                fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
                indexFileName: ct.indexFileName || "index",
                linkBasePath: ct.linkBasePath,
                enabled: ct.enabled !== false
                // Default to enabled if not specified
              }));
              return importedTypes2;
            }
          }
        }
      }
      const configDir = this.app.vault.configDir;
      const pluginDataPath = `${configDir}/plugins/astro-composer/data.json`;
      console.debug("ContentTypeStep: Trying to read file:", pluginDataPath);
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      console.debug("ContentTypeStep: File found:", !!dataFile, dataFile ? `Type: ${dataFile.constructor.name}` : "not found");
      if (!dataFile || !(dataFile instanceof import_obsidian8.TFile)) {
        const altPaths = [
          `${configDir}/plugins/astro-composer/data.json`,
          `obsidian/plugins/astro-composer/data.json`
        ];
        for (const altPath of altPaths) {
          const altFile = this.app.vault.getAbstractFileByPath(altPath);
          if (altFile && altFile instanceof import_obsidian8.TFile) {
            console.debug("ContentTypeStep: Found file at alternative path:", altPath);
            const content2 = await this.app.vault.read(altFile);
            const data2 = JSON.parse(content2);
            if (data2.contentTypes && Array.isArray(data2.contentTypes)) {
              console.debug("ContentTypeStep: Importing", data2.contentTypes.length, "content types from Astro Composer (via file at", altPath, ")");
              const importedTypes2 = data2.contentTypes.map((ct) => ({
                id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
                name: ct.name || this.capitalizeFirst(ct.folder),
                folder: ct.folder,
                fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
                indexFileName: ct.indexFileName || "index",
                linkBasePath: ct.linkBasePath,
                enabled: ct.enabled !== false
              }));
              return importedTypes2;
            }
          }
        }
        console.debug("ContentTypeStep: No Astro Composer data.json found, will scan folders");
        return [];
      }
      const content = await this.app.vault.read(dataFile);
      const data = JSON.parse(content);
      if (!data.contentTypes || !Array.isArray(data.contentTypes)) {
        console.debug("ContentTypeStep: Astro Composer data.json has no contentTypes array. Data keys:", Object.keys(data));
        return [];
      }
      console.debug("ContentTypeStep: Importing", data.contentTypes.length, "content types from Astro Composer (via file)");
      const importedTypes = data.contentTypes.map((ct) => ({
        id: ct.id || `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
        name: ct.name || this.capitalizeFirst(ct.folder),
        folder: ct.folder,
        fileOrganization: ct.creationMode === "folder" ? "folder" : "file",
        indexFileName: ct.indexFileName || "index",
        linkBasePath: ct.linkBasePath,
        enabled: ct.enabled !== false
        // Default to enabled if not specified
      }));
      return importedTypes;
    } catch (error) {
      console.error("ContentTypeStep: Failed to import from Astro Composer:", error);
      return [];
    }
  }
  async display() {
    const { containerEl } = this;
    let stepContentWrapper = containerEl.querySelector(".content-type-step-content");
    if (!stepContentWrapper) {
      containerEl.empty();
      stepContentWrapper = containerEl.createDiv({ cls: "content-type-step-content" });
    } else {
      stepContentWrapper.empty();
    }
    stepContentWrapper.createEl("h2", { text: "Content types" });
    stepContentWrapper.createEl("p", {
      text: "Detecting content types in your vault..."
    });
    if (!this.detected) {
      const savedContentTypes = this.state.contentTypes || [];
      const savedContentTypesMap = new Map(savedContentTypes.map((ct) => [ct.folder, ct]));
      const importedTypes = await this.importFromAstroComposer();
      const scannedTypes = this.contentTypeDetector.detectContentTypes(this.state.projectDetection);
      const allDetectedTypes = [];
      const imported = [...importedTypes];
      for (const scanned of scannedTypes) {
        const matchingImportedIndex = imported.findIndex(
          (it) => scanned.folder === it.folder || scanned.folder.endsWith(`/${it.folder}`) || it.folder.endsWith(`/${scanned.folder}`)
        );
        if (matchingImportedIndex >= 0) {
          const importedType = imported[matchingImportedIndex];
          if (scanned.folder.length > importedType.folder.length) {
            console.debug(`ContentTypeStep: Updating imported type "${importedType.name}" folder from "${importedType.folder}" to "${scanned.folder}"`);
            imported[matchingImportedIndex] = {
              ...importedType,
              folder: scanned.folder
            };
          }
        } else {
          allDetectedTypes.push(scanned);
        }
      }
      allDetectedTypes.push(...imported);
      const detectedTypesMap = new Map(allDetectedTypes.map((ct) => [ct.folder, ct]));
      const mergedTypes = [];
      const processedFolders = /* @__PURE__ */ new Set();
      const allFolders = /* @__PURE__ */ new Set([
        ...savedContentTypes.map((ct) => ct.folder),
        ...allDetectedTypes.map((ct) => ct.folder)
      ]);
      for (const folder of allFolders) {
        if (processedFolders.has(folder)) continue;
        let savedType = savedContentTypesMap.get(folder);
        const detectedType = detectedTypesMap.get(folder);
        if (savedType && !detectedType) {
          const matchingDetected = allDetectedTypes.find(
            (dt) => dt.folder.endsWith(`/${folder}`) || dt.folder === folder
          );
          if (matchingDetected && !processedFolders.has(matchingDetected.folder)) {
            console.debug(`ContentTypeStep: Reconciling saved folder "${folder}" with detected folder "${matchingDetected.folder}"`);
            mergedTypes.push({
              ...savedType,
              folder: matchingDetected.folder
            });
            processedFolders.add(folder);
            processedFolders.add(matchingDetected.folder);
            continue;
          }
        }
        if (savedType) {
          if (detectedType) {
            mergedTypes.push({
              ...savedType,
              // Preserve all saved settings (enabled, custom name, linkBasePath, etc.)
              // Always preserve saved folder and name (user may have customized the name)
              folder: savedType.folder,
              name: savedType.name
              // Always use saved name (may be customized)
            });
          } else {
            mergedTypes.push(savedType);
          }
        } else if (detectedType) {
          mergedTypes.push(detectedType);
        }
        processedFolders.add(folder);
      }
      mergedTypes.sort((a, b) => a.name.localeCompare(b.name));
      this.state.contentTypes = mergedTypes;
      this.detected = true;
    }
    stepContentWrapper.empty();
    stepContentWrapper.createEl("h2", { text: "Content types" });
    stepContentWrapper.createEl("p", {
      text: "Select and configure your content types:"
    });
    stepContentWrapper.createEl("h3", { text: "Attachment handling", cls: "vault-cms-section-header" });
    stepContentWrapper.createEl("p", {
      text: "How should attachments be stored globally?",
      cls: "vault-cms-section-desc"
    });
    new import_obsidian8.Setting(stepContentWrapper).setName("How are attachments handled?").setDesc("Choose how attachments are stored for all content types").addDropdown((dropdown) => dropdown.addOption("same-folder", "Same folder as current file").addOption("specified-folder", "In the specified folder").addOption("subfolder", "In subfolder under current folder").setValue(this.state.attachmentHandlingMode || "subfolder").onChange((value) => {
      this.state.attachmentHandlingMode = value;
      if (value === "same-folder") {
        this.state.attachmentFolderName = void 0;
      }
      void this.display();
    }));
    if (this.state.attachmentHandlingMode === "specified-folder" || this.state.attachmentHandlingMode === "subfolder") {
      const descText = this.state.attachmentHandlingMode === "specified-folder" ? 'Enter the exact path to the folder for attachments (e.g., "attachments" or "images/attachments"). Leave blank to use "attachments" as default.' : 'Enter the name of the subfolder for attachments (e.g., "attachments"). Leave blank to use "attachments" as default.';
      const folderNameSetting = new import_obsidian8.Setting(stepContentWrapper).setName("Attachment folder").setDesc(descText);
      folderNameSetting.addText((text) => {
        text.setPlaceholder("attachments").setValue(this.state.attachmentFolderName || "").onChange((value) => {
          this.state.attachmentFolderName = value || void 0;
        });
        if (this.state.attachmentHandlingMode !== "same-folder") {
          new FolderNameSuggest(this.app, text.inputEl, this.state.attachmentHandlingMode);
        }
      });
    }
    stepContentWrapper.createEl("hr", { cls: "vault-cms-divider" });
    stepContentWrapper.createEl("h3", { text: "Content types", cls: "vault-cms-section-header" });
    for (const contentType of this.state.contentTypes) {
      const setting = new import_obsidian8.Setting(stepContentWrapper);
      const nameContainer = setting.nameEl.createDiv({ cls: "vault-cms-editable-name" });
      setCssProps3(nameContainer, { display: "flex", alignItems: "center", gap: "0.5rem" });
      const createNameDisplay = (name) => {
        nameContainer.empty();
        const display = nameContainer.createSpan({
          text: name,
          cls: "vault-cms-name-display"
        });
        const iconContainer = nameContainer.createDiv({ cls: "vault-cms-edit-icon" });
        setCssProps3(iconContainer, { opacity: "0.6" });
        (0, import_obsidian8.setIcon)(iconContainer, "lucide-pencil-line");
        const startEdit = () => {
          const currentName = contentType.name;
          nameContainer.empty();
          const nameInput = nameContainer.createEl("input", {
            type: "text",
            value: currentName
          });
          nameInput.addClass("mod-text-input");
          nameInput.focus();
          nameInput.select();
          const saveName = () => {
            nameInput.removeEventListener("blur", saveName);
            let newName = nameInput.value.trim();
            if (!newName) {
              newName = currentName;
            }
            newName = newName.replace(/[<>:"/\\|?*\x00-\x1F]/g, "");
            if (!newName.trim()) {
              newName = currentName;
            } else {
              newName = newName.trim();
            }
            contentType.name = newName;
            void this.display();
          };
          nameInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              saveName();
            } else if (e.key === "Escape") {
              e.preventDefault();
              createNameDisplay(currentName);
            }
          });
          nameInput.addEventListener("blur", saveName);
        };
        display.addEventListener("click", startEdit);
        iconContainer.addEventListener("click", startEdit);
        iconContainer.addEventListener("mouseenter", () => {
          setCssProps3(iconContainer, { opacity: "1" });
        });
        iconContainer.addEventListener("mouseleave", () => {
          setCssProps3(iconContainer, { opacity: "0.6" });
        });
        return display;
      };
      createNameDisplay(contentType.name);
      setting.setDesc(`Folder: ${contentType.folder}`).addToggle((toggle) => toggle.setValue(contentType.enabled).onChange((value) => {
        contentType.enabled = value;
      }));
      new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - File organization`).setDesc("Choose how content is organized for this content type").addDropdown((dropdown) => dropdown.addOption("file", "File-based").addOption("folder", "Folder-based").setValue(contentType.fileOrganization || "file").onChange((value) => {
        contentType.fileOrganization = value;
        void this.display();
      }));
      if (contentType.fileOrganization === "folder") {
        new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - Index file name`).setDesc("Name of the index file in folder-based organization").addText((text) => text.setValue(contentType.indexFileName || "index").onChange((value) => {
          contentType.indexFileName = value || "index";
        }));
      }
      const pathParts = contentType.folder.split("/").filter((p) => p.length > 0);
      const folderName = pathParts[pathParts.length - 1] || contentType.folder;
      const defaultLinkBasePath = `/${folderName}/`;
      new import_obsidian8.Setting(stepContentWrapper).setName(`${contentType.name} - Link base path`).setDesc(`URL path for this content type (e.g., "/posts/" or "/" for root). Leave blank to use default: ${defaultLinkBasePath}`).addText((text) => text.setPlaceholder(defaultLinkBasePath).setValue(contentType.linkBasePath || "").onChange((value) => {
        contentType.linkBasePath = value || void 0;
      }));
    }
    const addButton = stepContentWrapper.createEl("button", {
      text: "Add additional content type",
      cls: "mod-cta"
    });
    setCssProps3(addButton, { marginTop: "20px", marginBottom: "30px" });
    addButton.addEventListener("click", () => {
      void (async () => {
        const selectedFolder = this.selectContentTypeFolder();
        if (selectedFolder) {
          const vaultPath = this.getVaultPath();
          let folderPath = selectedFolder;
          if (selectedFolder.startsWith(vaultPath)) {
            folderPath = selectedFolder.substring(vaultPath.length).replace(/^[/\\]+/, "");
          }
          const pathParts = folderPath.split(/[/\\]/).filter((p) => p.length > 0);
          const leafFolderName = pathParts[pathParts.length - 1] || folderPath;
          const newType = {
            id: `content-type-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`,
            name: this.capitalizeFirst(leafFolderName),
            folder: folderPath,
            fileOrganization: "file",
            enabled: true,
            // Enable by default so it shows up in Step 5
            indexFileName: "index"
          };
          this.state.contentTypes.push(newType);
          await this.display();
        }
      })();
    });
  }
  /**
   * Select folder for additional content type
   */
  selectContentTypeFolder() {
    var _a, _b;
    try {
      let dialog = null;
      try {
        const electronRemote = require("@electron/remote");
        dialog = (electronRemote == null ? void 0 : electronRemote.dialog) || null;
      } catch (e) {
      }
      if (!dialog) {
        try {
          const electron = ((_a = window.require) == null ? void 0 : _a.call(window, "electron")) || require("electron");
          dialog = ((_b = electron == null ? void 0 : electron.remote) == null ? void 0 : _b.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog) {
        try {
          const electron = require("electron");
          dialog = (electron == null ? void 0 : electron.dialog) || null;
        } catch (e) {
        }
      }
      if (!dialog || typeof dialog.showOpenDialogSync !== "function") {
        throw new Error("Electron dialog API not available");
      }
      const vaultPath = this.getVaultPath();
      const result = dialog.showOpenDialogSync({
        title: "Select Content Type Folder",
        defaultPath: vaultPath,
        properties: ["openDirectory"]
      });
      if (result && result.length > 0) {
        return result[0].replace(/\\/g, "/").replace(/\/$/, "");
      }
    } catch (error) {
      console.error("Error opening folder picker:", error);
      new import_obsidian8.Notice("Unable to open folder picker. Please ensure you are using Obsidian on desktop.");
    }
    return null;
  }
  /**
   * Get the vault path
   */
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    const vaultPath = adapter.basePath || adapter.path;
    if (vaultPath) {
      if (vaultPath.startsWith("/") || /^[A-Z]:/.test(vaultPath)) {
        return vaultPath.replace(/\\/g, "/");
      }
      return vaultPath.replace(/\\/g, "/");
    }
    return "/";
  }
  /**
   * Capitalize first letter
   */
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  validate() {
    return this.state.contentTypes.some((ct) => ct.enabled);
  }
  getTitle() {
    return "Content types";
  }
  getDescription() {
    return "Configure content types";
  }
};

// src/ui/wizard/DefaultContentTypeStep.ts
var import_obsidian9 = require("obsidian");
var DefaultContentTypeStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Default content type" });
    containerEl.createEl("p", {
      text: "Select which content type should be used as the default. This will:"
    });
    const ul = containerEl.createEl("ul");
    ul.createEl("li", { text: "Set as the default Bases CMS view" });
    ul.createEl("li", { text: `Configure Obsidian's "Default location for new notes" to that folder.` });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    if (enabledTypes.length === 0) {
      containerEl.createEl("p", {
        text: "No enabled content types found. Please go back and enable at least one content type."
      });
      return;
    }
    if (!this.state.defaultContentTypeId || enabledTypes.findIndex((ct) => ct.id === this.state.defaultContentTypeId) === -1) {
      this.state.defaultContentTypeId = enabledTypes[0].id;
    }
    const selectedValue = this.state.defaultContentTypeId;
    new import_obsidian9.Setting(containerEl).setName("Default content type").setDesc("Choose the default content type for new notes").addDropdown((dropdown) => {
      enabledTypes.forEach((ct) => {
        dropdown.addOption(ct.id, ct.name);
      });
      dropdown.setValue(selectedValue);
      dropdown.onChange((value) => {
        this.state.defaultContentTypeId = value;
      });
    });
  }
  validate() {
    return !!this.state.defaultContentTypeId;
  }
  getTitle() {
    return "Default content type";
  }
  getDescription() {
    return "Select default content type";
  }
};

// src/ui/wizard/FrontmatterPropertiesStep.ts
var import_obsidian11 = require("obsidian");

// src/utils/FrontmatterAnalyzer.ts
var import_obsidian10 = require("obsidian");

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path7) {
  const ctrl = callVisitor(key, node, visitor, path7);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path7, ctrl);
    return visit_(key, ctrl, visitor, path7);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path7 = Object.freeze(path7.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path7);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path7 = Object.freeze(path7.concat(node));
      const ck = visit_("key", node.key, visitor, path7);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path7);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path7) {
  const ctrl = await callVisitor(key, node, visitor, path7);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path7, ctrl);
    return visitAsync_(key, ctrl, visitor, path7);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path7 = Object.freeze(path7.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path7);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path7 = Object.freeze(path7.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path7);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path7);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path7) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path7);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path7);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path7);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path7);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path7);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path7);
  return void 0;
}
function replaceNode(key, path7, node) {
  const parent = path7[path7.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class _Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      prevAnchors != null ? prevAnchors : prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc, ctx) {
    let nodes;
    if (ctx == null ? void 0 : ctx.aliasResolveCache) {
      nodes = ctx.aliasResolveCache;
    } else {
      nodes = [];
      visit(doc, {
        Node: (_key, node) => {
          if (isAlias(node) || hasAnchor(node))
            nodes.push(node);
        }
      });
      if (ctx)
        ctx.aliasResolveCache = nodes;
    }
    let found = void 0;
    for (const node of nodes) {
      if (node === this)
        break;
      if (node.anchor === this.source)
        found = node;
    }
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc, ctx);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if ((data == null ? void 0 : data.res) === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  var _a;
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = (_a = match.find((t) => !t.format)) != null ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => {
    var _a2;
    return ((_a2 = t.identify) == null ? void 0 : _a2.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b, _c, _d;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      (_c = ref.anchor) != null ? _c : ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_d = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _d.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path7, value) {
  let v = value;
  for (let i = path7.length - 1; i >= 0; --i) {
    const k = path7[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path7) => path7 == null || typeof path7 === "object" && !!path7[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path7, value) {
    if (isEmptyPath(path7))
      this.add(value);
    else {
      const [key, ...rest] = path7;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path7) {
    const [key, ...rest] = path7;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path7, keepScalar) {
    const [key, ...rest] = path7;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path7) {
    const [key, ...rest] = path7;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path7, value) {
    const [key, ...rest] = path7;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch (e) {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t) => t.format === item.format)) != null ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags.filter((t) => {
      var _a2;
      return (_a2 = t.identify) == null ? void 0 : _a2.call(t, obj);
    });
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = (_b = match.find((t) => t.format === item.format)) != null ? _b : match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : obj === null ? "null" : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  var _a;
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = (_a = node.tag) != null ? _a : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  tagObj != null ? tagObj : tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  var _a, _b;
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n" && valueComment)
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = (_b = (_a = ctx.inFlow) != null ? _a : value.flow) != null ? _b : value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
var MERGE_KEY = "<<";
var merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && (ctx == null ? void 0 : ctx.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default));
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class _Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new _Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) != null ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar(node) ? node.value : node) != null ? _a : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    type != null ? type : type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) != null ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class _YAMLSet extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = _YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => {
    var _a;
    return (_a = value == null ? void 0 : value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) != null ? _a : "";
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag) => {
    const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
    if (!tagObj) {
      const tagName = JSON.stringify(tag);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class _Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  var _a;
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/Document.js
var Document = class _Document {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options == null ? void 0 : options._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path7, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path7, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options != null ? options : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path7) {
    if (isEmptyPath(path7)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path7) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path7, keepScalar) {
    if (isEmptyPath(path7))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path7, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path7) {
    if (isEmptyPath(path7))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path7) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path7, value) {
    if (isEmptyPath(path7)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path7), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path7, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if ((end == null ? void 0 : end.line) === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || (next == null ? void 0 : next.type) !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        start != null ? start : start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        start != null ? start : start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow != null ? flow : "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || (next == null ? void 0 : next.type) === "block-map" || (next == null ? void 0 : next.type) === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag,
    newlineAfterProp,
    end,
    start: start != null ? start : end
  };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  var _a, _b;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep: sep4, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep4 == null ? void 0 : sep4[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep4) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_b = keyProps.found) == null ? void 0 : _b.indent) !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep4 != null ? sep4 : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep4, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd != null ? commentEnd : offset];
  return map2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  var _a;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if ((value == null ? void 0 : value.type) === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd != null ? commentEnd : offset];
  return seq2;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep4 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep4 + cb;
          sep4 = "";
          break;
        }
        case "newline":
          if (comment)
            sep4 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  var _a, _b, _c;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : isMap2 ? YAMLMap : YAMLSeq;
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep: sep4, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep4 == null ? void 0 : sep4[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep4 && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_b = prev.value) != null ? _b : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep4 && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep4, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep4 != null ? sep4 : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep4)
            for (const st of sep4) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && ((_c = value.source) == null ? void 0 : _c[0]) === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep4, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode != null ? valueNode : keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if ((ce == null ? void 0 : ce.source) === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  var _a, _b, _c;
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor != null ? anchor : tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if ((kt == null ? void 0 : kt.collection) === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${(_a = kt.collection) != null ? _a : "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = (_c = (_b = tag.resolve) == null ? void 0 : _b.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) != null ? _c : coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep4 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep4 + indent.slice(trimIndent) + content;
      sep4 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep4 === " ")
        sep4 = "\n";
      else if (!prevMoreIndented && sep4 === "\n")
        sep4 = "\n\n";
      value += sep4 + indent.slice(trimIndent) + content;
      sep4 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep4 === "\n")
        value += "\n";
      else
        sep4 = "\n";
    } else {
      value += sep4 + content;
      sep4 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (e) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep4 = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep4 === "\n")
        res += sep4;
      else
        sep4 = "\n";
    } else {
      res += sep4 + match[1];
      sep4 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep4 + ((_a = match == null ? void 0 : match[1]) != null ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag = ctx.schema[SCALAR];
  } else if (tagName)
    tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag = findScalarTagByTest(ctx, value, token, onError);
  else
    tag = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  var _a;
  const tag = schema4.tags.find((tag2) => {
    var _a2;
    return (tag2.default === true || atKey && tag2.default === "key") && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a = schema4.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
    })) != null ? _a : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    pos != null ? pos : pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag != null ? tag : token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value != null ? value : end == null ? void 0 : end[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) == null ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path7) => {
  let item = cst;
  for (const [field, index] of path7) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path7) => {
  const parent = visit2.itemAtPath(cst, path7.slice(0, -1));
  const field = path7[path7.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path7, item, visitor) {
  let ctrl = visitor(item, path7);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path7.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path7);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path7) : ctrl;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) != null ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next = this.buffer[i2 + 1];
          if (!next && !this.atEnd)
            return this.setNext("block-scalar");
          if (next === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (((_a = prev[++i]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (top == null ? void 0 : top.type) !== "doc-end") {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error != null ? error : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep4;
      if (scalar.end) {
        sep4 = scalar.end;
        sep4.push(this.sourceToken);
        delete scalar.end;
      } else
        sep4 = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep: sep4 }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep4 = it.sep;
              sep4.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep: sep4 }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs5 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs5, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs5);
          } else {
            Object.assign(it, { key: fs5, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while ((top == null ? void 0 : top.type) === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs5 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs5, sep: [] });
          else if (it.sep)
            this.stack.push(fs5);
          else
            Object.assign(it, { key: fs5, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep4 = fc.end.splice(1, fc.end.length);
        sep4.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep: sep4 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse2(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}

// src/utils/FrontmatterAnalyzer.ts
var FrontmatterAnalyzer = class {
  constructor(app) {
    this.app = app;
  }
  async findExampleFile(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      return null;
    }
    if (folder instanceof import_obsidian10.TFile && folder.extension === "md") {
      return await this.parseFrontmatter(folder);
    }
    if (!(folder instanceof import_obsidian10.TFolder)) {
      return null;
    }
    let files = this.getMarkdownFiles(folder, false);
    if (files.length === 0 && folder instanceof import_obsidian10.TFolder) {
      files = this.getMarkdownFiles(folder, true, 1);
      if (files.length === 0) {
        files = this.getMarkdownFiles(folder, true, 2);
      }
      if (files.length === 0) {
        files = this.getMarkdownFiles(folder, true);
      }
    }
    for (const file of files) {
      const example = await this.parseFrontmatter(file);
      if (example) {
        return example;
      }
    }
    return null;
  }
  hasUnderscoreFiles(folderPath) {
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!(folder instanceof import_obsidian10.TFolder)) {
      return Promise.resolve(false);
    }
    const files = this.getMarkdownFiles(folder, true);
    return Promise.resolve(files.some((file) => file.name.startsWith("_")));
  }
  getMarkdownFiles(folder, recursive = true, maxDepth, currentDepth = 0) {
    const files = [];
    if (!folder.children) {
      return files;
    }
    if (maxDepth !== void 0 && currentDepth >= maxDepth) {
      return files;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian10.TFile && child.extension === "md") {
        files.push(child);
      } else if (recursive && child instanceof import_obsidian10.TFolder && child.children) {
        files.push(...this.getMarkdownFiles(child, recursive, maxDepth, currentDepth + 1));
      }
    }
    return files;
  }
  async parseFrontmatter(file) {
    try {
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const match = content.match(frontmatterRegex);
      if (!match) {
        return null;
      }
      const yamlContent = match[1];
      const frontmatter = parse2(yamlContent);
      if (!frontmatter || typeof frontmatter !== "object") {
        return null;
      }
      return {
        file: file.path,
        frontmatter,
        rawYaml: yamlContent
      };
    } catch (e) {
      return null;
    }
  }
  autoDetectDateProperty(frontmatter) {
    const dateProperties = ["date", "pubDate", "publishedDate", "publishDate"];
    for (const prop of dateProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
  autoDetectDescriptionProperty(frontmatter) {
    const descriptionProperties = ["description", "summary", "excerpt", "intro", "snippet", "blurb"];
    for (const prop of descriptionProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
  autoDetectTagsProperty(frontmatter) {
    if (frontmatter.hasOwnProperty("tags")) {
      return "tags";
    }
    return null;
  }
  autoDetectDraftProperty(frontmatter) {
    if (frontmatter.hasOwnProperty("draft")) {
      return { property: "draft", logic: "true-draft" };
    }
    if (frontmatter.hasOwnProperty("published")) {
      return { property: "published", logic: "false-draft" };
    }
    return null;
  }
  autoDetectImageProperty(frontmatter) {
    const imageProperties = ["image", "cover", "coverImage", "thumbnail", "featuredImage"];
    for (const prop of imageProperties) {
      if (frontmatter.hasOwnProperty(prop)) {
        return prop;
      }
    }
    return null;
  }
};

// src/ui/wizard/FrontmatterPropertiesStep.ts
function setCssProps4(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var FrontmatterPropertiesStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.examples = {};
    this.frontmatterAnalyzer = new FrontmatterAnalyzer(app);
  }
  async display() {
    const { containerEl } = this;
    const existingWrapper = containerEl.querySelector(".frontmatter-step-content");
    if (existingWrapper) {
      existingWrapper.remove();
    }
    const stepContentWrapper = containerEl.createDiv({ cls: "frontmatter-step-content" });
    stepContentWrapper.createEl("h2", { text: "Frontmatter properties" });
    stepContentWrapper.createEl("p", {
      text: "Map frontmatter properties for each content type. We'll find example files to help you."
    });
    for (const contentType of this.state.contentTypes) {
      if (!contentType.enabled) {
        continue;
      }
      const contentTypeWrapper = stepContentWrapper.createDiv({ cls: "content-type-settings" });
      if (!this.examples[contentType.id]) {
        const pathResolver = new PathResolver(this.app);
        const folderPath = pathResolver.getFolderPathFromVaultRoot(contentType.folder, this.state.projectDetection);
        const example2 = await this.frontmatterAnalyzer.findExampleFile(folderPath);
        if (example2) {
          this.examples[contentType.id] = example2;
        }
      }
      const example = this.examples[contentType.id];
      contentTypeWrapper.createEl("h3", { text: contentType.name });
      if (example) {
        contentTypeWrapper.createEl("p", { text: `Example file: ${example.file}` });
        const preEl = contentTypeWrapper.createEl("pre", {
          text: example.rawYaml,
          cls: "frontmatter-example"
        });
        setCssProps4(preEl, {
          fontFamily: "var(--font-monospace)",
          fontSize: "0.85em",
          whiteSpace: "pre-wrap",
          overflowWrap: "break-word",
          maxWidth: "100%",
          padding: "10px",
          backgroundColor: "var(--background-secondary)",
          borderRadius: "4px",
          border: "1px solid var(--background-modifier-border)"
        });
      }
      if (!this.state.frontmatterProperties[contentType.id]) {
        const detectedDraft = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
        const detectedTags = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
        const detectedImage = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
        const detectedDesc = example ? this.frontmatterAnalyzer.autoDetectDescriptionProperty(example.frontmatter) : null;
        const detectedTitle = example ? example.frontmatter.hasOwnProperty("title") ? "title" : null : null;
        const detectedDate = example ? this.frontmatterAnalyzer.autoDetectDateProperty(example.frontmatter) : null;
        const pathResolver = new PathResolver(this.app);
        const folderPath = pathResolver.getFolderPathFromVaultRoot(contentType.folder, this.state.projectDetection);
        const hasUnderscoreFiles = await this.frontmatterAnalyzer.hasUnderscoreFiles(folderPath);
        this.state.frontmatterProperties[contentType.id] = {
          titleProperty: detectedTitle || void 0,
          // Only set if detected, otherwise blank
          dateProperty: detectedDate || void 0,
          // Only set if detected, otherwise blank
          descriptionProperty: detectedDesc || void 0,
          tagsProperty: detectedTags || void 0,
          draftProperty: detectedDraft == null ? void 0 : detectedDraft.property,
          draftLogic: (detectedDraft == null ? void 0 : detectedDraft.property) === "published" ? "false-draft" : detectedDraft ? "true-draft" : void 0,
          hasDraftStatus: !!(detectedDraft == null ? void 0 : detectedDraft.property) || hasUnderscoreFiles,
          // Track if draft status is enabled
          imageProperty: detectedImage || void 0
        };
      }
      const props = this.state.frontmatterProperties[contentType.id];
      new import_obsidian11.Setting(contentTypeWrapper).setName("Title property").setDesc("The frontmatter property that contains the title (e.g., title, name, heading). Leave blank to use full file name instead.").addText((text) => {
        const detected = "title";
        text.setPlaceholder(detected).setValue(props.titleProperty || "").onChange((value) => {
          props.titleProperty = value.trim() || void 0;
        });
      });
      new import_obsidian11.Setting(contentTypeWrapper).setName("Date property").setDesc("The frontmatter property that contains the date (e.g., date, pubDate, publishedDate, publishDate). Leave blank to use file created date instead.").addText((text) => {
        const detected = example ? this.frontmatterAnalyzer.autoDetectDateProperty(example.frontmatter) : null;
        text.setPlaceholder(detected || "date").setValue(props.dateProperty || "").onChange((value) => {
          props.dateProperty = value.trim() || void 0;
        });
      });
      const descSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has description/summary?").setDesc("Does this content type have a description or summary field?");
      let descTextSetting = null;
      descSetting.addToggle((toggle) => toggle.setValue(!!props.descriptionProperty).onChange((value) => {
        if (value && !props.descriptionProperty) {
          props.descriptionProperty = example ? this.frontmatterAnalyzer.autoDetectDescriptionProperty(example.frontmatter) || "description" : "description";
          if (!descTextSetting) {
            descTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Description property").setDesc("The frontmatter property that contains the description (e.g., description, summary, excerpt, intro, snippet, blurb)").addText((text) => text.setValue(props.descriptionProperty || "").onChange((value2) => {
              props.descriptionProperty = value2.trim() || void 0;
            }));
            descTextSetting.settingEl.remove();
            descSetting.settingEl.insertAdjacentElement("afterend", descTextSetting.settingEl);
          }
        } else if (!value) {
          props.descriptionProperty = void 0;
          if (descTextSetting) {
            descTextSetting.settingEl.remove();
            descTextSetting = null;
          }
        }
      }));
      if (props.descriptionProperty) {
        descTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Description property").setDesc("The frontmatter property that contains the description (e.g., description, summary, excerpt, intro, snippet, blurb)").addText((text) => text.setValue(props.descriptionProperty || "").onChange((value) => {
          props.descriptionProperty = value.trim() || void 0;
        }));
        descTextSetting.settingEl.remove();
        descSetting.settingEl.insertAdjacentElement("afterend", descTextSetting.settingEl);
      }
      const tagsSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has tags?").setDesc("Does this content type have tags?");
      let tagsTextSetting = null;
      tagsSetting.addToggle((toggle) => toggle.setValue(!!props.tagsProperty).onChange((value) => {
        if (value && !props.tagsProperty) {
          const detected = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
          props.tagsProperty = detected || "tags";
          if (!tagsTextSetting) {
            tagsTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Tags property").setDesc("The frontmatter property that contains tags (e.g., tags, tag, categories, category). Leave blank if not applicable.").addText((text) => {
              const detected2 = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
              text.setPlaceholder(detected2 || "tags").setValue(props.tagsProperty || "").onChange((value2) => {
                props.tagsProperty = value2.trim() || void 0;
              });
            });
            tagsTextSetting.settingEl.remove();
            tagsSetting.settingEl.insertAdjacentElement("afterend", tagsTextSetting.settingEl);
          }
        } else if (!value) {
          props.tagsProperty = void 0;
          if (tagsTextSetting) {
            tagsTextSetting.settingEl.remove();
            tagsTextSetting = null;
          }
        }
      }));
      if (props.tagsProperty) {
        tagsTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Tags property").setDesc("The frontmatter property that contains tags (e.g., tags, tag, categories, category). Leave blank if not applicable.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectTagsProperty(example.frontmatter) : null;
          text.setPlaceholder(detected || "tags").setValue(props.tagsProperty || "").onChange((value) => {
            props.tagsProperty = value.trim() || void 0;
          });
        });
        tagsTextSetting.settingEl.remove();
        tagsSetting.settingEl.insertAdjacentElement("afterend", tagsTextSetting.settingEl);
      }
      const draftSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has draft status?").setDesc("Does this content type have draft status?");
      let draftPropertySetting = null;
      let draftLogicSetting = null;
      if (props.hasDraftStatus === void 0) {
        props.hasDraftStatus = !!props.draftProperty;
      }
      draftSetting.addToggle((toggle) => {
        var _a;
        return toggle.setValue((_a = props.hasDraftStatus) != null ? _a : !!props.draftProperty).onChange((value) => {
          props.hasDraftStatus = value;
          if (value && !props.draftProperty) {
            const detectedDraft = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
            props.draftProperty = (detectedDraft == null ? void 0 : detectedDraft.property) || "draft";
            if ((detectedDraft == null ? void 0 : detectedDraft.property) === "published") {
              props.draftLogic = "false-draft";
            } else {
              props.draftLogic = "true-draft";
            }
            if (!draftPropertySetting) {
              draftPropertySetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft property").setDesc("The frontmatter property that contains draft status. Leave blank to use an underscore prefix instead.").addText((text) => {
                const detected = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
                text.setPlaceholder((detected == null ? void 0 : detected.property) || "draft").setValue(props.draftProperty || "").onChange((value2) => {
                  props.draftProperty = value2.trim() || void 0;
                  if (value2 === "published") {
                    props.draftLogic = "false-draft";
                  } else if (value2) {
                    props.draftLogic = "true-draft";
                  }
                  if (value2 && !draftLogicSetting) {
                    draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((dropdownValue) => {
                      props.draftLogic = dropdownValue;
                    }));
                    draftLogicSetting.settingEl.remove();
                    if (draftPropertySetting) {
                      draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
                    }
                  } else if (!value2 && draftLogicSetting) {
                    draftLogicSetting.settingEl.remove();
                    draftLogicSetting = null;
                  }
                });
              });
              draftPropertySetting.settingEl.remove();
              draftSetting.settingEl.insertAdjacentElement("afterend", draftPropertySetting.settingEl);
            }
            if (props.draftProperty && !draftLogicSetting) {
              draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((value2) => {
                props.draftLogic = value2;
              }));
              draftLogicSetting.settingEl.remove();
              if (draftPropertySetting !== null) {
                draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
              }
            }
          } else if (!value) {
            props.draftProperty = void 0;
            props.draftLogic = void 0;
            props.hasDraftStatus = false;
            if (draftPropertySetting) {
              draftPropertySetting.settingEl.remove();
              draftPropertySetting = null;
            }
            if (draftLogicSetting) {
              draftLogicSetting.settingEl.remove();
              draftLogicSetting = null;
            }
          }
        });
      });
      if (props.hasDraftStatus) {
        draftPropertySetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft property").setDesc("The frontmatter property that contains draft status. Leave blank to use an underscore prefix instead.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectDraftProperty(example.frontmatter) : null;
          text.setPlaceholder((detected == null ? void 0 : detected.property) || "draft").setValue(props.draftProperty || "").onChange((value) => {
            props.draftProperty = value.trim() || void 0;
            if (value === "published") {
              props.draftLogic = "false-draft";
            } else if (value) {
              props.draftLogic = "true-draft";
            }
            if (value && !draftLogicSetting) {
              draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((dropdownValue) => {
                props.draftLogic = dropdownValue;
              }));
              draftLogicSetting.settingEl.remove();
              if (draftPropertySetting) {
                draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
              }
            } else if (!value && draftLogicSetting) {
              draftLogicSetting.settingEl.remove();
              draftLogicSetting = null;
            }
          });
        });
        draftPropertySetting.settingEl.remove();
        draftSetting.settingEl.insertAdjacentElement("afterend", draftPropertySetting.settingEl);
        if (props.draftProperty) {
          draftLogicSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Draft logic").setDesc("How draft status is represented").addDropdown((dropdown) => dropdown.addOption("true-draft", "true = draft").addOption("false-draft", "false = draft").setValue(props.draftLogic || "true-draft").onChange((value) => {
            props.draftLogic = value;
          }));
          draftLogicSetting.settingEl.remove();
          if (draftPropertySetting !== null) {
            draftPropertySetting.settingEl.insertAdjacentElement("afterend", draftLogicSetting.settingEl);
          }
        }
      }
      const imageSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Has image/cover property?").setDesc("Does this content type have an image or cover property? Used for Bases CMS cover images, Simple Banner, and Image Inserter.");
      let imageTextSetting = null;
      imageSetting.addToggle((toggle) => toggle.setValue(!!props.imageProperty).onChange((value) => {
        if (value && !props.imageProperty) {
          const detected = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
          props.imageProperty = detected || "image";
          if (!imageTextSetting) {
            imageTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Image property").setDesc("The frontmatter property that contains the image/cover (e.g., image, cover, coverImage, thumbnail, featuredImage). Leave blank if not applicable.").addText((text) => {
              const detected2 = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
              text.setPlaceholder(detected2 || "image").setValue(props.imageProperty || "").onChange((value2) => {
                props.imageProperty = value2.trim() || void 0;
              });
            });
            imageTextSetting.settingEl.remove();
            imageSetting.settingEl.insertAdjacentElement("afterend", imageTextSetting.settingEl);
          }
        } else if (!value) {
          props.imageProperty = void 0;
          if (imageTextSetting) {
            imageTextSetting.settingEl.remove();
            imageTextSetting = null;
          }
        }
      }));
      if (props.imageProperty) {
        imageTextSetting = new import_obsidian11.Setting(contentTypeWrapper).setName("Image property").setDesc("The frontmatter property that contains the image/cover (e.g., image, cover, coverImage, thumbnail, featuredImage). Leave blank if not applicable.").addText((text) => {
          const detected = example ? this.frontmatterAnalyzer.autoDetectImageProperty(example.frontmatter) : null;
          text.setPlaceholder(detected || "image").setValue(props.imageProperty || "").onChange((value) => {
            props.imageProperty = value.trim() || void 0;
          });
        });
        imageTextSetting.settingEl.remove();
        imageSetting.settingEl.insertAdjacentElement("afterend", imageTextSetting.settingEl);
      }
      contentTypeWrapper.createEl("h4", { text: "Template" });
      contentTypeWrapper.createEl("p", {
        text: 'Edit the template that will be used when creating new files of this content type. Use {{title}} and {{date}} as variables. Note: {{title}} should be in quotes (e.g., title: "{{title}}"), while {{date}} should not be in quotes (e.g., date: {{date}}).'
      });
      if (!props.template) {
        props.template = this.generateDefaultTemplate(props, example);
      }
      const templateTextArea = contentTypeWrapper.createEl("textarea", {
        cls: "template-editor",
        attr: {
          rows: "10",
          style: "width: 100%; font-family: monospace;",
          spellcheck: "false"
        }
      });
      templateTextArea.value = props.template || "";
      templateTextArea.addEventListener("input", (e) => {
        const target = e.target;
        props.template = target.value;
      });
    }
  }
  generateDefaultTemplate(props, example) {
    let template = "---\n";
    if (example && example.rawYaml) {
      const lines = example.rawYaml.split("\n");
      const processedProps = /* @__PURE__ */ new Set();
      let titleAdded = false;
      if (props.titleProperty) {
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) continue;
          const colonIndex = trimmed.indexOf(":");
          if (colonIndex > 0) {
            const prop = trimmed.substring(0, colonIndex).trim();
            if (prop === props.titleProperty) {
              template += `${props.titleProperty}: "{{title}}"
`;
              titleAdded = true;
              processedProps.add(prop);
              continue;
            }
          }
        }
        if (!titleAdded) {
          template += `${props.titleProperty}: "{{title}}"
`;
        }
      }
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith("#")) continue;
        const colonIndex = trimmed.indexOf(":");
        if (colonIndex > 0) {
          const prop = trimmed.substring(0, colonIndex).trim();
          if (processedProps.has(prop)) {
            continue;
          }
          if (prop === props.titleProperty) {
            continue;
          }
          if (prop === props.dateProperty && props.dateProperty) {
            template += `${props.dateProperty}: {{date}}
`;
            processedProps.add(prop);
            continue;
          }
          if (prop === props.descriptionProperty) {
            template += `${props.descriptionProperty}: ""
`;
            processedProps.add(prop);
            continue;
          }
          const value = example.frontmatter[prop];
          if (value === null || value === void 0) {
            template += `${prop}:
`;
          } else if (Array.isArray(value)) {
            template += `${prop}: []
`;
          } else if (typeof value === "boolean") {
            template += `${prop}: ${value}
`;
          } else if (typeof value === "number") {
            template += `${prop}: ${value}
`;
          } else if (typeof value === "string") {
            if (/^\d{4}-\d{2}-\d{2}/.test(value) && prop.toLowerCase().includes("date")) {
              template += `${prop}: {{date}}
`;
            } else {
              template += `${prop}: ""
`;
            }
          } else if (typeof value === "object") {
            if (Array.isArray(value)) {
              template += `${prop}: []
`;
            } else {
              template += `${prop}:
`;
            }
          }
          processedProps.add(prop);
        }
      }
    } else {
      if (props.titleProperty) {
        template += `${props.titleProperty}: "{{title}}"
`;
      }
      if (props.dateProperty) {
        template += `${props.dateProperty}: {{date}}
`;
      }
      if (props.descriptionProperty) {
        template += `${props.descriptionProperty}: ""
`;
      }
      if (props.tagsProperty) {
        template += `${props.tagsProperty}: []
`;
      }
      if (props.draftProperty) {
        const draftValue = props.draftLogic === "false-draft" ? "false" : "true";
        template += `${props.draftProperty}: ${draftValue}
`;
      }
    }
    template += "---\n";
    return template;
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Frontmatter properties";
  }
  getDescription() {
    return "Map frontmatter properties";
  }
};

// src/ui/wizard/WYSIWYGPreferenceStep.ts
var import_obsidian12 = require("obsidian");
var WYSIWYGPreferenceStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "WYSIWYG editing toolbar" });
    containerEl.createEl("p", {
      // False positive: "WYSIWYG" is an acronym and should be capitalized
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: "Do you want to use the WYSIWYG editing toolbar?"
    });
    containerEl.createEl("p", {
      text: "This enables a visual editing toolbar for formatting text. The toolbar can be toggled on/off via command."
    });
    new import_obsidian12.Setting(containerEl).setName("Enable WYSIWYG toolbar").setDesc("Show the editing toolbar command in the page header").addToggle((toggle) => toggle.setValue(this.state.enableWYSIWYG).onChange((value) => {
      this.state.enableWYSIWYG = value;
    }));
  }
  validate() {
    return true;
  }
  getTitle() {
    return "WYSIWYG preference";
  }
  getDescription() {
    return "Configure editing toolbar preference";
  }
};

// src/ui/wizard/BasesCMSConfigStep.ts
var BasesCMSConfigStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Bases CMS configuration" });
    containerEl.createEl("p", {
      // False positive: "Bases CMS" is a proper noun (product name) and should be capitalized
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: "Bases CMS views will be automatically created for each enabled content type using your mapped frontmatter properties."
    });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    if (enabledTypes.length === 0) {
      containerEl.createEl("p", {
        text: "No content types enabled. Please go back and enable at least one content type."
      });
      return;
    }
    containerEl.createEl("h3", { text: "Views to be created:" });
    const list = containerEl.createEl("ul");
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        const properties = [];
        if (props.titleProperty) properties.push(`title: ${props.titleProperty}`);
        if (props.dateProperty) properties.push(`date: ${props.dateProperty}`);
        if (props.descriptionProperty) properties.push(`description: ${props.descriptionProperty}`);
        if (props.tagsProperty) properties.push(`tags: ${props.tagsProperty}`);
        if (props.imageProperty) properties.push(`image: ${props.imageProperty}`);
        if (props.draftProperty) properties.push(`draft: ${props.draftProperty}`);
        const propertiesText = properties.length > 0 ? properties.join(", ") : "default properties";
        list.createEl("li", {
          text: `${contentType.name}: ${propertiesText}`
        });
      }
    }
    containerEl.createEl("p", {
      // False positive: "Bases CMS" is a proper noun (product name) and should be capitalized
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: "You can customize these views later in the Bases CMS settings."
    });
  }
  validate() {
    return this.state.contentTypes.some((ct) => ct.enabled);
  }
  getTitle() {
    return "Bases CMS configuration";
  }
  getDescription() {
    return "Configure Bases CMS views";
  }
};

// src/ui/wizard/AstroComposerStep.ts
var AstroComposerStep = class extends BaseWizardStep {
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Astro Composer configuration" });
    containerEl.createEl("p", {
      // False positive: "Astro Composer" is a proper noun (product name) and should be capitalized
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: "Astro Composer will be configured with your content types and frontmatter properties."
    });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    if (enabledTypes.length === 0) {
      containerEl.createEl("p", {
        text: "No content types enabled."
      });
      return;
    }
    containerEl.createEl("h3", { text: "Content types to configure:" });
    const list = containerEl.createEl("ul");
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        const modeLabel = contentType.fileOrganization === "folder" ? "folder-based" : "file-based";
        list.createEl("li", {
          text: `${contentType.name} (${contentType.folder}): ${modeLabel}`
        });
      }
    }
    if (this.state.projectDetection) {
      if (this.state.projectDetection.projectRoot) {
        containerEl.createEl("p", {
          text: `Project root: ${this.state.projectDetection.projectRoot}`
        });
      }
      if (this.state.projectDetection.configFilePath) {
        containerEl.createEl("p", {
          text: `Config file: ${this.state.projectDetection.configFilePath}`
        });
      }
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Astro Composer configuration";
  }
  getDescription() {
    return "Configure Astro Composer";
  }
};

// src/ui/wizard/SEOConfigStep.ts
var import_obsidian13 = require("obsidian");
function setCssProps5(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var SEOConfigStep = class extends BaseWizardStep {
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "SEO plugin configuration" });
    containerEl.createEl("p", {
      // False positive: "SEO" is an acronym and should be capitalized
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: "SEO plugin will be configured using your mapped frontmatter properties."
    });
    const enabledTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    const firstType = enabledTypes[0];
    const firstProps = firstType ? this.state.frontmatterProperties[firstType.id] : void 0;
    const titleProperties = /* @__PURE__ */ new Set();
    const descriptionProperties = /* @__PURE__ */ new Set();
    for (const contentType of enabledTypes) {
      const props = this.state.frontmatterProperties[contentType.id];
      if (props) {
        if (props.titleProperty) {
          titleProperties.add(props.titleProperty);
        }
        if (props.descriptionProperty) {
          descriptionProperties.add(props.descriptionProperty);
        }
      }
    }
    if (titleProperties.size > 1 || descriptionProperties.size > 1) {
      const warningDiv = containerEl.createDiv({ cls: "vault-cms-warning" });
      setCssProps5(warningDiv, {
        padding: "10px",
        backgroundColor: "var(--background-modifier-border)",
        borderLeft: "3px solid var(--text-warning)",
        marginBottom: "15px"
      });
      warningDiv.createEl("p", {
        // eslint-disable-next-line obsidianmd/ui/sentence-case
        text: "\u26A0\uFE0F Warning: Different content types use different properties for title or description.",
        attr: { style: "margin: 0 0 5px 0; font-weight: bold;" }
      });
      warningDiv.createEl("p", {
        // False positive: "SEO" is an acronym and should be capitalized
        // eslint-disable-next-line obsidianmd/ui/sentence-case
        text: "The SEO plugin will use the first content type's properties. You may need to manually configure SEO settings for other content types.",
        attr: { style: "margin: 0;" }
      });
    }
    if (firstProps) {
      containerEl.createEl("h3", { text: "Configuration:" });
      containerEl.createEl("p", {
        text: `Title property: ${firstProps.titleProperty || "(using filename)"}`
      });
      if (firstProps.descriptionProperty) {
        containerEl.createEl("p", {
          text: `Description property: ${firstProps.descriptionProperty}`
        });
      }
      const scanDirs = enabledTypes.map((ct) => ct.folder).join(", ");
      containerEl.createEl("p", {
        text: `Scan directories: ${scanDirs}`
      });
    }
    const pathResolver = new PathResolver(this.app);
    const defaultScanDirs = this.state.contentTypes.filter((ct) => ct.enabled).map((ct) => pathResolver.getFolderPathFromVaultRoot(ct.folder, this.state.projectDetection)).join(",");
    const savedScanDirs = (_a = this.state.seoConfig) == null ? void 0 : _a.scanDirectories;
    const initialScanDirs = savedScanDirs && savedScanDirs.trim() ? savedScanDirs : defaultScanDirs;
    if (!this.state.seoConfig.scanDirectories || !this.state.seoConfig.scanDirectories.trim()) {
      this.state.seoConfig.scanDirectories = initialScanDirs;
    }
    new import_obsidian13.Setting(containerEl).setName("Scan directories").setDesc("Comma-separated list of directories to scan (you can customize this)").addText((text) => text.setValue(initialScanDirs).onChange((value) => {
      if (this.state.seoConfig) {
        this.state.seoConfig.scanDirectories = value;
      }
    }));
  }
  validate() {
    return true;
  }
  getTitle() {
    return "SEO configuration";
  }
  getDescription() {
    return "Configure SEO plugin";
  }
};

// src/ui/wizard/OptionalPluginsStep.ts
var import_obsidian14 = require("obsidian");

// src/utils/PluginManager.ts
var PluginManager = class {
  constructor(app) {
    this.app = app;
  }
  async enablePlugin(pluginId) {
    var _a, _b;
    const plugins = this.app.plugins;
    if (!plugins) {
      return;
    }
    const plugin = (_a = plugins.plugins) == null ? void 0 : _a[pluginId];
    if (plugin && !plugin.enabled) {
      await ((_b = plugins.enablePlugin) == null ? void 0 : _b.call(plugins, pluginId));
    }
  }
  async disablePlugin(pluginId) {
    var _a, _b;
    const plugins = this.app.plugins;
    if (!plugins) {
      return;
    }
    const plugin = (_a = plugins.plugins) == null ? void 0 : _a[pluginId];
    if (plugin && plugin.enabled) {
      await ((_b = plugins.disablePlugin) == null ? void 0 : _b.call(plugins, pluginId));
    }
  }
  async setPluginStates(enabled, disabled) {
    const corePlugins = ["bases-cms", "astro-composer", "vault-cms"];
    const safeDisabled = disabled.filter((p) => !corePlugins.includes(p));
    for (const pluginId of safeDisabled) {
      await this.disablePlugin(pluginId);
    }
    for (const pluginId of enabled) {
      await this.enablePlugin(pluginId);
    }
  }
  getPresetPlugins(preset) {
    const corePlugins = [
      "astro-composer",
      "bases-cms",
      "homepage",
      "new-tab-default-page",
      "property-over-file-name",
      "settings-search",
      "statusbar-organizer",
      "seo",
      "ui-tweaker",
      "zenmode",
      "cmdr",
      "simple-focus",
      "tag-wrangler"
    ];
    const optionalPlugins = [
      "editing-toolbar",
      "insert-unsplash-image",
      "custom-save",
      "title-only-tab",
      "obsidian-paste-image-rename",
      "obsidian42-brat",
      "obsidian-hider",
      "disable-tabs",
      "obsidian-style-settings",
      "mdx-as-md-obsidian",
      "explorer-focus"
    ];
    const opinionatedPlugins = [
      "obsidian-oxygen",
      "obsidian-style-settings"
    ];
    if (preset === "vanilla") {
      return {
        enabled: [...corePlugins, ...optionalPlugins.filter((p) => !opinionatedPlugins.includes(p))],
        disabled: opinionatedPlugins
      };
    } else if (preset === "opinionated") {
      return {
        enabled: [...corePlugins, ...optionalPlugins],
        disabled: []
      };
    } else {
      return {
        enabled: [],
        disabled: []
      };
    }
  }
};

// src/ui/wizard/OptionalPluginsStep.ts
function setCssProps6(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var OptionalPluginsStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.pluginManager = new PluginManager(app);
  }
  display() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Plugin configuration" });
    containerEl.createEl("p", {
      // False positive: "Vault CMS" is a proper noun (product name) and should be capitalized
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: "Review and configure your installed plugins. Essential plugins are recommended for the core Vault CMS experience."
    });
    const allPlugins = [
      // Essential plugins (alphabetically ordered)
      { id: "astro-composer", name: "Astro Composer", category: "essential" },
      { id: "bases-cms", name: "Bases CMS", category: "essential" },
      { id: "cmdr", name: "Commander", category: "essential" },
      { id: "new-tab-default-page", name: "Default New Tab Page", category: "essential" },
      { id: "editing-toolbar", name: "Editing Toolbar", category: "essential" },
      { id: "home-base", name: "Home Base", category: "essential" },
      { id: "homepage", name: "Homepage", category: "essential" },
      { id: "image-manager", name: "Image Manager", category: "essential" },
      { id: "obsidian-paste-image-rename", name: "Paste Image Rename", category: "essential" },
      { id: "property-over-file-name", name: "Property Over File Name", category: "essential" },
      { id: "seo", name: "SEO", category: "essential" },
      { id: "ui-tweaker", name: "UI Tweaker", category: "essential" },
      { id: "simple-focus", name: "Simple Focus", category: "essential" },
      { id: "statusbar-organizer", name: "Status Bar Organizer", category: "essential" },
      // Nice to have plugins (alphabetically ordered)
      { id: "alias-file-name-history", name: "Alias File Name History", category: "nice-to-have" },
      { id: "iconic", name: "Iconic", category: "nice-to-have" },
      { id: "insert-unsplash-image", name: "Image Inserter", category: "nice-to-have" },
      { id: "paste-image-into-property", name: "Paste Image Into Property", category: "nice-to-have" },
      { id: "settings-search", name: "Settings Search", category: "nice-to-have" },
      { id: "simple-banner", name: "Simple Banner", category: "nice-to-have" },
      { id: "tag-wrangler", name: "Tag Wrangler", category: "nice-to-have" },
      { id: "zenmode", name: "Zen Mode", category: "nice-to-have" },
      { id: "explorer-focus", name: "Explorer Focus", category: "nice-to-have" }
    ];
    const plugins = this.app.plugins;
    const installedPluginIds = (plugins == null ? void 0 : plugins.plugins) ? Object.keys(plugins.plugins) : [];
    const ignoredPlugins = [
      "obsidian42-brat",
      "astro-modular-settings",
      "folder-notes",
      "disable-tabs",
      "vault-cms"
      // Don't show Vault CMS plugin itself
    ];
    const essentialPlugins = allPlugins.filter(
      (p) => p.category === "essential" && installedPluginIds.includes(p.id) && !ignoredPlugins.includes(p.id)
    );
    const niceToHavePlugins = allPlugins.filter(
      (p) => p.category === "nice-to-have" && installedPluginIds.includes(p.id) && !ignoredPlugins.includes(p.id)
    ).sort((a, b) => a.name.localeCompare(b.name));
    if (essentialPlugins.length > 0) {
      containerEl.createEl("h3", { text: "Essential plugins", cls: "vault-cms-section-header" });
      containerEl.createEl("p", {
        // False positive: "Vault CMS" is a proper noun (product name) and should be capitalized
        // eslint-disable-next-line obsidianmd/ui/sentence-case
        text: "These plugins are recommended for the core Vault CMS experience.",
        cls: "vault-cms-section-desc"
      });
      for (const plugin of essentialPlugins) {
        const pluginInstance = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[plugin.id];
        const isInstalled = !!pluginInstance;
        const pluginInstanceTyped = pluginInstance;
        const isCurrentlyEnabled = (_e = (_d = (_c = (_b = plugins == null ? void 0 : plugins.enabledPlugins) == null ? void 0 : _b.has) == null ? void 0 : _c.call(_b, plugin.id)) != null ? _d : pluginInstanceTyped == null ? void 0 : pluginInstanceTyped.enabled) != null ? _e : false;
        console.debug(`Plugin ${plugin.id}: installed=${isInstalled}, enabled=${isCurrentlyEnabled}`);
        if (isInstalled && isCurrentlyEnabled) {
          if (!this.state.enabledPlugins.includes(plugin.id)) {
            this.state.enabledPlugins.push(plugin.id);
          }
          this.state.disabledPlugins = this.state.disabledPlugins.filter((p) => p !== plugin.id);
        } else if (isInstalled && !isCurrentlyEnabled) {
          this.state.enabledPlugins = this.state.enabledPlugins.filter((p) => p !== plugin.id);
          if (!this.state.disabledPlugins.includes(plugin.id)) {
            this.state.disabledPlugins.push(plugin.id);
          }
        }
        const setting = new import_obsidian14.Setting(containerEl).setName(plugin.name).setDesc(isInstalled ? isCurrentlyEnabled ? "Installed and enabled" : "Installed but disabled" : "Not installed");
        const iconContainer = setting.controlEl.createDiv({ cls: "vault-cms-plugin-status" });
        if (isInstalled && isCurrentlyEnabled) {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-check-circle-2");
          setCssProps6(iconContainer, { color: "var(--text-success)" });
        } else {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-x-circle");
          setCssProps6(iconContainer, { color: "var(--text-error)" });
        }
      }
    }
    if (niceToHavePlugins.length > 0) {
      containerEl.createEl("h3", { text: "Nice to have plugins", cls: "vault-cms-section-header" });
      containerEl.createEl("p", {
        text: "These plugins can be helpful depending on your theme's capabilities and workflow needs.",
        cls: "vault-cms-section-desc"
      });
      for (const plugin of niceToHavePlugins) {
        const pluginInstance = (_f = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _f[plugin.id];
        const isInstalled = !!pluginInstance;
        const pluginInstanceTyped = pluginInstance;
        const isCurrentlyEnabled = (_j = (_i = (_h = (_g = plugins == null ? void 0 : plugins.enabledPlugins) == null ? void 0 : _g.has) == null ? void 0 : _h.call(_g, plugin.id)) != null ? _i : pluginInstanceTyped == null ? void 0 : pluginInstanceTyped.enabled) != null ? _j : false;
        console.debug(`Plugin ${plugin.id}: installed=${isInstalled}, enabled=${isCurrentlyEnabled}`);
        if (isInstalled && isCurrentlyEnabled) {
          if (!this.state.enabledPlugins.includes(plugin.id)) {
            this.state.enabledPlugins.push(plugin.id);
          }
          this.state.disabledPlugins = this.state.disabledPlugins.filter((p) => p !== plugin.id);
        } else if (isInstalled && !isCurrentlyEnabled) {
          this.state.enabledPlugins = this.state.enabledPlugins.filter((p) => p !== plugin.id);
          if (!this.state.disabledPlugins.includes(plugin.id)) {
            this.state.disabledPlugins.push(plugin.id);
          }
        }
        const setting = new import_obsidian14.Setting(containerEl).setName(plugin.name).setDesc(isInstalled ? isCurrentlyEnabled ? "Installed and enabled" : "Installed but disabled" : "Not installed");
        const iconContainer = setting.controlEl.createDiv({ cls: "vault-cms-plugin-status" });
        if (isInstalled && isCurrentlyEnabled) {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-check-circle-2");
          setCssProps6(iconContainer, { color: "var(--text-success)" });
        } else {
          (0, import_obsidian14.setIcon)(iconContainer, "lucide-x-circle");
          setCssProps6(iconContainer, { color: "var(--text-error)" });
        }
      }
    }
    if (essentialPlugins.length === 0 && niceToHavePlugins.length === 0) {
      containerEl.createEl("p", {
        // False positive: "Vault CMS" is a proper noun (product name) and should be capitalized
        // eslint-disable-next-line obsidianmd/ui/sentence-case
        text: "No Vault CMS plugins detected. Make sure you have installed the recommended plugins."
      });
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Optional Plugins";
  }
  getDescription() {
    return "Configure optional plugins";
  }
};

// src/ui/wizard/IgnoreStep.ts
var import_obsidian16 = require("obsidian");

// src/utils/ProjectOptimizer.ts
var import_obsidian15 = require("obsidian");
var path6 = __toESM(require("path"), 1);
function setCssProps7(element, props) {
  for (const [key, value] of Object.entries(props)) {
    element.style.setProperty(key.replace(/([A-Z])/g, "-$1").toLowerCase(), value);
  }
}
var ProjectOptimizer = class {
  constructor(app, state) {
    this.app = app;
    this.state = state;
  }
  async getStatus() {
    var _a, _b;
    const status = {
      gitIgnoreStatus: "not-configured",
      viteIgnoreStatus: "not-configured"
    };
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) return status;
    const configDir = this.app.vault.configDir;
    const adapter = this.app.vault.adapter;
    const gitIgnorePath = path6.join(projectRoot, ".gitignore").replace(/\\/g, "/");
    if (await adapter.exists(gitIgnorePath)) {
      const content = await adapter.read(gitIgnorePath);
      if (content.includes(`${configDir}/workspace.json`)) {
        status.gitIgnoreStatus = "configured";
      }
    }
    const astroConfigNames = ["astro.config.ts", "astro.config.mjs", "astro.config.js", "astro.config.mts", "astro.config.cjs"];
    let resolvedViteConfigPath = "";
    for (const name of astroConfigNames) {
      const p = path6.join(projectRoot, name).replace(/\\/g, "/");
      if (await adapter.exists(p)) {
        resolvedViteConfigPath = p;
        break;
      }
    }
    if (!resolvedViteConfigPath && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath)) {
      resolvedViteConfigPath = this.state.projectDetection.configFilePath;
    }
    if (resolvedViteConfigPath && await adapter.exists(resolvedViteConfigPath)) {
      const content = await adapter.read(resolvedViteConfigPath);
      if (content.includes("server.watch.ignored") || content.includes("ignored:")) {
        if (content.includes(configDir)) {
          status.viteIgnoreStatus = "configured";
        }
      }
    }
    return status;
  }
  async configureGitIgnore() {
    var _a;
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) return;
    const configDir = this.app.vault.configDir;
    const gitIgnorePath = path6.join(projectRoot, ".gitignore").replace(/\\/g, "/");
    const rules = `
# Obsidian workspace files
**/${configDir}/workspace.json
**/${configDir}/workspace-mobile.json
`;
    const adapter = this.app.vault.adapter;
    try {
      if (await adapter.exists(gitIgnorePath)) {
        let content = await adapter.read(gitIgnorePath);
        if (!content.includes(`${configDir}/workspace.json`)) {
          content += rules;
          await adapter.write(gitIgnorePath, content);
        }
      } else {
        await adapter.write(gitIgnorePath, rules);
      }
    } catch (error) {
      console.error("Failed to update .gitignore:", error);
      throw error;
    }
  }
  async configureViteIgnore() {
    var _a, _b;
    const projectRoot = (_a = this.state.projectDetection) == null ? void 0 : _a.projectRoot;
    if (!projectRoot) return;
    const configDir = this.app.vault.configDir;
    const adapter = this.app.vault.adapter;
    const astroConfigNames = ["astro.config.ts", "astro.config.mjs", "astro.config.js", "astro.config.mts", "astro.config.cjs"];
    let resolvedConfigPath = "";
    let configFileName = "";
    for (const name of astroConfigNames) {
      const p = path6.join(projectRoot, name).replace(/\\/g, "/");
      if (await adapter.exists(p)) {
        resolvedConfigPath = p;
        configFileName = name;
        break;
      }
    }
    if (!resolvedConfigPath && ((_b = this.state.projectDetection) == null ? void 0 : _b.configFilePath)) {
      resolvedConfigPath = this.state.projectDetection.configFilePath;
      configFileName = path6.basename(resolvedConfigPath);
    }
    if (!resolvedConfigPath || !await adapter.exists(resolvedConfigPath)) {
      throw new Error(`Astro config file not found in: ${projectRoot}`);
    }
    try {
      const content = await adapter.read(resolvedConfigPath);
      if (content.includes("server.watch.ignored") && content.includes(configDir)) {
        return;
      }
      const exportIdx = content.lastIndexOf("export default");
      let startIndex = -1;
      let endIndex = -1;
      let configBody = "";
      let isWholeFile = false;
      if (exportIdx !== -1) {
        startIndex = content.indexOf("{", exportIdx);
        if (startIndex !== -1) {
          let braceCount = 0;
          for (let i = startIndex; i < content.length; i++) {
            if (content[i] === "{") braceCount++;
            else if (content[i] === "}") braceCount--;
            if (braceCount === 0) {
              endIndex = i;
              break;
            }
          }
          if (endIndex !== -1) {
            configBody = content.substring(startIndex + 1, endIndex);
          }
        }
      }
      if (!configBody && (content.includes("vite:") || content.includes("server:"))) {
        configBody = content;
        isWholeFile = true;
      }
      if (configBody) {
        if (configBody.includes("vite:")) {
          if (configBody.includes("server:")) {
            if (configBody.includes("watch:")) {
              if (configBody.includes("ignored:")) {
                if (!configBody.includes(configDir)) {
                  configBody = configBody.replace(/ignored:\s*\[([^\]]*)\]/, (_m, p1) => {
                    const existing = p1.trim();
                    const separator = existing ? ", " : "";
                    return `ignored: [${existing}${separator}'**/${configDir}/**', '**/_bases/**', '**/bases/**']`;
                  });
                }
              } else {
                configBody = configBody.replace(/watch:\s*\{/, `watch: {
      ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**'],`);
              }
            } else {
              configBody = configBody.replace(/server:\s*\{/, `server: {
    watch: {
      ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
    },`);
            }
          } else {
            configBody = configBody.replace(/vite:\s*\{/, `vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
      }
    },`);
          }
        } else {
          if (isWholeFile) {
            if (content.includes("defineConfig")) {
              configBody = configBody.replace(/defineConfig\s*\(\s*\{/, `defineConfig({
  vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
      }
    }
  },`);
            } else {
              throw new Error(`Could not find a clear place to insert Vite config in ${configFileName}.`);
            }
          } else {
            configBody = `
  vite: {
    server: {
      watch: {
        ignored: ['**/${configDir}/**', '**/_bases/**', '**/bases/**']
      }
    }
  },` + configBody;
          }
        }
        const updatedContent = isWholeFile ? configBody : content.substring(0, startIndex + 1) + configBody + content.substring(endIndex);
        await adapter.write(resolvedConfigPath, updatedContent);
      } else {
        throw new Error(`Could not parse configuration in ${configFileName}.`);
      }
    } catch (error) {
      console.error(`ProjectOptimizer: Error updating ${configFileName}:`, error);
      throw error;
    }
  }
  renderStatus(container, status) {
    const statusEl = container.createDiv({ cls: "vault-cms-plugin-status" });
    if (status === "configured") {
      (0, import_obsidian15.setIcon)(statusEl, "lucide-check-circle-2");
      setCssProps7(statusEl, { color: "var(--text-success)" });
    } else {
      (0, import_obsidian15.setIcon)(statusEl, "lucide-alert-circle");
      setCssProps7(statusEl, { color: "var(--text-warning)" });
    }
  }
};

// src/ui/wizard/IgnoreStep.ts
var IgnoreStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.optimizer = new ProjectOptimizer(app, state);
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const status = await this.optimizer.getStatus();
    this.state.ignoreConfig.gitIgnoreConfigured = status.gitIgnoreStatus === "configured";
    this.state.ignoreConfig.viteIgnoreConfigured = status.viteIgnoreStatus === "configured";
    containerEl.createEl("h2", { text: "Project optimization (optional)" });
    containerEl.createEl("p", {
      text: "Optimize your project by ignoring Obsidian-specific files in Git and Vite."
    });
    this.gitSetting = new import_obsidian16.Setting(containerEl);
    this.updateGitSetting(status.gitIgnoreStatus);
    this.viteSetting = new import_obsidian16.Setting(containerEl);
    this.updateViteSetting(status.viteIgnoreStatus);
    return Promise.resolve();
  }
  updateGitSetting(status) {
    this.gitSetting.setName("Ignore in Git").setDesc("Add Obsidian workspace files to .gitignore to prevent them from being tracked.").clear();
    this.gitSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureGitIgnore();
          this.state.ignoreConfig.gitIgnoreConfigured = true;
          new import_obsidian16.Notice(".gitignore updated");
          const newStatus = await this.optimizer.getStatus();
          this.updateGitSetting(newStatus.gitIgnoreStatus);
        } catch (error) {
          new import_obsidian16.Notice(`Failed to update .gitignore: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.gitSetting.controlEl, status);
  }
  updateViteSetting(status) {
    this.viteSetting.setName("Ignore in Vite").setDesc("Configure Vite to ignore Obsidian and bases folders.").clear();
    this.viteSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureViteIgnore();
          this.state.ignoreConfig.viteIgnoreConfigured = true;
          new import_obsidian16.Notice("Vite optimization applied");
          const newStatus = await this.optimizer.getStatus();
          this.updateViteSetting(newStatus.viteIgnoreStatus);
        } catch (error) {
          new import_obsidian16.Notice(`Failed to update Vite config: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.viteSetting.controlEl, status);
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Project optimization (optional)";
  }
  getDescription() {
    return "Configure project-level ignores";
  }
};

// src/ui/wizard/FinalizeStep.ts
var import_obsidian23 = require("obsidian");

// src/utils/BasesCMSConfig.ts
var import_obsidian17 = require("obsidian");
var BasesCMSConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
  }
  async resolveBaseFilePath() {
    const preferredPath = "_bases/Home.base";
    const legacyPath = "bases/Home.base";
    if (await this.app.vault.adapter.exists(preferredPath)) {
      return preferredPath;
    }
    if (await this.app.vault.adapter.exists(legacyPath)) {
      return legacyPath;
    }
    if (await this.app.vault.adapter.exists("_bases")) {
      return preferredPath;
    }
    if (await this.app.vault.adapter.exists("bases")) {
      return legacyPath;
    }
    return preferredPath;
  }
  async createOrUpdateBaseFile(contentTypes, frontmatterProperties, defaultContentTypeId, projectDetection, enableMdxSupport) {
    const baseFilePath = await this.resolveBaseFilePath();
    const folderPath = baseFilePath.split("/")[0];
    const basesFolder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!basesFolder) {
      try {
        await this.app.vault.createFolder(folderPath);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (!errorMessage || !errorMessage.includes("already exists")) {
          console.warn(`BasesCMSConfig: Could not create ${folderPath} folder:`, error);
        }
      }
    }
    const baseFileAbstract = this.app.vault.getAbstractFileByPath(baseFilePath);
    let baseFile = baseFileAbstract instanceof import_obsidian17.TFile ? baseFileAbstract : null;
    let existingBase = null;
    if (baseFile) {
      try {
        const content = await this.app.vault.read(baseFile);
        existingBase = parse2(content);
      } catch (error) {
        console.error("BasesCMSConfig: Failed to parse existing base file:", error);
      }
    }
    const enabledTypes = contentTypes.filter((ct) => ct.enabled);
    console.debug("BasesCMSConfig: Generating base content for", contentTypes.length, "content types");
    console.debug("BasesCMSConfig: Enabled content types:", enabledTypes.map((ct) => ct.name));
    const baseContent = this.generateBaseContent(contentTypes, frontmatterProperties, defaultContentTypeId, existingBase, projectDetection, enableMdxSupport);
    const viewMatches = baseContent.match(/^\s*-\s+type:\s+bases-cms/gm);
    const viewCount = viewMatches ? viewMatches.length : 0;
    console.debug("BasesCMSConfig: Generated", viewCount, "views in base content");
    const baseFileAbstract2 = this.app.vault.getAbstractFileByPath(baseFilePath);
    baseFile = baseFileAbstract2 instanceof import_obsidian17.TFile ? baseFileAbstract2 : null;
    if (baseFile) {
      console.debug(`BasesCMSConfig: Modifying existing ${baseFilePath} file`);
      try {
        await this.app.vault.modify(baseFile, baseContent);
        console.debug(`BasesCMSConfig: Successfully modified ${baseFilePath} file`);
        return;
      } catch (error) {
        console.error("BasesCMSConfig: Failed to modify file:", error);
        throw error;
      }
    }
    console.debug(`BasesCMSConfig: Creating new ${baseFilePath} file`);
    try {
      await this.app.vault.create(baseFilePath, baseContent);
      console.debug(`BasesCMSConfig: Successfully created ${baseFilePath} file`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
        console.debug("BasesCMSConfig: File existed, attempting direct modify via path");
        try {
          const adapter = this.app.vault.adapter;
          if (adapter && typeof adapter.write === "function") {
            await adapter.write(baseFilePath, baseContent);
            console.debug("BasesCMSConfig: Successfully wrote Home.base file via adapter");
          } else {
            console.debug("BasesCMSConfig: Adapter write not available, retrying getAbstractFileByPath");
            for (let i = 0; i < 10; i++) {
              await new Promise((resolve6) => setTimeout(resolve6, 200));
              const retryFileAbstract = this.app.vault.getAbstractFileByPath(baseFilePath);
              const retryFile = retryFileAbstract instanceof import_obsidian17.TFile ? retryFileAbstract : null;
              if (retryFile) {
                await this.app.vault.modify(retryFile, baseContent);
                console.debug(`BasesCMSConfig: Successfully modified Home.base file on retry ${i + 1}`);
                return;
              }
            }
            console.error("BasesCMSConfig: File exists but cannot be found after all retries");
            throw new Error(`File exists but cannot be accessed. Please try again or manually edit ${baseFilePath}`);
          }
        } catch (writeError) {
          console.error("BasesCMSConfig: Failed to write file via adapter:", writeError);
          throw writeError;
        }
      } else {
        console.error("BasesCMSConfig: Failed to create base file:", error);
        throw error;
      }
    }
  }
  generateBaseContent(contentTypes, frontmatterProperties, defaultContentTypeId, existingBase, projectDetection, enableMdxSupport) {
    const lines = [];
    const defaultContentType = defaultContentTypeId ? contentTypes.find((ct) => ct.id === defaultContentTypeId && ct.enabled) : null;
    if (defaultContentType) {
      lines.push(`defaultView: "${defaultContentType.name}"`);
    }
    if (existingBase == null ? void 0 : existingBase.formulas) {
      lines.push("formulas:");
      for (const [key, value] of Object.entries(existingBase.formulas)) {
        if (typeof value === "string") {
          lines.push(`  ${key}: |-`);
          const formulaLines = value.split("\n");
          for (const formulaLine of formulaLines) {
            lines.push(`    ${formulaLine}`);
          }
        }
      }
      lines.push("");
    }
    lines.push("filters:");
    if (enableMdxSupport) {
      lines.push("  or:");
      lines.push('    - file.ext == "md"');
      lines.push('    - file.ext == "mdx"');
    } else {
      lines.push("  and:");
      lines.push('    - file.ext == "md"');
    }
    lines.push("");
    const allProperties = /* @__PURE__ */ new Set();
    for (const contentType of contentTypes) {
      const props = frontmatterProperties[contentType.id];
      if (props) {
        allProperties.add(`note.${props.titleProperty}`);
        allProperties.add(`note.${props.dateProperty}`);
        if (props.descriptionProperty) {
          allProperties.add(`note.${props.descriptionProperty}`);
        }
        if (props.tagsProperty) {
          allProperties.add(`note.${props.tagsProperty}`);
        }
        if (props.draftProperty) {
          allProperties.add(`note.${props.draftProperty}`);
        }
        if (props.imageProperty) {
          allProperties.add(`note.${props.imageProperty}`);
        }
      }
    }
    allProperties.add("note.title");
    allProperties.add("note.date");
    allProperties.add("note.pubDate");
    allProperties.add("note.draft");
    allProperties.add("file.fullname");
    allProperties.add("file.name");
    if (existingBase == null ? void 0 : existingBase.properties) {
      for (const prop of Object.keys(existingBase.properties)) {
        if (prop.startsWith("formula.")) {
          allProperties.add(prop);
        }
      }
    }
    if (allProperties.size > 0) {
      lines.push("properties:");
      const existingProps = (existingBase == null ? void 0 : existingBase.properties) || {};
      for (const prop of Array.from(allProperties).sort()) {
        lines.push(`  ${prop}:`);
        const existingProp = existingProps[prop];
        if (existingProp == null ? void 0 : existingProp.displayName) {
          lines.push(`    displayName: ${existingProp.displayName}`);
        } else if (prop === "file.fullname") {
          lines.push(`    displayName: Full File Name`);
        } else {
          const propName = prop.replace("note.", "").replace("file.", "");
          lines.push(`    displayName: ${this.capitalizeFirst(propName)}`);
        }
      }
      lines.push("");
    }
    lines.push("views:");
    const existingViews = (existingBase == null ? void 0 : existingBase.views) || [];
    const existingContentTypeNames = new Set(contentTypes.filter((ct) => ct.enabled).map((ct) => ct.name));
    const guideView = existingViews.find((v) => v.name === "Guide");
    const otherViews = existingViews.filter(
      (v) => v.name !== "All Content" && v.name !== "Guide" && !existingContentTypeNames.has(v.name || "")
    );
    if (defaultContentType) {
      const defaultViewProps = frontmatterProperties[defaultContentType.id];
      if (defaultViewProps) {
        const folderPath = this.pathResolver.getBasesCMSFolderPath(defaultContentType.folder, projectDetection);
        lines.push("  - type: bases-cms");
        lines.push(`    name: "${defaultContentType.name}"`);
        lines.push("    filters:");
        lines.push("      and:");
        if (folderPath === "" || folderPath === ".") {
          lines.push(`        - file.folder == "/"`);
        } else {
          lines.push(`        - file.folder.startsWith("${folderPath}")`);
        }
        lines.push(`    imageFormat: cover`);
        if (defaultViewProps.titleProperty) {
          lines.push(`    titleProperty: note.${defaultViewProps.titleProperty}`);
        } else {
          lines.push(`    titleProperty: file.fullname`);
        }
        if (defaultViewProps.dateProperty) {
          lines.push(`    dateProperty: note.${defaultViewProps.dateProperty}`);
        } else {
          lines.push(`    dateProperty: file.ctime`);
        }
        if (defaultViewProps.descriptionProperty) {
          lines.push(`    descriptionProperty: note.${defaultViewProps.descriptionProperty}`);
        }
        if (defaultViewProps.imageProperty) {
          lines.push(`    imageProperty: note.${defaultViewProps.imageProperty}`);
        }
        lines.push(`    showTags: ${defaultViewProps.tagsProperty ? "true" : "false"}`);
        if (defaultViewProps.tagsProperty) {
          lines.push(`    tagsProperty: note.${defaultViewProps.tagsProperty}`);
        }
        lines.push(`    showDate: true`);
        lines.push(`    showDraftStatus: ${defaultViewProps.hasDraftStatus ? "true" : "false"}`);
        if (defaultViewProps.hasDraftStatus) {
          if (defaultViewProps.draftProperty) {
            lines.push(`    draftStatusProperty: note.${defaultViewProps.draftProperty}`);
            lines.push(`    draftStatusReverse: ${defaultViewProps.draftLogic === "false-draft" ? "true" : "false"}`);
          } else {
            lines.push(`    draftStatusUseFilenamePrefix: true`);
          }
        }
        lines.push(`    customizeNewButton: true`);
        lines.push(`    newNoteLocation: "${folderPath}"`);
        lines.push(`    fallbackToEmbeds: if-empty`);
        lines.push(`    propertyDisplay1: file.fullname`);
        lines.push(`    showTextPreview: true`);
        lines.push(`    propertyLabels: above`);
        lines.push(`    sort:`);
        lines.push(`      - property: ${defaultViewProps.dateProperty ? `note.${defaultViewProps.dateProperty}` : "file.ctime"}`);
        lines.push(`        direction: DESC`);
      }
    }
    for (const contentType of contentTypes) {
      if (!contentType.enabled) {
        continue;
      }
      if (contentType.name === "All Content") {
        continue;
      }
      if (defaultContentType && contentType.id === defaultContentType.id) {
        continue;
      }
      const props = frontmatterProperties[contentType.id];
      if (!props) {
        continue;
      }
      const folderPath = this.pathResolver.getBasesCMSFolderPath(contentType.folder, projectDetection);
      lines.push("  - type: bases-cms");
      lines.push(`    name: "${contentType.name}"`);
      lines.push("    filters:");
      lines.push("      and:");
      if (folderPath === "" || folderPath === ".") {
        lines.push(`        - file.folder == "/"`);
      } else {
        lines.push(`        - file.folder.startsWith("${folderPath}")`);
      }
      lines.push(`    imageFormat: cover`);
      if (props.titleProperty) {
        lines.push(`    titleProperty: note.${props.titleProperty}`);
      } else {
        lines.push(`    titleProperty: file.fullname`);
      }
      if (props.dateProperty) {
        lines.push(`    dateProperty: note.${props.dateProperty}`);
      } else {
        lines.push(`    dateProperty: file.ctime`);
      }
      if (props.descriptionProperty) {
        lines.push(`    descriptionProperty: note.${props.descriptionProperty}`);
      }
      if (props.imageProperty) {
        lines.push(`    imageProperty: note.${props.imageProperty}`);
      }
      lines.push(`    showTags: ${props.tagsProperty ? "true" : "false"}`);
      if (props.tagsProperty) {
        lines.push(`    tagsProperty: note.${props.tagsProperty}`);
      }
      lines.push(`    showDate: true`);
      lines.push(`    showDraftStatus: ${props.hasDraftStatus ? "true" : "false"}`);
      if (props.hasDraftStatus) {
        if (props.draftProperty) {
          lines.push(`    draftStatusProperty: note.${props.draftProperty}`);
          lines.push(`    draftStatusReverse: ${props.draftLogic === "false-draft" ? "true" : "false"}`);
        } else {
          lines.push(`    draftStatusUseFilenamePrefix: true`);
        }
      }
      lines.push(`    customizeNewButton: true`);
      lines.push(`    newNoteLocation: "${folderPath}"`);
      lines.push(`    fallbackToEmbeds: if-empty`);
      lines.push(`    propertyDisplay1: file.fullname`);
      lines.push(`    showTextPreview: true`);
      lines.push(`    propertyLabels: above`);
      lines.push(`    sort:`);
      lines.push(`      - property: ${props.dateProperty ? `note.${props.dateProperty}` : "file.ctime"}`);
      lines.push(`        direction: DESC`);
    }
    for (const view of otherViews) {
      lines.push(...this.serializeView(view));
    }
    if (guideView) {
      lines.push(...this.serializeView(guideView));
    }
    return lines.join("\n");
  }
  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  /**
   * Serialize a view object to YAML lines (with proper indentation)
   */
  serializeView(view) {
    const viewLines = [];
    viewLines.push("  - type: bases-cms");
    viewLines.push(`    name: "${view.name}"`);
    if (view.filters) {
      viewLines.push("    filters:");
      if (view.filters.and) {
        if (view.filters.and.length === 0) {
          viewLines.push("      and: []");
        } else {
          viewLines.push("      and:");
          for (const filter of view.filters.and) {
            if (typeof filter === "string") {
              viewLines.push(`        - ${filter}`);
            } else if (typeof filter === "object") {
              for (const [key, value] of Object.entries(filter)) {
                const valueStr = typeof value === "string" ? `"${value}"` : String(value);
                viewLines.push(`        - ${key}: ${valueStr}`);
              }
            }
          }
        }
      }
    }
    if (view.groupBy) {
      viewLines.push("    groupBy:");
      if (typeof view.groupBy === "object") {
        if (view.groupBy.property) viewLines.push(`      property: ${view.groupBy.property}`);
        if (view.groupBy.direction) viewLines.push(`      direction: ${view.groupBy.direction}`);
      } else if (typeof view.groupBy === "string") {
        viewLines.push(`      ${view.groupBy}`);
      }
    }
    if (view.order) {
      if (view.order.length === 0) {
        viewLines.push("    order: []");
      } else {
        viewLines.push("    order:");
        for (const orderItem of view.order) {
          viewLines.push(`      - ${orderItem}`);
        }
      }
    }
    if (view.sort) {
      if (view.sort.length === 0) {
        viewLines.push("    sort: []");
      } else {
        viewLines.push("    sort:");
        for (const sortItem of view.sort) {
          if (typeof sortItem === "object" && sortItem.property) {
            viewLines.push(`      - property: ${sortItem.property}`);
            viewLines.push(`        direction: ${sortItem.direction || "ASC"}`);
          }
        }
      }
    }
    const skipProps = ["type", "name", "filters", "groupBy", "order", "sort"];
    for (const prop of Object.keys(view)) {
      if (skipProps.includes(prop) || view[prop] === void 0) {
        continue;
      }
      const value = view[prop];
      if (value === null) {
        viewLines.push(`    ${prop}: null`);
      } else if (typeof value === "boolean") {
        viewLines.push(`    ${prop}: ${value}`);
      } else if (typeof value === "number") {
        viewLines.push(`    ${prop}: ${value}`);
      } else if (typeof value === "string") {
        if (value === "") {
          viewLines.push(`    ${prop}: ""`);
          continue;
        }
        const isPropertyRef = (prop.includes("Property") || prop.startsWith("propertyDisplay")) && (value.startsWith("note.") || value.startsWith("file."));
        if (isPropertyRef) {
          viewLines.push(`    ${prop}: ${value}`);
        } else if (prop === "newNoteLocation") {
          viewLines.push(`    ${prop}: "${value}"`);
        } else {
          viewLines.push(`    ${prop}: "${value}"`);
        }
      }
    }
    return viewLines;
  }
};

// src/utils/SEOConfig.ts
var import_obsidian18 = require("obsidian");
var SEOConfigurator = class {
  constructor(app) {
    this.app = app;
    this.pathResolver = new PathResolver(app);
  }
  generateSEOConfig(contentTypes, frontmatterProperties, projectDetection, enableMdxSupport) {
    const firstType = contentTypes.find((ct) => ct.enabled);
    const firstProps = firstType ? frontmatterProperties[firstType.id] : void 0;
    const scanDirectories = contentTypes.filter((ct) => ct.enabled).map((ct) => this.pathResolver.getFolderPathFromVaultRoot(ct.folder, projectDetection)).join(",");
    const config = {
      // Only set titleProperty if it exists (not blank) - this comes from the wizard
      titleProperty: (firstProps == null ? void 0 : firstProps.titleProperty) && firstProps.titleProperty.trim() !== "" ? firstProps.titleProperty : "title",
      // Default fallback
      // Only set descriptionProperty if it exists (not blank) - this comes from the wizard
      descriptionProperty: (firstProps == null ? void 0 : firstProps.descriptionProperty) && firstProps.descriptionProperty.trim() !== "" ? firstProps.descriptionProperty : void 0,
      scanDirectories,
      // Don't set these - we don't collect them in the wizard
      keywordProperty: void 0,
      useFilenameAsTitle: false,
      useFilenameAsSlug: true,
      enableMDXSupport: enableMdxSupport != null ? enableMdxSupport : false
    };
    return config;
  }
  async saveConfig(config) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const seoPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["seo"];
      if (seoPlugin && seoPlugin.settings) {
        const pluginSettings = seoPlugin.settings;
        if (config.scanDirectories) {
          pluginSettings.scanDirectories = config.scanDirectories;
        }
        if (config.titleProperty !== void 0) {
          pluginSettings.titleProperty = config.titleProperty;
        }
        if (config.descriptionProperty !== void 0) {
          pluginSettings.descriptionProperty = config.descriptionProperty;
        }
        if (config.enableMDXSupport !== void 0) {
          pluginSettings.enableMDXSupport = config.enableMDXSupport;
        }
        if (typeof seoPlugin.saveSettings === "function") {
          await seoPlugin.saveSettings();
          console.debug("SEOConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save SEO config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "seo";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      let existingData = {};
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile && dataFile instanceof import_obsidian18.TFile) {
        try {
          existingData = JSON.parse(await this.app.vault.read(dataFile));
        } catch (error) {
          console.warn("Failed to parse existing SEO data.json, starting fresh:", error);
          existingData = {};
        }
      }
      const mergedData = {
        ...existingData,
        // Always update scanDirectories
        scanDirectories: config.scanDirectories,
        // Update titleProperty if provided (from wizard)
        ...config.titleProperty !== void 0 && { titleProperty: config.titleProperty },
        // Update descriptionProperty if provided (from wizard)
        ...config.descriptionProperty !== void 0 && { descriptionProperty: config.descriptionProperty },
        // Update enableMDXSupport if provided (from wizard)
        ...config.enableMDXSupport !== void 0 && { enableMDXSupport: config.enableMDXSupport }
        // All other properties (keywordProperty, useFilenameAsTitle, useFilenameAsSlug, etc.)
        // are preserved from existingData - we don't collect them in the wizard
      };
      if (dataFile instanceof import_obsidian18.TFile) {
        await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
        console.debug("SEOConfig: Successfully updated SEO plugin data.json (via file)");
      } else {
        const pluginDir = `${configDir}/plugins/${pluginId}`;
        const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
        if (!pluginDirFile) {
          await this.app.vault.createFolder(pluginDir);
        }
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
        console.debug("SEOConfig: Successfully created SEO plugin data.json (via file)");
      }
    } catch (error) {
      console.error("Failed to save SEO config (fallback):", error);
      throw error;
    }
  }
};

// src/utils/PropertyOverFileNameConfig.ts
var import_obsidian19 = require("obsidian");
var PropertyOverFileNameConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(config) {
    var _a;
    try {
      const plugins = this.app.plugins;
      const propertyOverFileNamePlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a["property-over-file-name"];
      if (propertyOverFileNamePlugin && propertyOverFileNamePlugin.settings) {
        const pluginSettings = propertyOverFileNamePlugin.settings;
        console.debug("PropertyOverFileNameConfig: Using plugin.saveSettings() method");
        console.debug("PropertyOverFileNameConfig: Input config.enableMdxSupport =", config.enableMdxSupport);
        if (config.propertyKey) {
          pluginSettings.propertyKey = config.propertyKey;
        }
        if (config.enableMdxSupport !== void 0) {
          pluginSettings.enableMdxSupport = config.enableMdxSupport;
          console.debug("PropertyOverFileNameConfig: Set pluginSettings.enableMdxSupport to", config.enableMdxSupport);
        } else {
          console.warn("PropertyOverFileNameConfig: config.enableMdxSupport is undefined!");
        }
        if (typeof propertyOverFileNamePlugin.saveSettings === "function") {
          await propertyOverFileNamePlugin.saveSettings();
          console.debug("PropertyOverFileNameConfig: Successfully saved via plugin.saveSettings()");
          return;
        } else {
          console.warn("PropertyOverFileNameConfig: Plugin saveSettings not available, using fallback");
        }
      } else {
        console.warn("PropertyOverFileNameConfig: Plugin not found or settings not available, using fallback");
      }
      await this.saveConfigFallback(config);
    } catch (error) {
      console.error("Failed to save Property Over File Name config via plugin method:", error);
      await this.saveConfigFallback(config);
    }
  }
  async saveConfigFallback(config) {
    const pluginId = "property-over-file-name";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    try {
      let existingData = {};
      const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
      if (dataFile instanceof import_obsidian19.TFile) {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      }
      console.debug("PropertyOverFileNameConfig: Using fallback file method");
      console.debug("PropertyOverFileNameConfig: Input config =", JSON.stringify(config));
      console.debug("PropertyOverFileNameConfig: Input config.enableMdxSupport =", config.enableMdxSupport);
      console.debug("PropertyOverFileNameConfig: Existing data =", JSON.stringify(existingData));
      const mergedData = {
        ...existingData,
        ...config
      };
      if (config.enableMdxSupport !== void 0) {
        mergedData.enableMdxSupport = config.enableMdxSupport;
        console.debug("PropertyOverFileNameConfig: Explicitly set enableMdxSupport to", config.enableMdxSupport);
      } else {
        console.warn("PropertyOverFileNameConfig: config.enableMdxSupport is undefined!");
      }
      console.debug("PropertyOverFileNameConfig: Final mergedData.enableMdxSupport =", mergedData.enableMdxSupport);
      console.debug("PropertyOverFileNameConfig: Final mergedData =", JSON.stringify(mergedData));
      if (dataFile instanceof import_obsidian19.TFile) {
        await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
      } else {
        const pluginDir = `${configDir}/plugins/${pluginId}`;
        const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
        if (!pluginDirFile) {
          try {
            await this.app.vault.createFolder(pluginDir);
          } catch (error) {
            if (error instanceof Error && !error.message.includes("already exists")) {
              throw error;
            }
          }
        }
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      }
    } catch (error) {
      console.error("Failed to save Property Over File Name config (fallback):", error);
      throw error;
    }
  }
};

// src/utils/UITweakerConfig.ts
var import_obsidian20 = require("obsidian");
var UITweakerConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(enableMdxSupport) {
    var _a;
    const pluginId = "ui-tweaker";
    try {
      const plugins = this.app.plugins;
      const uiTweakerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (uiTweakerPlugin && uiTweakerPlugin.settings) {
        console.debug("UITweakerConfig: Using plugin.settings API");
        const settings = uiTweakerPlugin.settings;
        this.forceMdxUpdate(settings, enableMdxSupport);
        if (typeof uiTweakerPlugin.saveSettings === "function") {
          await uiTweakerPlugin.saveSettings();
          console.debug("UITweakerConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      console.debug("UITweakerConfig: Plugin API not available, using fallback file method");
      await this.saveConfigFallback(enableMdxSupport);
    } catch (error) {
      console.error("Failed to save UI Tweaker config:", error);
      await this.saveConfigFallback(enableMdxSupport);
    }
  }
  forceMdxUpdate(settings, enableMdxSupport) {
    const mdxFileTypes = enableMdxSupport ? "md,mdx" : "md";
    if (!settings.tabBarCommands || !Array.isArray(settings.tabBarCommands)) {
      settings.tabBarCommands = [];
    }
    const tabBarCommands = settings.tabBarCommands;
    const toolbarCommandIndex = tabBarCommands.findIndex((cmd) => cmd.id === "editing-toolbar:hide-show-menu");
    if (toolbarCommandIndex !== -1) {
      tabBarCommands[toolbarCommandIndex] = {
        ...tabBarCommands[toolbarCommandIndex],
        "showOnFileTypes": mdxFileTypes
      };
      console.debug(`UITweakerConfig: Updated existing toolbar command showOnFileTypes to ${mdxFileTypes}`);
    } else {
      tabBarCommands.push({
        "id": "editing-toolbar:hide-show-menu",
        "icon": "lucide-panel-top-open",
        "name": "Toggle editing toolbar",
        "displayName": "Editing Toolbar: Hide/Show ",
        "mode": "desktop",
        "toggleIcon": "lucide-panel-top-close",
        "showOnFileTypes": mdxFileTypes
      });
      console.debug(`UITweakerConfig: Added missing toolbar command with showOnFileTypes=${mdxFileTypes}`);
    }
  }
  async saveConfigFallback(enableMdxSupport) {
    const pluginId = "ui-tweaker";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile instanceof import_obsidian20.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing ui-tweaker data.json:", error);
      }
    }
    this.forceMdxUpdate(existingData, enableMdxSupport);
    const pluginDir = `${configDir}/plugins/${pluginId}`;
    const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
    if (!pluginDirFile) {
      try {
        await this.app.vault.createFolder(pluginDir);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists") && !errorMessage.includes("Folder already exists")) {
          throw error;
        }
      }
    }
    const content = JSON.stringify(existingData, null, 2);
    if (dataFile instanceof import_obsidian20.TFile) {
      await this.app.vault.modify(dataFile, content);
    } else {
      await this.app.vault.create(pluginDataPath, content);
    }
    console.debug("UITweakerConfig: Successfully saved ui-tweaker config via fallback");
  }
};

// src/utils/ImageInserterConfig.ts
var import_obsidian21 = require("obsidian");
var ImageInserterConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(config, imageProperty) {
    var _a;
    const pluginId = "insert-unsplash-image";
    try {
      const plugins = this.app.plugins;
      const imageInserterPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (imageInserterPlugin && imageInserterPlugin.settings) {
        const pluginSettings = imageInserterPlugin.settings;
        if (!pluginSettings.frontmatter) {
          pluginSettings.frontmatter = {};
        }
        if (config.valueFormat) {
          pluginSettings.frontmatter.valueFormat = config.valueFormat;
        }
        if (imageProperty) {
          pluginSettings.frontmatter.key = imageProperty;
        }
        if (typeof imageInserterPlugin.saveSettings === "function") {
          await imageInserterPlugin.saveSettings();
          console.debug("ImageInserterConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(config, imageProperty);
    } catch (error) {
      console.error("Failed to save Image Inserter config:", error);
      try {
        await this.saveConfigFallback(config, imageProperty);
      } catch (fallbackError) {
        console.error("Failed to save Image Inserter config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(config, imageProperty) {
    const pluginId = "insert-unsplash-image";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian21.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Image Inserter data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const mergedData = {
      ...existingData
    };
    const frontmatter = mergedData.frontmatter || {};
    if (!mergedData.frontmatter) {
      mergedData.frontmatter = frontmatter;
    }
    if (config.valueFormat) {
      frontmatter.valueFormat = config.valueFormat;
    }
    if (imageProperty) {
      frontmatter.key = imageProperty;
    }
    if (dataFile && dataFile instanceof import_obsidian21.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(mergedData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(mergedData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian21.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(mergedData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
};

// src/utils/SimpleBannerConfig.ts
var import_obsidian22 = require("obsidian");
var SimpleBannerConfigurator = class {
  constructor(app) {
    this.app = app;
  }
  async saveConfig(imageProperty) {
    var _a;
    const pluginId = "simple-banner";
    try {
      const plugins = this.app.plugins;
      const simpleBannerPlugin = (_a = plugins == null ? void 0 : plugins.plugins) == null ? void 0 : _a[pluginId];
      if (simpleBannerPlugin && simpleBannerPlugin.settings) {
        if (!simpleBannerPlugin.settings.properties) {
          simpleBannerPlugin.settings.properties = {};
        }
        simpleBannerPlugin.settings.properties.image = imageProperty;
        if (typeof simpleBannerPlugin.saveSettings === "function") {
          await simpleBannerPlugin.saveSettings();
          console.debug("SimpleBannerConfig: Successfully saved via plugin.saveSettings()");
          return;
        }
      }
      await this.saveConfigFallback(imageProperty);
    } catch (error) {
      console.error("Failed to save Simple Banner config:", error);
      try {
        await this.saveConfigFallback(imageProperty);
      } catch (fallbackError) {
        console.error("Failed to save Simple Banner config via fallback:", fallbackError);
      }
    }
  }
  async saveConfigFallback(imageProperty) {
    const pluginId = "simple-banner";
    const configDir = this.app.vault.configDir;
    const pluginDataPath = `${configDir}/plugins/${pluginId}/data.json`;
    let existingData = {};
    const dataFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
    if (dataFile && dataFile instanceof import_obsidian22.TFile) {
      try {
        existingData = JSON.parse(await this.app.vault.read(dataFile));
      } catch (error) {
        console.warn("Failed to parse existing Simple Banner data.json, starting fresh:", error);
        existingData = {};
      }
    }
    const properties = existingData.properties || {};
    if (!existingData.properties) {
      existingData.properties = properties;
    }
    properties.image = imageProperty;
    if (dataFile && dataFile instanceof import_obsidian22.TFile) {
      await this.app.vault.modify(dataFile, JSON.stringify(existingData, null, 2));
    } else {
      const pluginDir = `${configDir}/plugins/${pluginId}`;
      const pluginDirFile = this.app.vault.getAbstractFileByPath(pluginDir);
      if (!pluginDirFile) {
        try {
          await this.app.vault.createFolder(pluginDir);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage && !errorMessage.includes("already exists") && !errorMessage.includes("File already exists")) {
            throw error;
          }
        }
      }
      try {
        await this.app.vault.create(pluginDataPath, JSON.stringify(existingData, null, 2));
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage && (errorMessage.includes("already exists") || errorMessage.includes("File already exists"))) {
          const retryFile = this.app.vault.getAbstractFileByPath(pluginDataPath);
          if (retryFile instanceof import_obsidian22.TFile) {
            await this.app.vault.modify(retryFile, JSON.stringify(existingData, null, 2));
          } else {
            throw error;
          }
        } else {
          throw error;
        }
      }
    }
  }
};

// src/ui/wizard/FinalizeStep.ts
var FinalizeStep = class extends BaseWizardStep {
  constructor(app, containerEl, state, onNext, onBack, onCancel) {
    super(app, containerEl, state, onNext, onBack, onCancel);
    this.applied = false;
    this.pluginManager = new PluginManager(app);
    this.basesCMSConfigurator = new BasesCMSConfigurator(app);
    this.astroComposerConfigurator = new AstroComposerConfigurator(app);
    this.seoConfigurator = new SEOConfigurator(app);
    this.commanderConfigurator = new CommanderConfigurator(app);
    this.propertyOverFileNameConfigurator = new PropertyOverFileNameConfigurator(app);
    this.uiTweakerConfigurator = new UITweakerConfigurator(app);
    this.imageInserterConfigurator = new ImageInserterConfigurator(app);
    this.simpleBannerConfigurator = new SimpleBannerConfigurator(app);
    this.imageManagerConfigurator = new ImageManagerConfigurator(app);
    this.homeBaseConfigurator = new HomeBaseConfigurator(app);
    this.explorerFocusConfigurator = new ExplorerFocusConfigurator(app);
  }
  isApplied() {
    return this.applied;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Finalize configuration" });
    containerEl.createEl("p", {
      // eslint-disable-next-line obsidianmd/ui/sentence-case
      text: 'Review your configuration and click "Apply and restart" below to save and apply all settings.'
    });
    const summary = containerEl.createEl("div", { cls: "finalize-summary" });
    summary.createEl("h3", { text: "Summary" });
    const enabledContentTypes = this.state.contentTypes.filter((ct) => ct.enabled);
    summary.createEl("p", { text: `Content Types: ${enabledContentTypes.length}` });
    summary.createEl("p", { text: `WYSIWYG Toolbar: ${this.state.enableWYSIWYG ? "Enabled" : "Disabled"}` });
    const basesViewsCount = enabledContentTypes.length;
    summary.createEl("p", { text: `Bases CMS Views: ${basesViewsCount} new view${basesViewsCount !== 1 ? "s" : ""} to be created` });
    const seoDirectories = enabledContentTypes.map((ct) => ct.folder);
    const seoDirectoriesCount = seoDirectories.length;
    summary.createEl("p", { text: `SEO Scan Directories: ${seoDirectoriesCount} director${seoDirectoriesCount !== 1 ? "ies" : "y"} (${seoDirectories.join(", ")})` });
  }
  async applyConfiguration(shouldRestart = false) {
    return this.applyConfigurationInternal(shouldRestart);
  }
  async applyConfigurationInternal(shouldRestart = false) {
    if (this.applied) {
      return;
    }
    try {
      console.debug("FinalizeStep: Starting configuration application");
      console.debug("FinalizeStep: Enabled content types:", this.state.contentTypes.filter((ct) => ct.enabled).map((ct) => ct.name));
      console.debug("FinalizeStep: Configuring plugin states");
      await this.pluginManager.setPluginStates(this.state.enabledPlugins, this.state.disabledPlugins);
      console.debug("FinalizeStep: Configuring Bases CMS");
      await this.basesCMSConfigurator.createOrUpdateBaseFile(
        this.state.contentTypes,
        this.state.frontmatterProperties,
        this.state.defaultContentTypeId,
        this.state.projectDetection,
        this.state.enableMdxSupport === true
      );
      console.debug("FinalizeStep: Bases CMS configuration complete");
      if (this.state.defaultContentTypeId) {
        const defaultType = this.state.contentTypes.find((ct) => ct.id === this.state.defaultContentTypeId);
        if (defaultType) {
          console.debug("FinalizeStep: Updating active Bases views to:", defaultType.name);
          await this.updateActiveBasesViews(defaultType.name, shouldRestart);
        }
      }
      if (this.state.projectDetection) {
        console.debug("FinalizeStep: Configuring Astro Composer, enableMdxSupport =", this.state.enableMdxSupport);
        const astroConfig = await this.astroComposerConfigurator.configureAstroComposer(
          this.state.contentTypes,
          this.state.frontmatterProperties,
          this.state.projectDetection.projectRoot,
          this.state.projectDetection.configFilePath,
          this.state.defaultContentTypeId,
          this.state.projectDetection,
          this.state.enableMdxSupport
        );
        console.debug("FinalizeStep: Astro Composer config.showMdxFilesInExplorer =", astroConfig.showMdxFilesInExplorer);
        this.state.astroComposerConfig = astroConfig;
        await this.astroComposerConfigurator.saveConfig(astroConfig);
      }
      const seoConfig = this.seoConfigurator.generateSEOConfig(
        this.state.contentTypes,
        this.state.frontmatterProperties,
        this.state.projectDetection,
        this.state.enableMdxSupport
      );
      this.state.seoConfig = seoConfig;
      await this.seoConfigurator.saveConfig(seoConfig);
      console.debug(`FinalizeStep: Configuring editing toolbar, enableWYSIWYG=${this.state.enableWYSIWYG}`);
      await this.commanderConfigurator.toggleEditingToolbarCommand(this.app, this.state.enableWYSIWYG);
      const commanderConfig = this.commanderConfigurator.generateCommanderConfig(this.state.enableWYSIWYG);
      this.state.commanderConfig = commanderConfig;
      await this.commanderConfigurator.saveConfig(commanderConfig);
      const firstType = this.state.contentTypes.find((ct) => ct.enabled);
      const firstProps = firstType ? this.state.frontmatterProperties[firstType.id] : void 0;
      if (firstProps && firstProps.titleProperty) {
        this.state.propertyOverFileName.propertyKey = firstProps.titleProperty;
      }
      console.debug("FinalizeStep: Configuring Property Over File Name");
      console.debug("FinalizeStep: this.state.enableMdxSupport =", this.state.enableMdxSupport);
      console.debug("FinalizeStep: this.state.propertyOverFileName before =", JSON.stringify(this.state.propertyOverFileName));
      const mdxSupportValue = this.state.enableMdxSupport === true;
      this.state.propertyOverFileName.enableMdxSupport = mdxSupportValue;
      console.debug("FinalizeStep: Set enableMdxSupport to", mdxSupportValue);
      console.debug("FinalizeStep: this.state.propertyOverFileName after =", JSON.stringify(this.state.propertyOverFileName));
      console.debug("FinalizeStep: About to call saveConfig with:", JSON.stringify(this.state.propertyOverFileName));
      await this.propertyOverFileNameConfigurator.saveConfig(this.state.propertyOverFileName);
      console.debug("FinalizeStep: Configuring UI Tweaker");
      await this.uiTweakerConfigurator.saveConfig(this.state.enableMdxSupport === true);
      const imageProperty = firstProps == null ? void 0 : firstProps.imageProperty;
      if (imageProperty && this.state.enabledPlugins.includes("simple-banner")) {
        await this.simpleBannerConfigurator.saveConfig(imageProperty);
      }
      if (imageProperty && this.state.enabledPlugins.includes("insert-unsplash-image")) {
        let imageInserterConfig = { ...this.state.imageInserter };
        if (this.state.attachmentHandlingMode === "same-folder") {
          imageInserterConfig.valueFormat = "[[{image-url}]]";
          imageInserterConfig.insertFormat = "[[{image-url}]]";
        } else {
          const folderName = this.state.attachmentFolderName || "attachments";
          imageInserterConfig.valueFormat = `[[${folderName}/{image-url}]]`;
          imageInserterConfig.insertFormat = `[[${folderName}/{image-url}]]`;
        }
        await this.imageInserterConfigurator.saveConfig(imageInserterConfig, imageProperty);
      }
      if (this.state.enabledPlugins.includes("image-manager")) {
        await this.imageManagerConfigurator.saveConfig(this.state.imageManager);
      }
      if (this.state.enabledPlugins.includes("home-base")) {
        await this.homeBaseConfigurator.saveConfig(this.state.homeBase);
      }
      if (this.state.enabledPlugins.includes("explorer-focus")) {
        await this.explorerFocusConfigurator.saveConfig(this.state.explorerFocus);
      }
      if (this.state.defaultContentTypeId) {
        const defaultType = this.state.contentTypes.find((ct) => ct.id === this.state.defaultContentTypeId);
        if (defaultType) {
          console.debug("FinalizeStep: Configuring Obsidian settings for default content type:", defaultType.name);
          const app = this.app;
          let targetPath = "./";
          if (this.state.attachmentHandlingMode === "same-folder") {
            targetPath = "./";
          } else if (this.state.attachmentHandlingMode === "subfolder") {
            const folderName = this.state.attachmentFolderName || "attachments";
            targetPath = `./${folderName}`;
          } else if (this.state.attachmentHandlingMode === "specified-folder") {
            const folderName = this.state.attachmentFolderName || "attachments";
            targetPath = folderName;
          }
          if (app.setting && typeof app.setting.set === "function") {
            console.debug("FinalizeStep: Using app.setting API");
            await app.setting.set("newFileLocation", "folder");
            await app.setting.set("newFileFolderPath", defaultType.folder);
            await app.setting.set("attachmentFolderPath", targetPath);
            await app.setting.set("newLinkFormat", "relative");
            if (typeof app.setting.save === "function") {
              await app.setting.save();
              console.debug("FinalizeStep: Obsidian settings saved via app.setting.save()");
            }
          } else {
            console.debug("FinalizeStep: Using vault.config API");
            const vault = this.app.vault;
            const obsidianSettings = vault.config;
            if (!obsidianSettings) {
              console.error("FinalizeStep: vault.config is not available");
            } else {
              obsidianSettings.newFileLocation = "folder";
              obsidianSettings.newFileFolderPath = defaultType.folder;
              obsidianSettings.attachmentFolderPath = targetPath;
              obsidianSettings.newLinkFormat = "relative";
              if (typeof vault.saveConfig === "function") {
                await vault.saveConfig();
                console.debug("FinalizeStep: Obsidian settings saved via vault.saveConfig()");
              } else {
                console.error("FinalizeStep: vault.saveConfig() is not available");
              }
            }
          }
        }
      }
      this.applied = true;
      if (shouldRestart) {
        new import_obsidian23.Notice("Configuration applied. Obsidian will now restart...", 3e3);
      } else {
        new import_obsidian23.Notice("Configuration applied successfully! You may need to restart Obsidian to see all changes.", 8e3);
      }
    } catch (error) {
      console.error("Failed to apply configuration:", error);
      new import_obsidian23.Notice("Failed to apply configuration. Please check the console for details.", 6e3);
    }
  }
  /**
   * Find any active Bases views and switch them to the new default view.
   * Closes old tabs and reopens them to force a clean reload if not restarting.
   */
  async updateActiveBasesViews(defaultViewName, shouldRestart) {
    const baseFilePath = await this.basesCMSConfigurator.resolveBaseFilePath();
    let updated = false;
    const leavesToUpdate = [];
    this.app.workspace.iterateAllLeaves((leaf) => {
      var _a;
      const viewType = leaf.view.getViewType();
      if (viewType === "bases" || viewType === "bases-cms") {
        const state = leaf.getViewState();
        if (((_a = state.state) == null ? void 0 : _a.file) === baseFilePath) {
          console.debug(`FinalizeStep: Found Bases leaf to update (type: ${viewType})`);
          leavesToUpdate.push({ leaf, state });
        }
      }
    });
    for (const { leaf, state } of leavesToUpdate) {
      console.debug("FinalizeStep: Updating existing Bases leaf state");
      await leaf.setViewState({
        ...state,
        state: {
          ...state.state,
          view: defaultViewName,
          viewName: defaultViewName
        }
      });
      updated = true;
    }
    if (!updated) {
      console.debug("FinalizeStep: Opening new Bases leaf with fresh state");
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.setViewState({
        type: "bases-cms",
        active: true,
        state: {
          file: baseFilePath,
          view: defaultViewName,
          viewName: defaultViewName
        }
      });
      this.app.workspace.setActiveLeaf(leaf, { focus: true });
      updated = true;
    }
    if (shouldRestart) {
      try {
        const adapter = this.app.vault.adapter;
        const configDir = this.app.vault.configDir;
        const workspacePath = `${configDir}/workspace.json`;
        if (await adapter.exists(workspacePath)) {
          console.debug("FinalizeStep: Attempting direct workspace.json modification");
          const content = await adapter.read(workspacePath);
          const workspace = JSON.parse(content);
          let modified = false;
          const updateNode = (node) => {
            var _a;
            if (!node) return;
            if (node.type === "leaf" && node.state) {
              if ((node.state.type === "bases" || node.state.type === "bases-cms") && ((_a = node.state.state) == null ? void 0 : _a.file) === baseFilePath) {
                console.debug(`FinalizeStep: Found Bases leaf in workspace.json, updating to ${defaultViewName}`);
                if (node.state.state) {
                  node.state.state.view = defaultViewName;
                  node.state.state.viewName = defaultViewName;
                  modified = true;
                }
              }
            }
            if (node.children) {
              if (Array.isArray(node.children)) {
                node.children.forEach((child) => updateNode(child));
              } else {
                updateNode(node.children);
              }
            }
          };
          updateNode(workspace.main);
          updateNode(workspace.left);
          updateNode(workspace.right);
          if (modified) {
            await adapter.write(workspacePath, JSON.stringify(workspace, null, 2));
            console.debug("FinalizeStep: Successfully modified workspace.json");
          }
        }
      } catch (error) {
        console.warn("FinalizeStep: Failed to modify workspace.json directly:", error);
      }
    }
  }
  validate() {
    return true;
  }
  getTitle() {
    return "Finalize";
  }
  getDescription() {
    return "Review and apply configuration";
  }
};

// src/ui/SetupWizardModal.ts
function setCssProps8(element, props) {
  for (const [key, value] of Object.entries(props)) {
    const cssKey = key.replace(/([A-Z])/g, "-$1").toLowerCase();
    element.style.setProperty(cssKey, value);
  }
}
var SetupWizardModal = class extends import_obsidian24.Modal {
  // Track the last step where "Next" was clicked
  constructor(app, initialState, pluginInstance) {
    var _a, _b;
    super(app);
    this.currentStepInstance = null;
    this.isCompleting = false;
    this.initialSettingsSnapshot = null;
    this.lastSavedStepIndex = -1;
    this.plugin = pluginInstance || ((_b = (_a = app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["vault-cms"]);
    if (!this.plugin) {
      throw new Error("VaultCMSPlugin instance is required");
    }
    this.stateManager = new WizardStateManager(this.plugin);
    if (initialState) {
      this.stateManager.updateState(initialState);
    }
    this.steps = [
      WelcomeStep,
      ProjectDetectionStep,
      ContentTypeStep,
      DefaultContentTypeStep,
      FrontmatterPropertiesStep,
      WYSIWYGPreferenceStep,
      BasesCMSConfigStep,
      AstroComposerStep,
      SEOConfigStep,
      OptionalPluginsStep,
      IgnoreStep,
      FinalizeStep
    ];
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vault-cms-wizard");
    await this.stateManager.refreshState();
    this.initialSettingsSnapshot = this.createSettingsSnapshot();
    void this.renderCurrentStep();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.isCompleting = false;
  }
  scrollToTop() {
    const { contentEl } = this;
    let scrollableParent = contentEl;
    while (scrollableParent && scrollableParent !== document.body) {
      const style = window.getComputedStyle(scrollableParent);
      if (scrollableParent.scrollHeight > scrollableParent.clientHeight && (style.overflowY === "auto" || style.overflowY === "scroll" || style.overflow === "auto" || style.overflow === "scroll")) {
        scrollableParent.scrollTop = 0;
        break;
      }
      scrollableParent = scrollableParent.parentElement;
    }
    const modalContent = contentEl.closest(".modal-content");
    if (modalContent) {
      modalContent.scrollTop = 0;
    }
    const modalContainer = contentEl.closest(".modal-container");
    if (modalContainer) {
      modalContainer.scrollTop = 0;
    }
    contentEl.scrollTop = 0;
  }
  async renderCurrentStep() {
    const { contentEl } = this;
    this.scrollToTop();
    contentEl.empty();
    contentEl.addClass("vault-cms-wizard");
    this.scrollToTop();
    this.renderProgress(contentEl);
    const stepContent = contentEl.createDiv("wizard-content");
    await this.renderStepContent(stepContent);
    this.renderFooter(contentEl);
    requestAnimationFrame(() => {
      this.scrollToTop();
    });
  }
  renderProgress(container) {
    const state = this.stateManager.getState();
    const totalSteps = this.steps.length;
    const progress = container.createDiv("wizard-progress");
    const progressBar = progress.createDiv("progress-bar");
    const progressFill = progressBar.createDiv("progress-fill");
    setCssProps8(progressFill, { width: `${this.stateManager.getProgress(totalSteps)}%` });
    const progressText = progress.createDiv("progress-text");
    progressText.textContent = `Step ${state.currentStep + 1} of ${totalSteps}`;
  }
  async renderStepContent(container) {
    const state = this.stateManager.getState();
    const stepIndex = state.currentStep;
    if (stepIndex >= 0 && stepIndex < this.steps.length) {
      const StepClass = this.steps[stepIndex];
      const stepName = StepClass.name || "Unknown";
      console.debug(`SetupWizardModal: Displaying step ${stepIndex + 1}/${this.steps.length}: ${stepName}`);
      this.currentStepInstance = new StepClass(
        this.app,
        container,
        state,
        () => {
          void (async () => {
            if (this.currentStepInstance && this.currentStepInstance.validate()) {
              await this.saveCurrentStepToWizardState();
              this.stateManager.nextStep();
              await this.renderCurrentStep();
            }
          })();
        },
        () => {
          this.discardCurrentStepChanges();
          this.stateManager.previousStep();
          void this.renderCurrentStep();
        },
        () => this.close()
      );
      await this.currentStepInstance.display();
    }
  }
  renderFooter(container) {
    const footer = container.createDiv("wizard-footer");
    setCssProps8(footer, { display: "flex", justifyContent: "space-between", alignItems: "center" });
    if (this.stateManager.getState().currentStep === 0) {
      const startupSetting = footer.createDiv("wizard-startup-setting-footer");
      const label = startupSetting.createEl("label", { cls: "wizard-checkbox-label" });
      setCssProps8(label, { cursor: "default" });
      const checkbox = label.createEl("input", { type: "checkbox" });
      setCssProps8(checkbox, { cursor: "default" });
      checkbox.checked = !this.plugin.settings.runWizardOnStartup;
      label.createSpan({ text: " I've already set up my vault, don't show on startup" });
      checkbox.addEventListener("change", () => {
        this.plugin.settings.runWizardOnStartup = !checkbox.checked;
        void this.plugin.saveSettings();
      });
    } else {
      footer.createDiv();
    }
    const buttons = footer.createDiv("wizard-buttons");
    setCssProps8(buttons, { display: "flex", gap: "10px" });
    if (this.stateManager.canGoPrevious()) {
      const prevBtn = buttons.createEl("button", {
        text: "Previous",
        cls: "mod-button"
      });
      prevBtn.addEventListener("click", () => {
        this.discardCurrentStepChanges();
        this.stateManager.previousStep();
        void this.renderCurrentStep();
      });
    }
    if (this.stateManager.canGoNext(this.steps.length)) {
      if (this.stateManager.getState().currentStep !== 0) {
        const nextBtn = buttons.createEl("button", {
          text: "Next",
          cls: "mod-button mod-cta"
        });
        nextBtn.addEventListener("click", () => {
          void (async () => {
            if (this.currentStepInstance && this.currentStepInstance.validate()) {
              await this.saveCurrentStepToWizardState();
              this.lastSavedStepIndex = this.stateManager.getState().currentStep;
              this.stateManager.nextStep();
              await this.renderCurrentStep();
            }
          })();
        });
      }
    } else {
      if (this.currentStepInstance instanceof FinalizeStep) {
        const applyBtn = buttons.createEl("button", {
          text: "Apply",
          cls: "mod-button"
        });
        applyBtn.addEventListener("click", () => {
          void this.handleComplete(false);
        });
        const applyRestartBtn = buttons.createEl("button", {
          text: "Apply and restart",
          cls: "mod-button mod-cta"
        });
        applyRestartBtn.addEventListener("click", () => {
          void this.handleComplete(true);
        });
      } else {
        const completeBtn = buttons.createEl("button", {
          text: "Complete setup",
          cls: "mod-button mod-cta"
        });
        completeBtn.addEventListener("click", () => {
          void this.handleComplete(false);
        });
      }
    }
    if (this.stateManager.canGoNext(this.steps.length)) {
      if (this.stateManager.getState().currentStep !== 0) {
        const skipBtn = buttons.createEl("button", {
          text: "Skip",
          cls: "mod-button"
        });
        skipBtn.addClass("wizard-skip-button");
        setCssProps8(skipBtn, { opacity: "0.6" });
        skipBtn.addEventListener("click", () => {
          this.stateManager.nextStep();
          void this.renderCurrentStep();
        });
      }
    }
  }
  async handleComplete(shouldRestart) {
    if (this.isCompleting) return;
    this.isCompleting = true;
    try {
      if (this.currentStepInstance && this.currentStepInstance.validate()) {
        if (this.currentStepInstance instanceof FinalizeStep) {
          await this.currentStepInstance.applyConfiguration(shouldRestart);
        } else {
          await this.saveCurrentStepToWizardState();
        }
        this.plugin.settings.wizardCompleted = true;
        this.plugin.settings.runWizardOnStartup = false;
        await this.plugin.saveSettings();
        await this.plugin.loadSettings();
        this.close();
        if (shouldRestart) {
          setTimeout(() => {
            this.app.commands.executeCommandById("app:reload");
          }, 1e3);
        }
      }
    } catch (error) {
      console.error("Error completing wizard:", error);
      new import_obsidian24.Notice("Failed to complete setup. Please check the console for details.");
    } finally {
      this.isCompleting = false;
    }
  }
  async saveCurrentStepToWizardState() {
    try {
      this.stateManager.buildFinalSettings();
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
    } catch (error) {
      console.error("Error saving current step to data.json:", error);
    }
  }
  discardCurrentStepChanges() {
    void this.stateManager.refreshState();
  }
  async saveWizardStateToDataJson(showNotification = true) {
    try {
      this.stateManager.buildFinalSettings();
      const hasChanges = this.hasSettingsChanged();
      if (!hasChanges) {
        return;
      }
      await this.plugin.saveSettings();
      await this.plugin.loadSettings();
      if (showNotification) {
        new import_obsidian24.Notice("Configuration saved");
      }
    } catch (error) {
      console.error("Error saving wizard state to data.json:", error);
      if (showNotification) {
        new import_obsidian24.Notice(`Failed to save configuration: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
  createSettingsSnapshot() {
    const state = this.stateManager.getState();
    return JSON.parse(JSON.stringify({
      projectDetection: state.projectDetection,
      contentTypes: state.contentTypes,
      frontmatterProperties: state.frontmatterProperties,
      defaultContentTypeId: state.defaultContentTypeId,
      preset: state.preset,
      enableWYSIWYG: state.enableWYSIWYG,
      enabledPlugins: state.enabledPlugins,
      disabledPlugins: state.disabledPlugins,
      theme: state.theme,
      basesCMSConfig: state.basesCMSConfig,
      astroComposerConfig: state.astroComposerConfig,
      seoConfig: state.seoConfig,
      commanderConfig: state.commanderConfig,
      propertyOverFileName: state.propertyOverFileName,
      imageInserter: state.imageInserter,
      imageManager: state.imageManager,
      homeBase: state.homeBase
    }));
  }
  hasSettingsChanged() {
    if (!this.initialSettingsSnapshot) {
      return false;
    }
    const currentSnapshot = this.createSettingsSnapshot();
    return JSON.stringify(currentSnapshot.projectDetection) !== JSON.stringify(this.initialSettingsSnapshot.projectDetection) || JSON.stringify(currentSnapshot.contentTypes) !== JSON.stringify(this.initialSettingsSnapshot.contentTypes) || JSON.stringify(currentSnapshot.frontmatterProperties) !== JSON.stringify(this.initialSettingsSnapshot.frontmatterProperties) || currentSnapshot.defaultContentTypeId !== this.initialSettingsSnapshot.defaultContentTypeId || currentSnapshot.preset !== this.initialSettingsSnapshot.preset || currentSnapshot.enableWYSIWYG !== this.initialSettingsSnapshot.enableWYSIWYG || JSON.stringify(currentSnapshot.enabledPlugins) !== JSON.stringify(this.initialSettingsSnapshot.enabledPlugins) || JSON.stringify(currentSnapshot.disabledPlugins) !== JSON.stringify(this.initialSettingsSnapshot.disabledPlugins) || currentSnapshot.theme !== this.initialSettingsSnapshot.theme || JSON.stringify(currentSnapshot.basesCMSConfig) !== JSON.stringify(this.initialSettingsSnapshot.basesCMSConfig) || JSON.stringify(currentSnapshot.astroComposerConfig) !== JSON.stringify(this.initialSettingsSnapshot.astroComposerConfig) || JSON.stringify(currentSnapshot.seoConfig) !== JSON.stringify(this.initialSettingsSnapshot.seoConfig) || JSON.stringify(currentSnapshot.commanderConfig) !== JSON.stringify(this.initialSettingsSnapshot.commanderConfig) || JSON.stringify(currentSnapshot.propertyOverFileName) !== JSON.stringify(this.initialSettingsSnapshot.propertyOverFileName) || JSON.stringify(currentSnapshot.imageInserter) !== JSON.stringify(this.initialSettingsSnapshot.imageInserter) || JSON.stringify(currentSnapshot.imageManager) !== JSON.stringify(this.initialSettingsSnapshot.imageManager) || JSON.stringify(currentSnapshot.homeBase) !== JSON.stringify(this.initialSettingsSnapshot.homeBase);
  }
  getState() {
    return this.stateManager.getState();
  }
  // Callback to save state to plugin settings (kept for backward compatibility)
  setSaveCallback(callback) {
    console.warn("setSaveCallback is deprecated - state is now managed automatically");
  }
};

// src/utils/settings-compat.ts
var import_obsidian25 = require("obsidian");
function createSettingsGroup(containerEl, heading, manifestId) {
  if ((0, import_obsidian25.requireApiVersion)("1.11.0")) {
    const obsidian = require("obsidian");
    const SettingGroup = obsidian.SettingGroup;
    const group = heading ? new SettingGroup(containerEl).setHeading(heading) : new SettingGroup(containerEl);
    return {
      addSetting(cb) {
        group.addSetting(cb);
      }
    };
  } else {
    if (manifestId) {
      containerEl.addClass(`${manifestId}-settings-compat`);
    }
    if (heading) {
      const headingEl = containerEl.createDiv("setting-group-heading");
      headingEl.createEl("h3", { text: heading });
    }
    return {
      addSetting(cb) {
        const setting = new import_obsidian25.Setting(containerEl);
        cb(setting);
      }
    };
  }
}

// src/utils/PresetManager.ts
var import_obsidian27 = require("obsidian");

// src/ui/ApplyPresetModal.ts
var import_obsidian26 = require("obsidian");
var ApplyPresetModal = class extends import_obsidian26.Modal {
  constructor(app, backupPath, onConfirm) {
    super(app);
    this.backupPath = backupPath;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Preset applied successfully" });
    contentEl.createEl("p", { text: "The preset has been applied successfully. You need to reload Obsidian for all changes to take effect." });
    contentEl.createEl("p", { text: `A backup of your original configuration folder was created at: ${this.backupPath}` });
    new import_obsidian26.Setting(contentEl).setName("Delete backup and reload").setDesc('Remove the backup folder and reload Obsidian. This is the recommended "clean" option.').addButton((button) => button.setButtonText("Delete and reload").setCta().onClick(() => {
      this.close();
      this.onConfirm(true);
    }));
    new import_obsidian26.Setting(contentEl).setName("Keep backup and reload").setDesc("Keep the backup folder for safety and reload Obsidian.").addButton((button) => button.setButtonText("Keep and reload").onClick(() => {
      this.close();
      this.onConfirm(false);
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/PresetManager.ts
var PresetManager = class {
  constructor(app) {
    this.app = app;
  }
  async applyPreset(repo, presetName) {
    if (!repo || !presetName) {
      new import_obsidian27.Notice("Please configure both repository and preset name in settings.");
      return;
    }
    try {
      new import_obsidian27.Notice(`Fetching preset "${presetName}" from ${repo}...`);
      const files = await this.fetchPresetFilesRecursive(repo, presetName);
      if (files.length === 0) {
        new import_obsidian27.Notice(`No files found for preset "${presetName}" in repo ${repo}.`);
        return;
      }
      new import_obsidian27.Notice("Backing up configuration folder...");
      const backupPath = await this.backupObsidianFolder();
      new import_obsidian27.Notice(`Downloading and applying ${files.length} files...`);
      let successCount = 0;
      for (const file of files) {
        if (file.download_url) {
          const relativePath = file.path.substring(presetName.length + 1);
          try {
            await this.downloadAndWriteFile(file.download_url, relativePath);
            successCount++;
          } catch (e) {
            console.error(`Failed to download ${relativePath}:`, e);
          }
        }
      }
      new import_obsidian27.Notice(`Applied ${successCount} files.`);
      new ApplyPresetModal(this.app, backupPath, (deleteBackup) => {
        void (async () => {
          if (deleteBackup) {
            try {
              await this.app.vault.adapter.rmdir(backupPath, true);
              new import_obsidian27.Notice("Backup deleted.");
            } catch (e) {
              console.error("Failed to delete backup:", e);
              new import_obsidian27.Notice("Failed to delete backup folder. You may need to remove it manually.");
            }
          }
          const appWithCommands = this.app;
          if (appWithCommands.commands && typeof appWithCommands.commands.executeCommandById === "function") {
            appWithCommands.commands.executeCommandById("app:reload");
          }
        })();
      }).open();
    } catch (error) {
      console.error("Failed to apply preset:", error);
      const message = error instanceof Error ? error.message : String(error);
      new import_obsidian27.Notice(`Failed to apply preset: ${message}`);
    }
  }
  async fetchPresetFilesRecursive(repo, path7) {
    const url = `https://api.github.com/repos/${repo}/contents/${path7}`;
    try {
      const response = await (0, import_obsidian27.requestUrl)({ url });
      if (response.status !== 200) {
        throw new Error(`GitHub API returned status ${response.status}`);
      }
      const items = response.json;
      let allFiles = [];
      for (const item of items) {
        if (item.type === "dir") {
          const subFiles = await this.fetchPresetFilesRecursive(repo, item.path);
          allFiles = allFiles.concat(subFiles);
        } else if (item.type === "file") {
          allFiles.push(item);
        }
      }
      return allFiles;
    } catch (e) {
      if (e && typeof e === "object" && "status" in e && e.status === 404) {
        throw new Error(`Preset folder "${path7}" not found in repository "${repo}".`);
      }
      throw e;
    }
  }
  async backupObsidianFolder() {
    const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").split("T")[0] + "-" + Math.floor(Date.now() / 1e3);
    const configDir = this.app.vault.configDir;
    const backupPath = `${configDir}_backup_${timestamp2}`;
    const adapter = this.app.vault.adapter;
    await adapter.mkdir(backupPath);
    await this.copyRecursive(configDir, `${backupPath}/${configDir}`);
    return backupPath;
  }
  async copyRecursive(source, destination) {
    const adapter = this.app.vault.adapter;
    if (!await adapter.exists(source)) {
      return;
    }
    const stats = await adapter.list(source);
    if (!await adapter.exists(destination)) {
      await adapter.mkdir(destination);
    }
    for (const file of stats.files) {
      const fileName = file.split("/").pop();
      if (fileName) {
        const destFile = destination + "/" + fileName;
        try {
          await adapter.copy(file, destFile);
        } catch (e) {
          console.error(`Failed to copy file ${file} to ${destFile}:`, e);
        }
      }
    }
    for (const folder of stats.folders) {
      const folderName = folder.split("/").pop();
      if (folderName) {
        const destFolder = destination + "/" + folderName;
        await this.copyRecursive(folder, destFolder);
      }
    }
  }
  async downloadAndWriteFile(url, path7) {
    const adapter = this.app.vault.adapter;
    const response = await (0, import_obsidian27.requestUrl)({ url });
    if (response.status !== 200) {
      throw new Error(`Failed to download ${path7} from ${url}`);
    }
    const parts = path7.split("/");
    if (parts.length > 1) {
      for (let i = 1; i < parts.length; i++) {
        const dir = parts.slice(0, i).join("/");
        if (!await adapter.exists(dir)) {
          await adapter.mkdir(dir);
        }
      }
    }
    await adapter.writeBinary(path7, response.arrayBuffer);
  }
};

// src/ui/SettingsTab.ts
var SettingsTab = class extends import_obsidian28.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.contentEl = containerEl.createDiv("vault-cms-settings-container");
    void this.render();
  }
  async render() {
    if (!this.contentEl) return;
    this.contentEl.empty();
    const generalGroup = createSettingsGroup(this.contentEl, void 0, "vault-cms");
    generalGroup.addSetting((setting) => {
      setting.setName("Open setup wizard").setDesc("Launch the setup wizard").addButton((button) => {
        button.setButtonText("Open wizard").setCta().onClick(() => {
          new SetupWizardModal(this.app, this.plugin.settings, this.plugin).open();
        });
      });
    });
    generalGroup.addSetting((setting) => {
      setting.setName("Run wizard on startup").setDesc("Automatically open the wizard when the plugin loads").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.runWizardOnStartup).onChange(async (value) => {
          this.plugin.settings.runWizardOnStartup = value;
          await this.plugin.saveSettings();
        });
      });
    });
    const presetGroup = createSettingsGroup(this.contentEl, "Preset configuration", "vault-cms-presets");
    presetGroup.addSetting((setting) => {
      setting.setName("Preset folder name").setDesc("Folder name in the repository").addText((text) => {
        text.setPlaceholder("Example: starlight").setValue(this.plugin.settings.presetName).onChange(async (value) => {
          this.plugin.settings.presetName = value;
          await this.plugin.saveSettings();
        });
      });
    });
    presetGroup.addSetting((setting) => {
      setting.setName("Presets repository").setDesc("GitHub repository containing the presets").addText((text) => {
        text.setPlaceholder("Example: owner/repo").setValue(this.plugin.settings.presetsRepo).onChange(async (value) => {
          this.plugin.settings.presetsRepo = value;
          await this.plugin.saveSettings();
        });
      });
    });
    presetGroup.addSetting((setting) => {
      setting.setName("Download and apply preset").setDesc("Download the specified preset and apply it to your vault").addButton((button) => {
        button.setButtonText("Apply preset").onClick(async () => {
          const manager = new PresetManager(this.app);
          await manager.applyPreset(this.plugin.settings.presetsRepo, this.plugin.settings.presetName);
        });
      });
    });
    const optimizationGroup = createSettingsGroup(this.contentEl, "Project optimization (optional)", "vault-cms-optimization");
    this.contentEl.createEl("p", {
      text: "Optimize your project by ignoring Obsidian-specific files."
    });
    const wizardState = {
      ...this.plugin.settings,
      currentStep: 0,
      projectDetection: {
        projectRoot: this.plugin.settings.projectRoot,
        configFilePath: this.plugin.settings.configFilePath,
        vaultLocation: "content"
      }
    };
    this.optimizer = new ProjectOptimizer(this.app, wizardState);
    const status = await this.optimizer.getStatus();
    optimizationGroup.addSetting((setting) => {
      this.gitSetting = setting;
      this.updateGitSetting(status.gitIgnoreStatus);
    });
    optimizationGroup.addSetting((setting) => {
      this.viteSetting = setting;
      this.updateViteSetting(status.viteIgnoreStatus);
    });
  }
  updateGitSetting(status) {
    this.gitSetting.setName("Ignore in Git").setDesc("Add workspace files to Git ignore").clear();
    this.gitSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureGitIgnore();
          this.plugin.settings.ignoreConfig.gitIgnoreConfigured = true;
          await this.plugin.saveSettings();
          new import_obsidian28.Notice("Git ignore updated");
          const newStatus = await this.optimizer.getStatus();
          this.updateGitSetting(newStatus.gitIgnoreStatus);
        } catch (error) {
          new import_obsidian28.Notice(`Failed to update Git ignore: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.gitSetting.controlEl, status);
  }
  updateViteSetting(status) {
    this.viteSetting.setName("Ignore in Vite").setDesc("Configure Vite to ignore internal folders").clear();
    this.viteSetting.addButton((button) => {
      button.setButtonText(status === "configured" ? "Re-configure" : "Configure").onClick(async () => {
        try {
          await this.optimizer.configureViteIgnore();
          this.plugin.settings.ignoreConfig.viteIgnoreConfigured = true;
          await this.plugin.saveSettings();
          new import_obsidian28.Notice("Vite optimization applied");
          const newStatus = await this.optimizer.getStatus();
          this.updateViteSetting(newStatus.viteIgnoreStatus);
        } catch (error) {
          new import_obsidian28.Notice(`Failed to update Vite config: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    });
    this.optimizer.renderStatus(this.viteSetting.controlEl, status);
  }
};

// src/commands/index.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "open-wizard",
    name: "Open setup wizard",
    callback: () => {
      const wizard = new SetupWizardModal(plugin.app, plugin.settings, plugin);
      wizard.open();
    }
  });
  plugin.addCommand({
    id: "download-apply-preset",
    name: "Download and apply preset",
    callback: async () => {
      const manager = new PresetManager(plugin.app);
      await manager.applyPreset(plugin.settings.presetsRepo, plugin.settings.presetName);
    }
  });
}

// src/main.ts
var VaultCMSPlugin = class extends import_obsidian29.Plugin {
  async onload() {
    await this.loadSettings();
    registerCommands(this);
    this.addSettingTab(new SettingsTab(this.app, this));
    if (this.settings.runWizardOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        this.startupTimeoutId = window.setTimeout(() => {
          void (async () => {
            await this.loadSettings();
            if (this.settings.runWizardOnStartup) {
              const wizard = new SetupWizardModal(this.app, void 0, this);
              wizard.open();
            }
          })();
        }, 2e3);
      });
    }
  }
  onunload() {
    if (this.startupTimeoutId) {
      window.clearTimeout(this.startupTimeoutId);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL3NldHRpbmdzLnRzIiwgInNyYy91aS9TZXR0aW5nc1RhYi50cyIsICJzcmMvdWkvU2V0dXBXaXphcmRNb2RhbC50cyIsICJzcmMvdXRpbHMvSW1hZ2VNYW5hZ2VyQ29uZmlnLnRzIiwgInNyYy91dGlscy9Ib21lQmFzZUNvbmZpZy50cyIsICJzcmMvdXRpbHMvRXhwbG9yZXJGb2N1c0NvbmZpZy50cyIsICJzcmMvdXRpbHMvQ29tbWFuZGVyQ29uZmlnLnRzIiwgInNyYy91aS93aXphcmQvV2l6YXJkU3RhdGVNYW5hZ2VyLnRzIiwgInNyYy91aS93aXphcmQvQmFzZVdpemFyZFN0ZXAudHMiLCAic3JjL3VpL3dpemFyZC9XZWxjb21lU3RlcC50cyIsICJzcmMvdWkvd2l6YXJkL1Byb2plY3REZXRlY3Rpb25TdGVwLnRzIiwgInNyYy91dGlscy9Qcm9qZWN0RGV0ZWN0b3IudHMiLCAic3JjL3V0aWxzL01keERldGVjdG9yLnRzIiwgInNyYy91dGlscy9Db250ZW50VHlwZURldGVjdG9yLnRzIiwgInNyYy91aS93aXphcmQvQ29udGVudFR5cGVTdGVwLnRzIiwgInNyYy91dGlscy9Bc3Ryb0NvbXBvc2VyQ29uZmlnLnRzIiwgInNyYy91dGlscy9QYXRoUmVzb2x2ZXIudHMiLCAic3JjL3VpL3dpemFyZC9EZWZhdWx0Q29udGVudFR5cGVTdGVwLnRzIiwgInNyYy91aS93aXphcmQvRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzU3RlcC50cyIsICJzcmMvdXRpbHMvRnJvbnRtYXR0ZXJBbmFseXplci50cyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvaWRlbnRpdHkuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3Zpc2l0LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvZGlyZWN0aXZlcy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2FuY2hvcnMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hcHBseVJldml2ZXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL3RvSlMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL05vZGUuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL0FsaWFzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9TY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9jcmVhdGVOb2RlLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9Db2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5Q29tbWVudC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L2ZvbGRGbG93TGluZXMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnkuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlQYWlyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9sb2cuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9tZXJnZS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvYWRkUGFpclRvSlNNYXAuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1BhaXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9ZQU1MTWFwLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL21hcC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvWUFNTFNlcS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9zZXEuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vc3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL251bGwuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2Jvb2wuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2Zsb2F0LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29yZS9pbnQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL3NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2pzb24vc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvYmluYXJ5LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvcGFpcnMuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9vbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvYm9vbC5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2Zsb2F0LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvaW50LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvc2V0LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvdGltZXN0YW1wLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvdGFncy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL1NjaGVtYS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvRG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2Vycm9ycy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLXByb3BzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtbWFwLWluY2x1ZGVzLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2VxLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZW5kLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1jb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2UtY29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2Utc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtZW1wdHktc2NhbGFyLXBvc2l0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2Utbm9kZS5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9jb21wb3NlLWRvYy5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvY29tcG9zZS9jb21wb3Nlci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvY3N0LXZpc2l0LmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9jc3QuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2xleGVyLmpzIiwgIm5vZGVfbW9kdWxlcy8ucG5wbS95YW1sQDIuOC4yL25vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9saW5lLWNvdW50ZXIuanMiLCAibm9kZV9tb2R1bGVzLy5wbnBtL3lhbWxAMi44LjIvbm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL3BhcnNlci5qcyIsICJub2RlX21vZHVsZXMvLnBucG0veWFtbEAyLjguMi9ub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcHVibGljLWFwaS5qcyIsICJzcmMvdWkvd2l6YXJkL1dZU0lXWUdQcmVmZXJlbmNlU3RlcC50cyIsICJzcmMvdWkvd2l6YXJkL0Jhc2VzQ01TQ29uZmlnU3RlcC50cyIsICJzcmMvdWkvd2l6YXJkL0FzdHJvQ29tcG9zZXJTdGVwLnRzIiwgInNyYy91aS93aXphcmQvU0VPQ29uZmlnU3RlcC50cyIsICJzcmMvdWkvd2l6YXJkL09wdGlvbmFsUGx1Z2luc1N0ZXAudHMiLCAic3JjL3V0aWxzL1BsdWdpbk1hbmFnZXIudHMiLCAic3JjL3VpL3dpemFyZC9JZ25vcmVTdGVwLnRzIiwgInNyYy91dGlscy9Qcm9qZWN0T3B0aW1pemVyLnRzIiwgInNyYy91aS93aXphcmQvRmluYWxpemVTdGVwLnRzIiwgInNyYy91dGlscy9CYXNlc0NNU0NvbmZpZy50cyIsICJzcmMvdXRpbHMvU0VPQ29uZmlnLnRzIiwgInNyYy91dGlscy9Qcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZy50cyIsICJzcmMvdXRpbHMvVUlUd2Vha2VyQ29uZmlnLnRzIiwgInNyYy91dGlscy9JbWFnZUluc2VydGVyQ29uZmlnLnRzIiwgInNyYy91dGlscy9TaW1wbGVCYW5uZXJDb25maWcudHMiLCAic3JjL3V0aWxzL3NldHRpbmdzLWNvbXBhdC50cyIsICJzcmMvdXRpbHMvUHJlc2V0TWFuYWdlci50cyIsICJzcmMvdWkvQXBwbHlQcmVzZXRNb2RhbC50cyIsICJzcmMvY29tbWFuZHMvaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgVmF1bHRDTVNTZXR0aW5ncywgREVGQVVMVF9TRVRUSU5HUyB9IGZyb20gJy4vc2V0dGluZ3MnO1xyXG5pbXBvcnQgeyBTZXR0aW5nc1RhYiB9IGZyb20gJy4vdWkvU2V0dGluZ3NUYWInO1xyXG5pbXBvcnQgeyBTZXR1cFdpemFyZE1vZGFsIH0gZnJvbSAnLi91aS9TZXR1cFdpemFyZE1vZGFsJztcclxuaW1wb3J0IHsgcmVnaXN0ZXJDb21tYW5kcyB9IGZyb20gJy4vY29tbWFuZHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmF1bHRDTVNQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xyXG5cdHNldHRpbmdzOiBWYXVsdENNU1NldHRpbmdzO1xyXG5cdHByaXZhdGUgc3RhcnR1cFRpbWVvdXRJZD86IG51bWJlcjtcclxuXHJcblx0YXN5bmMgb25sb2FkKCkge1xyXG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcclxuXHJcblx0XHQvLyBSZWdpc3RlciBjb21tYW5kc1xyXG5cdFx0cmVnaXN0ZXJDb21tYW5kcyh0aGlzKTtcclxuXHJcblx0XHQvLyBBZGQgc2V0dGluZ3MgdGFiXHJcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdzVGFiKHRoaXMuYXBwLCB0aGlzKSk7XHJcblxyXG5cdFx0Ly8gT3BlbiB3aXphcmQgb24gc3RhcnR1cCBpZiBjb25maWd1cmVkXHJcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5ydW5XaXphcmRPblN0YXJ0dXApIHtcclxuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xyXG5cdFx0XHRcdC8vIERlbGF5IHRoZSB3aXphcmQgdG8gbGV0IE9ic2lkaWFuIGZ1bGx5IGxvYWQgKGxpa2UgYXN0cm8tbW9kdWxhci1zZXR0aW5ncylcclxuXHRcdFx0XHR0aGlzLnN0YXJ0dXBUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHR2b2lkIChhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdC8vIFJlbG9hZCBzZXR0aW5ncyB0byBjaGVjayBpZiB1c2VyIGRpc2FibGVkIHRoZSBzZXR0aW5nXHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHdpemFyZCA9IG5ldyBTZXR1cFdpemFyZE1vZGFsKHRoaXMuYXBwLCB1bmRlZmluZWQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0XHRcdHdpemFyZC5vcGVuKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSwgMjAwMCk7IC8vIDItc2Vjb25kIGRlbGF5XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0b251bmxvYWQoKSB7XHJcblx0XHRpZiAodGhpcy5zdGFydHVwVGltZW91dElkKSB7XHJcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zdGFydHVwVGltZW91dElkKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcclxuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkgYXMgUGFydGlhbDxWYXVsdENNU1NldHRpbmdzPik7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlU2V0dGluZ3MoKSB7XHJcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IENvbnRlbnRUeXBlQ29uZmlnLCBGcm9udG1hdHRlclByb3BlcnRpZXMsIEJhc2VzQ01TQ29uZmlnLCBBc3Ryb0NvbXBvc2VyQ29uZmlnLCBTRU9Db25maWcsIENvbW1hbmRlckNvbmZpZywgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWcsIEltYWdlSW5zZXJ0ZXJDb25maWcsIEltYWdlTWFuYWdlckNvbmZpZywgSG9tZUJhc2VDb25maWcsIEV4cGxvcmVyRm9jdXNDb25maWcsIElnbm9yZUNvbmZpZyB9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYXVsdENNU1NldHRpbmdzIHtcclxuXHRwcm9qZWN0Um9vdDogc3RyaW5nO1xyXG5cdGNvbmZpZ0ZpbGVQYXRoOiBzdHJpbmc7XHJcblx0Y29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdO1xyXG5cdGZyb250bWF0dGVyUHJvcGVydGllczogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIH07XHJcblx0ZGVmYXVsdENvbnRlbnRUeXBlSWQ/OiBzdHJpbmc7XHJcblx0YXR0YWNobWVudEhhbmRsaW5nTW9kZTogJ3NwZWNpZmllZC1mb2xkZXInIHwgJ3NhbWUtZm9sZGVyJyB8ICdzdWJmb2xkZXInO1xyXG5cdGF0dGFjaG1lbnRGb2xkZXJOYW1lPzogc3RyaW5nO1xyXG5cdHByZXNldDogJ3ZhbmlsbGEnIHwgJ29waW5pb25hdGVkJyB8ICdjdXN0b20nO1xyXG5cdHByZXNldE5hbWU6IHN0cmluZztcclxuXHRwcmVzZXRzUmVwbzogc3RyaW5nO1xyXG5cdGVuYWJsZVdZU0lXWUc6IGJvb2xlYW47XHJcblx0ZW5hYmxlTWR4U3VwcG9ydD86IGJvb2xlYW47XHJcblx0ZW5hYmxlZFBsdWdpbnM6IHN0cmluZ1tdO1xyXG5cdGRpc2FibGVkUGx1Z2luczogc3RyaW5nW107XHJcblx0dGhlbWU6IHN0cmluZztcclxuXHRiYXNlc0NNU0NvbmZpZzogQmFzZXNDTVNDb25maWc7XHJcblx0YXN0cm9Db21wb3NlckNvbmZpZzogQXN0cm9Db21wb3NlckNvbmZpZztcclxuXHRzZW9Db25maWc6IFNFT0NvbmZpZztcclxuXHRjb21tYW5kZXJDb25maWc6IENvbW1hbmRlckNvbmZpZztcclxuXHRwcm9wZXJ0eU92ZXJGaWxlTmFtZTogUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc7XHJcblx0aW1hZ2VJbnNlcnRlcjogSW1hZ2VJbnNlcnRlckNvbmZpZztcclxuXHRpbWFnZU1hbmFnZXI6IEltYWdlTWFuYWdlckNvbmZpZztcclxuXHRob21lQmFzZTogSG9tZUJhc2VDb25maWc7XHJcblx0ZXhwbG9yZXJGb2N1czogRXhwbG9yZXJGb2N1c0NvbmZpZztcclxuXHRpZ25vcmVDb25maWc6IElnbm9yZUNvbmZpZztcclxuXHRydW5XaXphcmRPblN0YXJ0dXA6IGJvb2xlYW47XHJcblx0d2l6YXJkQ29tcGxldGVkOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogVmF1bHRDTVNTZXR0aW5ncyA9IHtcclxuXHRwcm9qZWN0Um9vdDogJycsXHJcblx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdGNvbnRlbnRUeXBlczogW10sXHJcblx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiB7fSxcclxuXHRhdHRhY2htZW50SGFuZGxpbmdNb2RlOiAnc3ViZm9sZGVyJyxcclxuXHRhdHRhY2htZW50Rm9sZGVyTmFtZTogdW5kZWZpbmVkLFxyXG5cdHByZXNldDogJ3ZhbmlsbGEnLFxyXG5cdHByZXNldE5hbWU6ICcnLFxyXG5cdHByZXNldHNSZXBvOiAnZGF2aWR2a2ltYmFsbC92YXVsdC1jbXMtcHJlc2V0cycsXHJcblx0ZW5hYmxlV1lTSVdZRzogZmFsc2UsXHJcblx0ZW5hYmxlZFBsdWdpbnM6IFtdLFxyXG5cdGRpc2FibGVkUGx1Z2luczogW10sXHJcblx0dGhlbWU6ICcnLFxyXG5cdGJhc2VzQ01TQ29uZmlnOiB7XHJcblx0XHR2aWV3czogW11cclxuXHR9LFxyXG5cdGFzdHJvQ29tcG9zZXJDb25maWc6IHtcclxuXHRcdGN1c3RvbUNvbnRlbnRUeXBlczogW10sXHJcblx0XHRkZWZhdWx0VGVtcGxhdGU6ICcnLFxyXG5cdFx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdFx0dGVybWluYWxQcm9qZWN0Um9vdFBhdGg6ICcnXHJcblx0fSxcclxuXHRzZW9Db25maWc6IHtcclxuXHRcdHRpdGxlUHJvcGVydHk6ICd0aXRsZScsXHJcblx0XHRkZXNjcmlwdGlvblByb3BlcnR5OiB1bmRlZmluZWQsXHJcblx0XHRzY2FuRGlyZWN0b3JpZXM6ICcnLFxyXG5cdFx0dXNlRmlsZW5hbWVBc1RpdGxlOiBmYWxzZSxcclxuXHRcdHVzZUZpbGVuYW1lQXNTbHVnOiB0cnVlLFxyXG5cdFx0ZW5hYmxlTURYU3VwcG9ydDogZmFsc2VcclxuXHR9LFxyXG5cdGNvbW1hbmRlckNvbmZpZzoge1xyXG5cdFx0cGFnZUhlYWRlckNvbW1hbmRzOiBbXVxyXG5cdH0sXHJcblx0cHJvcGVydHlPdmVyRmlsZU5hbWU6IHtcclxuXHRcdHByb3BlcnR5S2V5OiAndGl0bGUnXHJcblx0fSxcclxuXHRpbWFnZUluc2VydGVyOiB7XHJcblx0XHR2YWx1ZUZvcm1hdDogJ1tbYXR0YWNobWVudHMve2ltYWdlLXVybH1dXScsXHJcblx0XHRpbnNlcnRGb3JtYXQ6ICdbW2F0dGFjaG1lbnRzL3tpbWFnZS11cmx9XV0nXHJcblx0fSxcclxuXHRpbWFnZU1hbmFnZXI6IHt9LFxyXG5cdGhvbWVCYXNlOiB7fSxcclxuXHRleHBsb3JlckZvY3VzOiB7fSxcclxuXHRpZ25vcmVDb25maWc6IHtcclxuXHRcdGdpdElnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlLFxyXG5cdFx0dml0ZUlnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlXHJcblx0fSxcclxuXHRydW5XaXphcmRPblN0YXJ0dXA6IHRydWUsXHJcblx0d2l6YXJkQ29tcGxldGVkOiBmYWxzZVxyXG59O1xyXG5cclxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgTm90aWNlLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgVmF1bHRDTVNQbHVnaW4gZnJvbSAnLi4vbWFpbic7XHJcbmltcG9ydCB7IFNldHVwV2l6YXJkTW9kYWwgfSBmcm9tICcuL1NldHVwV2l6YXJkTW9kYWwnO1xyXG5pbXBvcnQgeyBjcmVhdGVTZXR0aW5nc0dyb3VwIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MtY29tcGF0JztcclxuaW1wb3J0IHsgUHJlc2V0TWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL1ByZXNldE1hbmFnZXInO1xyXG5pbXBvcnQgeyBQcm9qZWN0T3B0aW1pemVyLCBPcHRpbWl6YXRpb25TdGF0dXMgfSBmcm9tICcuLi91dGlscy9Qcm9qZWN0T3B0aW1pemVyJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgU2V0dGluZ3NUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcclxuXHRwbHVnaW46IFZhdWx0Q01TUGx1Z2luO1xyXG5cdHByaXZhdGUgY29udGVudEVsOiBIVE1MRWxlbWVudDtcclxuXHRwcml2YXRlIGdpdFNldHRpbmc6IFNldHRpbmc7XHJcblx0cHJpdmF0ZSB2aXRlU2V0dGluZzogU2V0dGluZztcclxuXHRwcml2YXRlIG9wdGltaXplcjogUHJvamVjdE9wdGltaXplcjtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogVmF1bHRDTVNQbHVnaW4pIHtcclxuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcclxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xyXG5cdH1cclxuXHJcblx0ZGlzcGxheSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cdFx0dGhpcy5jb250ZW50RWwgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ3ZhdWx0LWNtcy1zZXR0aW5ncy1jb250YWluZXInKTtcclxuXHRcdHZvaWQgdGhpcy5yZW5kZXIoKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgcmVuZGVyKCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0aWYgKCF0aGlzLmNvbnRlbnRFbCkgcmV0dXJuO1xyXG5cdFx0XHJcblx0XHR0aGlzLmNvbnRlbnRFbC5lbXB0eSgpO1xyXG5cclxuXHRcdC8vIEZpcnN0IGdyb3VwIChubyBoZWFkaW5nKSAtIGZvbGxvd2luZyBVSSBUd2Vha2VyIHBhdHRlcm5cclxuXHRcdGNvbnN0IGdlbmVyYWxHcm91cCA9IGNyZWF0ZVNldHRpbmdzR3JvdXAodGhpcy5jb250ZW50RWwsIHVuZGVmaW5lZCwgJ3ZhdWx0LWNtcycpO1xyXG5cclxuXHRcdGdlbmVyYWxHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XHJcblx0XHRcdHNldHRpbmcuc2V0TmFtZSgnT3BlbiBzZXR1cCB3aXphcmQnKVxyXG5cdFx0XHRcdC5zZXREZXNjKCdMYXVuY2ggdGhlIHNldHVwIHdpemFyZCcpXHJcblx0XHRcdFx0LmFkZEJ1dHRvbihidXR0b24gPT4ge1xyXG5cdFx0XHRcdFx0YnV0dG9uXHJcblx0XHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdPcGVuIHdpemFyZCcpXHJcblx0XHRcdFx0XHRcdC5zZXRDdGEoKVxyXG5cdFx0XHRcdFx0XHQub25DbGljaygoKSA9PiB7XHJcblx0XHRcdFx0XHRcdFx0bmV3IFNldHVwV2l6YXJkTW9kYWwodGhpcy5hcHAsIHRoaXMucGx1Z2luLnNldHRpbmdzLCB0aGlzLnBsdWdpbikub3BlbigpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGdlbmVyYWxHcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XHJcblx0XHRcdHNldHRpbmcuc2V0TmFtZSgnUnVuIHdpemFyZCBvbiBzdGFydHVwJylcclxuXHRcdFx0XHQuc2V0RGVzYygnQXV0b21hdGljYWxseSBvcGVuIHRoZSB3aXphcmQgd2hlbiB0aGUgcGx1Z2luIGxvYWRzJylcclxuXHRcdFx0XHQuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB7XHJcblx0XHRcdFx0XHR0b2dnbGVcclxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cClcclxuXHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFByZXNldCBjb25maWd1cmF0aW9uIGdyb3VwXHJcblx0XHRjb25zdCBwcmVzZXRHcm91cCA9IGNyZWF0ZVNldHRpbmdzR3JvdXAodGhpcy5jb250ZW50RWwsICdQcmVzZXQgY29uZmlndXJhdGlvbicsICd2YXVsdC1jbXMtcHJlc2V0cycpO1xyXG5cclxuXHRcdHByZXNldEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcclxuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdQcmVzZXQgZm9sZGVyIG5hbWUnKVxyXG5cdFx0XHRcdC5zZXREZXNjKCdGb2xkZXIgbmFtZSBpbiB0aGUgcmVwb3NpdG9yeScpXHJcblx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XHJcblx0XHRcdFx0XHR0ZXh0XHJcblx0XHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRXhhbXBsZTogc3RhcmxpZ2h0JylcclxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnByZXNldE5hbWUpXHJcblx0XHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXROYW1lID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cHJlc2V0R3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xyXG5cdFx0XHRzZXR0aW5nLnNldE5hbWUoJ1ByZXNldHMgcmVwb3NpdG9yeScpXHJcblx0XHRcdFx0LnNldERlc2MoJ0dpdEh1YiByZXBvc2l0b3J5IGNvbnRhaW5pbmcgdGhlIHByZXNldHMnKVxyXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xyXG5cdFx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0V4YW1wbGU6IG93bmVyL3JlcG8nKVxyXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlc2V0c1JlcG8pXHJcblx0XHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXRzUmVwbyA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHByZXNldEdyb3VwLmFkZFNldHRpbmcoKHNldHRpbmcpID0+IHtcclxuXHRcdFx0c2V0dGluZy5zZXROYW1lKCdEb3dubG9hZCBhbmQgYXBwbHkgcHJlc2V0JylcclxuXHRcdFx0XHQuc2V0RGVzYygnRG93bmxvYWQgdGhlIHNwZWNpZmllZCBwcmVzZXQgYW5kIGFwcGx5IGl0IHRvIHlvdXIgdmF1bHQnKVxyXG5cdFx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IHtcclxuXHRcdFx0XHRcdGJ1dHRvblxyXG5cdFx0XHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnQXBwbHkgcHJlc2V0JylcclxuXHRcdFx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgUHJlc2V0TWFuYWdlcih0aGlzLmFwcCk7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgbWFuYWdlci5hcHBseVByZXNldCh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXRzUmVwbywgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlc2V0TmFtZSk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gUHJvamVjdCBvcHRpbWl6YXRpb24gZ3JvdXBcclxuXHRcdGNvbnN0IG9wdGltaXphdGlvbkdyb3VwID0gY3JlYXRlU2V0dGluZ3NHcm91cCh0aGlzLmNvbnRlbnRFbCwgJ1Byb2plY3Qgb3B0aW1pemF0aW9uIChvcHRpb25hbCknLCAndmF1bHQtY21zLW9wdGltaXphdGlvbicpO1xyXG5cdFx0XHJcblx0XHR0aGlzLmNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHtcclxuXHRcdFx0dGV4dDogJ09wdGltaXplIHlvdXIgcHJvamVjdCBieSBpZ25vcmluZyBPYnNpZGlhbi1zcGVjaWZpYyBmaWxlcy4nXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBDcmVhdGUgb3B0aW1pemVyIGluc3RhbmNlXHJcblx0XHRjb25zdCB3aXphcmRTdGF0ZTogV2l6YXJkU3RhdGUgPSB7XHJcblx0XHRcdC4uLnRoaXMucGx1Z2luLnNldHRpbmdzLFxyXG5cdFx0XHRjdXJyZW50U3RlcDogMCxcclxuXHRcdFx0cHJvamVjdERldGVjdGlvbjoge1xyXG5cdFx0XHRcdHByb2plY3RSb290OiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0Um9vdCxcclxuXHRcdFx0XHRjb25maWdGaWxlUGF0aDogdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29uZmlnRmlsZVBhdGgsXHJcblx0XHRcdFx0dmF1bHRMb2NhdGlvbjogJ2NvbnRlbnQnXHJcblx0XHRcdH1cclxuXHRcdH0gYXMgV2l6YXJkU3RhdGU7XHJcblxyXG5cdFx0dGhpcy5vcHRpbWl6ZXIgPSBuZXcgUHJvamVjdE9wdGltaXplcih0aGlzLmFwcCwgd2l6YXJkU3RhdGUpO1xyXG5cdFx0Y29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy5vcHRpbWl6ZXIuZ2V0U3RhdHVzKCk7XHJcblxyXG5cdFx0b3B0aW1pemF0aW9uR3JvdXAuYWRkU2V0dGluZygoc2V0dGluZykgPT4ge1xyXG5cdFx0XHR0aGlzLmdpdFNldHRpbmcgPSBzZXR0aW5nO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUdpdFNldHRpbmcoc3RhdHVzLmdpdElnbm9yZVN0YXR1cyk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRvcHRpbWl6YXRpb25Hcm91cC5hZGRTZXR0aW5nKChzZXR0aW5nKSA9PiB7XHJcblx0XHRcdHRoaXMudml0ZVNldHRpbmcgPSBzZXR0aW5nO1xyXG5cdFx0XHR0aGlzLnVwZGF0ZVZpdGVTZXR0aW5nKHN0YXR1cy52aXRlSWdub3JlU3RhdHVzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSB1cGRhdGVHaXRTZXR0aW5nKHN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJykge1xyXG5cdFx0dGhpcy5naXRTZXR0aW5nLnNldE5hbWUoJ0lnbm9yZSBpbiBHaXQnKVxyXG5cdFx0XHQuc2V0RGVzYygnQWRkIHdvcmtzcGFjZSBmaWxlcyB0byBHaXQgaWdub3JlJylcclxuXHRcdFx0LmNsZWFyKCk7IC8vIENsZWFyIGV4aXN0aW5nIGJ1dHRvbnMgYW5kIHN0YXR1c1xyXG5cdFx0XHJcblx0XHR0aGlzLmdpdFNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XHJcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcclxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLm9wdGltaXplci5jb25maWd1cmVHaXRJZ25vcmUoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MuaWdub3JlQ29uZmlnLmdpdElnbm9yZUNvbmZpZ3VyZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnR2l0IGlnbm9yZSB1cGRhdGVkJyk7XHJcblx0XHRcdFx0XHRcdGNvbnN0IG5ld1N0YXR1cyA9IGF3YWl0IHRoaXMub3B0aW1pemVyLmdldFN0YXR1cygpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZUdpdFNldHRpbmcobmV3U3RhdHVzLmdpdElnbm9yZVN0YXR1cyk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gdXBkYXRlIEdpdCBpZ25vcmU6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLm9wdGltaXplci5yZW5kZXJTdGF0dXModGhpcy5naXRTZXR0aW5nLmNvbnRyb2xFbCwgc3RhdHVzKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgdXBkYXRlVml0ZVNldHRpbmcoc3RhdHVzOiAnY29uZmlndXJlZCcgfCAnbm90LWNvbmZpZ3VyZWQnKSB7XHJcblx0XHR0aGlzLnZpdGVTZXR0aW5nLnNldE5hbWUoJ0lnbm9yZSBpbiBWaXRlJylcclxuXHRcdFx0LnNldERlc2MoJ0NvbmZpZ3VyZSBWaXRlIHRvIGlnbm9yZSBpbnRlcm5hbCBmb2xkZXJzJylcclxuXHRcdFx0LmNsZWFyKCk7IC8vIENsZWFyIGV4aXN0aW5nIGJ1dHRvbnMgYW5kIHN0YXR1c1xyXG5cdFx0XHRcclxuXHRcdHRoaXMudml0ZVNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XHJcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcclxuXHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLm9wdGltaXplci5jb25maWd1cmVWaXRlSWdub3JlKCk7XHJcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmlnbm9yZUNvbmZpZy52aXRlSWdub3JlQ29uZmlndXJlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdWaXRlIG9wdGltaXphdGlvbiBhcHBsaWVkJyk7XHJcblx0XHRcdFx0XHRcdGNvbnN0IG5ld1N0YXR1cyA9IGF3YWl0IHRoaXMub3B0aW1pemVyLmdldFN0YXR1cygpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZVZpdGVTZXR0aW5nKG5ld1N0YXR1cy52aXRlSWdub3JlU3RhdHVzKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byB1cGRhdGUgVml0ZSBjb25maWc6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLm9wdGltaXplci5yZW5kZXJTdGF0dXModGhpcy52aXRlU2V0dGluZy5jb250cm9sRWwsIHN0YXR1cyk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XHJcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XHJcblx0XHRjb25zdCBjc3NLZXkgPSBrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcclxuXHRcdGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoY3NzS2V5LCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vd2l6YXJkL0Jhc2VXaXphcmRTdGVwJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGVNYW5hZ2VyIH0gZnJvbSAnLi93aXphcmQvV2l6YXJkU3RhdGVNYW5hZ2VyJztcclxuaW1wb3J0IFZhdWx0Q01TUGx1Z2luIGZyb20gJy4uL21haW4nO1xyXG5pbXBvcnQgeyBXZWxjb21lU3RlcCB9IGZyb20gJy4vd2l6YXJkL1dlbGNvbWVTdGVwJztcclxuaW1wb3J0IHsgUHJvamVjdERldGVjdGlvblN0ZXAgfSBmcm9tICcuL3dpemFyZC9Qcm9qZWN0RGV0ZWN0aW9uU3RlcCc7XHJcbmltcG9ydCB7IENvbnRlbnRUeXBlU3RlcCB9IGZyb20gJy4vd2l6YXJkL0NvbnRlbnRUeXBlU3RlcCc7XHJcbmltcG9ydCB7IERlZmF1bHRDb250ZW50VHlwZVN0ZXAgfSBmcm9tICcuL3dpemFyZC9EZWZhdWx0Q29udGVudFR5cGVTdGVwJztcclxuaW1wb3J0IHsgRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzU3RlcCB9IGZyb20gJy4vd2l6YXJkL0Zyb250bWF0dGVyUHJvcGVydGllc1N0ZXAnO1xyXG5pbXBvcnQgeyBXWVNJV1lHUHJlZmVyZW5jZVN0ZXAgfSBmcm9tICcuL3dpemFyZC9XWVNJV1lHUHJlZmVyZW5jZVN0ZXAnO1xyXG5pbXBvcnQgeyBCYXNlc0NNU0NvbmZpZ1N0ZXAgfSBmcm9tICcuL3dpemFyZC9CYXNlc0NNU0NvbmZpZ1N0ZXAnO1xyXG5pbXBvcnQgeyBBc3Ryb0NvbXBvc2VyU3RlcCB9IGZyb20gJy4vd2l6YXJkL0FzdHJvQ29tcG9zZXJTdGVwJztcclxuaW1wb3J0IHsgU0VPQ29uZmlnU3RlcCB9IGZyb20gJy4vd2l6YXJkL1NFT0NvbmZpZ1N0ZXAnO1xyXG5pbXBvcnQgeyBPcHRpb25hbFBsdWdpbnNTdGVwIH0gZnJvbSAnLi93aXphcmQvT3B0aW9uYWxQbHVnaW5zU3RlcCc7XHJcbmltcG9ydCB7IElnbm9yZVN0ZXAgfSBmcm9tICcuL3dpemFyZC9JZ25vcmVTdGVwJztcclxuaW1wb3J0IHsgRmluYWxpemVTdGVwIH0gZnJvbSAnLi93aXphcmQvRmluYWxpemVTdGVwJztcclxuXHJcbmV4cG9ydCBjbGFzcyBTZXR1cFdpemFyZE1vZGFsIGV4dGVuZHMgTW9kYWwge1xyXG5cdHByaXZhdGUgc3RhdGVNYW5hZ2VyOiBXaXphcmRTdGF0ZU1hbmFnZXI7XHJcblx0cHJpdmF0ZSBwbHVnaW46IFZhdWx0Q01TUGx1Z2luO1xyXG5cdHByaXZhdGUgc3RlcHM6IChuZXcgKGFwcDogQXBwLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHN0YXRlOiBXaXphcmRTdGF0ZSwgb25OZXh0OiAoKSA9PiB2b2lkLCBvbkJhY2s6ICgpID0+IHZvaWQsIG9uQ2FuY2VsOiAoKSA9PiB2b2lkKSA9PiBCYXNlV2l6YXJkU3RlcClbXTtcclxuXHRwcml2YXRlIGN1cnJlbnRTdGVwSW5zdGFuY2U6IEJhc2VXaXphcmRTdGVwIHwgbnVsbCA9IG51bGw7XHJcblx0cHJpdmF0ZSBpc0NvbXBsZXRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwcml2YXRlIGluaXRpYWxTZXR0aW5nc1NuYXBzaG90OiBQYXJ0aWFsPFdpemFyZFN0YXRlPiB8IG51bGwgPSBudWxsO1xyXG5cdHByaXZhdGUgbGFzdFNhdmVkU3RlcEluZGV4OiBudW1iZXIgPSAtMTsgLy8gVHJhY2sgdGhlIGxhc3Qgc3RlcCB3aGVyZSBcIk5leHRcIiB3YXMgY2xpY2tlZFxyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgaW5pdGlhbFN0YXRlPzogUGFydGlhbDxXaXphcmRTdGF0ZT4sIHBsdWdpbkluc3RhbmNlPzogVmF1bHRDTVNQbHVnaW4pIHtcclxuXHRcdHN1cGVyKGFwcCk7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbkluc3RhbmNlIHx8IChhcHAgYXMgeyBwbHVnaW5zPzogeyBwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgVmF1bHRDTVNQbHVnaW4+IH0gfSkucGx1Z2lucz8ucGx1Z2lucz8uWyd2YXVsdC1jbXMnXSBhcyBWYXVsdENNU1BsdWdpbjtcclxuXHRcdFxyXG5cdFx0aWYgKCF0aGlzLnBsdWdpbikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ZhdWx0Q01TUGx1Z2luIGluc3RhbmNlIGlzIHJlcXVpcmVkJyk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHRoaXMuc3RhdGVNYW5hZ2VyID0gbmV3IFdpemFyZFN0YXRlTWFuYWdlcih0aGlzLnBsdWdpbik7XHJcblx0XHRcclxuXHRcdC8vIEFwcGx5IGFueSBpbml0aWFsIHN0YXRlIG92ZXJyaWRlc1xyXG5cdFx0aWYgKGluaXRpYWxTdGF0ZSkge1xyXG5cdFx0XHR0aGlzLnN0YXRlTWFuYWdlci51cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RlcHMgPSBbXHJcblx0XHRcdFdlbGNvbWVTdGVwLFxyXG5cdFx0XHRQcm9qZWN0RGV0ZWN0aW9uU3RlcCxcclxuXHRcdFx0Q29udGVudFR5cGVTdGVwLFxyXG5cdFx0XHREZWZhdWx0Q29udGVudFR5cGVTdGVwLFxyXG5cdFx0XHRGcm9udG1hdHRlclByb3BlcnRpZXNTdGVwLFxyXG5cdFx0XHRXWVNJV1lHUHJlZmVyZW5jZVN0ZXAsXHJcblx0XHRcdEJhc2VzQ01TQ29uZmlnU3RlcCxcclxuXHRcdFx0QXN0cm9Db21wb3NlclN0ZXAsXHJcblx0XHRcdFNFT0NvbmZpZ1N0ZXAsXHJcblx0XHRcdE9wdGlvbmFsUGx1Z2luc1N0ZXAsXHJcblx0XHRcdElnbm9yZVN0ZXAsXHJcblx0XHRcdEZpbmFsaXplU3RlcFxyXG5cdFx0XTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIG9uT3BlbigpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XHJcblx0XHRjb250ZW50RWwuYWRkQ2xhc3MoJ3ZhdWx0LWNtcy13aXphcmQnKTtcclxuXHRcdFxyXG5cdFx0Ly8gUmVmcmVzaCB0aGUgd2l6YXJkIHN0YXRlIHdpdGggY3VycmVudCBzZXR0aW5nc1xyXG5cdFx0YXdhaXQgdGhpcy5zdGF0ZU1hbmFnZXIucmVmcmVzaFN0YXRlKCk7XHJcblx0XHRcclxuXHRcdC8vIFN0b3JlIGEgc25hcHNob3Qgb2YgaW5pdGlhbCBzZXR0aW5ncyB0byBkZXRlY3QgY2hhbmdlcyBsYXRlclxyXG5cdFx0dGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdCA9IHRoaXMuY3JlYXRlU2V0dGluZ3NTbmFwc2hvdCgpO1xyXG5cdFx0XHJcblx0XHQvLyBSZW5kZXIgY3VycmVudCBzdGVwIChtYXkgYmUgYXN5bmMsIGJ1dCB3ZSBkb24ndCBhd2FpdCBpdClcclxuXHRcdHZvaWQgdGhpcy5yZW5kZXJDdXJyZW50U3RlcCgpO1xyXG5cdH1cclxuXHJcblx0b25DbG9zZSgpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XHJcblx0XHRcclxuXHRcdC8vIFdoZW4gY2xvc2luZywgb25seSBwcmVzZXJ2ZSBjaGFuZ2VzIGZyb20gc3RlcHMgd2hlcmUgXCJOZXh0XCIgd2FzIGNsaWNrZWRcclxuXHRcdC8vIERpc2NhcmQgdW5zYXZlZCBjaGFuZ2VzIGZyb20gdGhlIGN1cnJlbnQgc3RlcCAoZXF1aXZhbGVudCB0byBcIlNraXBcIilcclxuXHRcdC8vIFRoZSBcIk5leHRcIiBidXR0b24gYWxyZWFkeSBzYXZlZCB0aG9zZSBzdGVwcywgc28gd2UgZG9uJ3QgbmVlZCB0byBzYXZlIGFnYWluXHJcblx0XHQvLyBKdXN0IGNsb3NlIHdpdGhvdXQgc2F2aW5nIC0gdGhpcyBkaXNjYXJkcyBjdXJyZW50IHN0ZXAgY2hhbmdlcyBidXQgcHJlc2VydmVzIHByZXZpb3VzIFwiTmV4dFwiIHNhdmVzXHJcblx0XHRcclxuXHRcdC8vIFJlc2V0IHRoZSBmbGFnXHJcblx0XHR0aGlzLmlzQ29tcGxldGluZyA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzY3JvbGxUb1RvcCgpIHtcclxuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xyXG5cdFx0XHJcblx0XHQvLyBNZXRob2QgMTogRmluZCBhbmQgc2Nyb2xsIHRoZSBhY3R1YWwgc2Nyb2xsYWJsZSBwYXJlbnRcclxuXHRcdGxldCBzY3JvbGxhYmxlUGFyZW50OiBIVE1MRWxlbWVudCB8IG51bGwgPSBjb250ZW50RWw7XHJcblx0XHR3aGlsZSAoc2Nyb2xsYWJsZVBhcmVudCAmJiBzY3JvbGxhYmxlUGFyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XHJcblx0XHRcdGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2Nyb2xsYWJsZVBhcmVudCk7XHJcblx0XHRcdGlmIChzY3JvbGxhYmxlUGFyZW50LnNjcm9sbEhlaWdodCA+IHNjcm9sbGFibGVQYXJlbnQuY2xpZW50SGVpZ2h0ICYmIFxyXG5cdFx0XHRcdChzdHlsZS5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBzdHlsZS5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IHN0eWxlLm92ZXJmbG93ID09PSAnYXV0bycgfHwgc3R5bGUub3ZlcmZsb3cgPT09ICdzY3JvbGwnKSkge1xyXG5cdFx0XHRcdHNjcm9sbGFibGVQYXJlbnQuc2Nyb2xsVG9wID0gMDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRzY3JvbGxhYmxlUGFyZW50ID0gc2Nyb2xsYWJsZVBhcmVudC5wYXJlbnRFbGVtZW50O1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBNZXRob2QgMjogVHJ5IGNvbW1vbiBPYnNpZGlhbiBtb2RhbCBjb250YWluZXJzXHJcblx0XHRjb25zdCBtb2RhbENvbnRlbnQgPSBjb250ZW50RWwuY2xvc2VzdCgnLm1vZGFsLWNvbnRlbnQnKTtcclxuXHRcdGlmIChtb2RhbENvbnRlbnQpIHtcclxuXHRcdFx0KG1vZGFsQ29udGVudCBhcyBIVE1MRWxlbWVudCkuc2Nyb2xsVG9wID0gMDtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y29uc3QgbW9kYWxDb250YWluZXIgPSBjb250ZW50RWwuY2xvc2VzdCgnLm1vZGFsLWNvbnRhaW5lcicpO1xyXG5cdFx0aWYgKG1vZGFsQ29udGFpbmVyKSB7XHJcblx0XHRcdChtb2RhbENvbnRhaW5lciBhcyBIVE1MRWxlbWVudCkuc2Nyb2xsVG9wID0gMDtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gQWxzbyB0cnkgY29udGVudEVsIGl0c2VsZlxyXG5cdFx0Y29udGVudEVsLnNjcm9sbFRvcCA9IDA7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHJlbmRlckN1cnJlbnRTdGVwKCkge1xyXG5cdFx0Y29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XHJcblx0XHRcclxuXHRcdC8vIFNjcm9sbCB0byB0b3AgSU1NRURJQVRFTFkgYmVmb3JlIGNsZWFyaW5nIGNvbnRlbnQgdG8gcHJldmVudCB2aXN1YWwganVtcFxyXG5cdFx0dGhpcy5zY3JvbGxUb1RvcCgpO1xyXG5cdFx0XHJcblx0XHQvLyBDbGVhciBjb250ZW50XHJcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcclxuXHRcdGNvbnRlbnRFbC5hZGRDbGFzcygndmF1bHQtY21zLXdpemFyZCcpO1xyXG5cclxuXHRcdC8vIFNjcm9sbCB0byB0b3AgYWdhaW4gYWZ0ZXIgY2xlYXJpbmcgKGluIGNhc2UgY2xlYXJpbmcgY2hhbmdlZCBzY3JvbGwgcG9zaXRpb24pXHJcblx0XHR0aGlzLnNjcm9sbFRvVG9wKCk7XHJcblxyXG5cdFx0Ly8gUmVuZGVyIHByb2dyZXNzXHJcblx0XHR0aGlzLnJlbmRlclByb2dyZXNzKGNvbnRlbnRFbCk7XHJcblxyXG5cdFx0Ly8gUmVuZGVyIHN0ZXAgY29udGVudCAobWF5IGJlIGFzeW5jLCBidXQgd2UgZG9uJ3QgYXdhaXQgaXQpXHJcblx0XHRjb25zdCBzdGVwQ29udGVudCA9IGNvbnRlbnRFbC5jcmVhdGVEaXYoJ3dpemFyZC1jb250ZW50Jyk7XHJcblx0XHRhd2FpdCB0aGlzLnJlbmRlclN0ZXBDb250ZW50KHN0ZXBDb250ZW50KTtcclxuXHJcblx0XHQvLyBSZW5kZXIgZm9vdGVyXHJcblx0XHR0aGlzLnJlbmRlckZvb3Rlcihjb250ZW50RWwpO1xyXG5cdFx0XHJcblx0XHQvLyBGaW5hbCBzY3JvbGwgdG8gdG9wIGFmdGVyIGFsbCByZW5kZXJpbmcgaXMgY29tcGxldGVcclxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcblx0XHRcdHRoaXMuc2Nyb2xsVG9Ub3AoKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSByZW5kZXJQcm9ncmVzcyhjb250YWluZXI6IEhUTUxFbGVtZW50KSB7XHJcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XHJcblx0XHRjb25zdCB0b3RhbFN0ZXBzID0gdGhpcy5zdGVwcy5sZW5ndGg7XHJcblx0XHRjb25zdCBwcm9ncmVzcyA9IGNvbnRhaW5lci5jcmVhdGVEaXYoJ3dpemFyZC1wcm9ncmVzcycpO1xyXG5cdFx0XHJcblx0XHRjb25zdCBwcm9ncmVzc0JhciA9IHByb2dyZXNzLmNyZWF0ZURpdigncHJvZ3Jlc3MtYmFyJyk7XHJcblx0XHRjb25zdCBwcm9ncmVzc0ZpbGwgPSBwcm9ncmVzc0Jhci5jcmVhdGVEaXYoJ3Byb2dyZXNzLWZpbGwnKTtcclxuXHRcdC8vIFNldCBkeW5hbWljIHdpZHRoIHVzaW5nIHNldENzc1Byb3BzXHJcblx0XHRzZXRDc3NQcm9wcyhwcm9ncmVzc0ZpbGwsIHsgd2lkdGg6IGAke3RoaXMuc3RhdGVNYW5hZ2VyLmdldFByb2dyZXNzKHRvdGFsU3RlcHMpfSVgIH0pO1xyXG5cdFx0XHJcblx0XHQvLyBBZGQgc3RlcCB0ZXh0IGJlbG93IHRoZSBwcm9ncmVzcyBiYXJcclxuXHRcdGNvbnN0IHByb2dyZXNzVGV4dCA9IHByb2dyZXNzLmNyZWF0ZURpdigncHJvZ3Jlc3MtdGV4dCcpO1xyXG5cdFx0cHJvZ3Jlc3NUZXh0LnRleHRDb250ZW50ID0gYFN0ZXAgJHtzdGF0ZS5jdXJyZW50U3RlcCArIDF9IG9mICR7dG90YWxTdGVwc31gO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyByZW5kZXJTdGVwQ29udGVudChjb250YWluZXI6IEhUTUxFbGVtZW50KSB7XHJcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XHJcblx0XHRjb25zdCBzdGVwSW5kZXggPSBzdGF0ZS5jdXJyZW50U3RlcDtcclxuXHRcdFxyXG5cdFx0aWYgKHN0ZXBJbmRleCA+PSAwICYmIHN0ZXBJbmRleCA8IHRoaXMuc3RlcHMubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IFN0ZXBDbGFzcyA9IHRoaXMuc3RlcHNbc3RlcEluZGV4XTtcclxuXHRcdFx0Y29uc3Qgc3RlcE5hbWUgPSBTdGVwQ2xhc3MubmFtZSB8fCAnVW5rbm93bic7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoYFNldHVwV2l6YXJkTW9kYWw6IERpc3BsYXlpbmcgc3RlcCAke3N0ZXBJbmRleCArIDF9LyR7dGhpcy5zdGVwcy5sZW5ndGh9OiAke3N0ZXBOYW1lfWApO1xyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5jdXJyZW50U3RlcEluc3RhbmNlID0gbmV3IFN0ZXBDbGFzcyhcclxuXHRcdFx0XHR0aGlzLmFwcCxcclxuXHRcdFx0XHRjb250YWluZXIsXHJcblx0XHRcdFx0c3RhdGUsXHJcblx0XHRcdFx0KCkgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gTmV4dCBoYW5kbGVyIC0gc2F2ZSBhbmQgYWR2YW5jZVxyXG5cdFx0XHRcdFx0dm9pZCAoYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jdXJyZW50U3RlcEluc3RhbmNlICYmIHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZS52YWxpZGF0ZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ3VycmVudFN0ZXBUb1dpemFyZFN0YXRlKCk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIubmV4dFN0ZXAoKTtcclxuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnJlbmRlckN1cnJlbnRTdGVwKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHQoKSA9PiB7XHJcblx0XHRcdFx0XHQvLyBCYWNrIGhhbmRsZXIgLSBkaXNjYXJkIGFuZCBnbyBiYWNrXHJcblx0XHRcdFx0XHR0aGlzLmRpc2NhcmRDdXJyZW50U3RlcENoYW5nZXMoKTtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLnByZXZpb3VzU3RlcCgpO1xyXG5cdFx0XHRcdFx0dm9pZCB0aGlzLnJlbmRlckN1cnJlbnRTdGVwKCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHQoKSA9PiB0aGlzLmNsb3NlKClcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdC8vIEF3YWl0IGRpc3BsYXkoKSBzaW5jZSBpdCBtYXkgYmUgYXN5bmNcclxuXHRcdFx0YXdhaXQgdGhpcy5jdXJyZW50U3RlcEluc3RhbmNlLmRpc3BsYXkoKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVuZGVyRm9vdGVyKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcclxuXHRcdGNvbnN0IGZvb3RlciA9IGNvbnRhaW5lci5jcmVhdGVEaXYoJ3dpemFyZC1mb290ZXInKTtcclxuXHRcdHNldENzc1Byb3BzKGZvb3RlciwgeyBkaXNwbGF5OiAnZmxleCcsIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsIGFsaWduSXRlbXM6ICdjZW50ZXInIH0pO1xyXG5cdFx0XHJcblx0XHQvLyBTdGFydHVwIHNldHRpbmcgY2hlY2tib3ggKG9ubHkgb24gdGhlIGZpcnN0IHN0ZXApXHJcblx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5jdXJyZW50U3RlcCA9PT0gMCkge1xyXG5cdFx0XHRjb25zdCBzdGFydHVwU2V0dGluZyA9IGZvb3Rlci5jcmVhdGVEaXYoJ3dpemFyZC1zdGFydHVwLXNldHRpbmctZm9vdGVyJyk7XHJcblx0XHRcdGNvbnN0IGxhYmVsID0gc3RhcnR1cFNldHRpbmcuY3JlYXRlRWwoJ2xhYmVsJywgeyBjbHM6ICd3aXphcmQtY2hlY2tib3gtbGFiZWwnIH0pO1xyXG5cdFx0XHQvLyBFbnN1cmUgY3Vyc29yIGlzIGRlZmF1bHQgd2hlbiBob3ZlcmluZyBvdmVyIHRoZSBsYWJlbC9jaGVja2JveFxyXG5cdFx0XHRzZXRDc3NQcm9wcyhsYWJlbCwgeyBjdXJzb3I6ICdkZWZhdWx0JyB9KTtcclxuXHRcdFx0Y29uc3QgY2hlY2tib3ggPSBsYWJlbC5jcmVhdGVFbCgnaW5wdXQnLCB7IHR5cGU6ICdjaGVja2JveCcgfSk7XHJcblx0XHRcdHNldENzc1Byb3BzKGNoZWNrYm94LCB7IGN1cnNvcjogJ2RlZmF1bHQnIH0pO1xyXG5cdFx0XHRjaGVja2JveC5jaGVja2VkID0gIXRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cDtcclxuXHRcdFx0bGFiZWwuY3JlYXRlU3Bhbih7IHRleHQ6IFwiIEkndmUgYWxyZWFkeSBzZXQgdXAgbXkgdmF1bHQsIGRvbid0IHNob3cgb24gc3RhcnR1cFwiIH0pO1xyXG5cdFx0XHRcclxuXHRcdFx0Y2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xyXG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnJ1bldpemFyZE9uU3RhcnR1cCA9ICFjaGVja2JveC5jaGVja2VkO1xyXG5cdFx0XHRcdHZvaWQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gRW1wdHkgZGl2IHRvIGtlZXAgYnV0dG9ucyBwdXNoZWQgdG8gdGhlIHJpZ2h0XHJcblx0XHRcdGZvb3Rlci5jcmVhdGVEaXYoKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y29uc3QgYnV0dG9ucyA9IGZvb3Rlci5jcmVhdGVEaXYoJ3dpemFyZC1idXR0b25zJyk7XHJcblx0XHRzZXRDc3NQcm9wcyhidXR0b25zLCB7IGRpc3BsYXk6ICdmbGV4JywgZ2FwOiAnMTBweCcgfSk7XHJcblx0XHRcclxuXHRcdC8vIFByZXZpb3VzIGJ1dHRvblxyXG5cdFx0aWYgKHRoaXMuc3RhdGVNYW5hZ2VyLmNhbkdvUHJldmlvdXMoKSkge1xyXG5cdFx0XHRjb25zdCBwcmV2QnRuID0gYnV0dG9ucy5jcmVhdGVFbCgnYnV0dG9uJywge1xyXG5cdFx0XHRcdHRleHQ6ICdQcmV2aW91cycsXHJcblx0XHRcdFx0Y2xzOiAnbW9kLWJ1dHRvbidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHByZXZCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdFx0Ly8gRGlzY2FyZCBhbnkgY2hhbmdlcyBtYWRlIG9uIGN1cnJlbnQgc3RlcCBhbmQgZ28gYmFja1xyXG5cdFx0XHRcdHRoaXMuZGlzY2FyZEN1cnJlbnRTdGVwQ2hhbmdlcygpO1xyXG5cdFx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLnByZXZpb3VzU3RlcCgpO1xyXG5cdFx0XHRcdHZvaWQgdGhpcy5yZW5kZXJDdXJyZW50U3RlcCgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBOZXh0L0NvbXBsZXRlIGJ1dHRvblxyXG5cdFx0aWYgKHRoaXMuc3RhdGVNYW5hZ2VyLmNhbkdvTmV4dCh0aGlzLnN0ZXBzLmxlbmd0aCkpIHtcclxuXHRcdFx0Ly8gRG9uJ3Qgc2hvdyBcIk5leHRcIiBidXR0b24gb24gdGhlIGZpcnN0IHN0ZXAgKFdlbGNvbWVTdGVwKVxyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5jdXJyZW50U3RlcCAhPT0gMCkge1xyXG5cdFx0XHRcdGNvbnN0IG5leHRCdG4gPSBidXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcblx0XHRcdFx0XHR0ZXh0OiAnTmV4dCcsXHJcblx0XHRcdFx0XHRjbHM6ICdtb2QtYnV0dG9uIG1vZC1jdGEnXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0bmV4dEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vIFNhdmUgY3VycmVudCBzdGVwIGNoYW5nZXMgdG8gd2l6YXJkIHN0YXRlIGFuZCBkYXRhLmpzb25cclxuXHRcdFx0XHRcdHZvaWQgKGFzeW5jICgpID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZSAmJiB0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UudmFsaWRhdGUoKSkge1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZUN1cnJlbnRTdGVwVG9XaXphcmRTdGF0ZSgpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIFRyYWNrIHRoYXQgdGhpcyBzdGVwIHdhcyBzYXZlZFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMubGFzdFNhdmVkU3RlcEluZGV4ID0gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKS5jdXJyZW50U3RlcDtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlTWFuYWdlci5uZXh0U3RlcCgpO1xyXG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucmVuZGVyQ3VycmVudFN0ZXAoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSkoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gRmluYWwgc3RlcCAtIHByb3ZpZGUgQXBwbHkgYW5kIEFwcGx5IGFuZCByZXN0YXJ0IG9wdGlvbnNcclxuXHRcdFx0aWYgKHRoaXMuY3VycmVudFN0ZXBJbnN0YW5jZSBpbnN0YW5jZW9mIEZpbmFsaXplU3RlcCkge1xyXG5cdFx0XHRcdGNvbnN0IGFwcGx5QnRuID0gYnV0dG9ucy5jcmVhdGVFbCgnYnV0dG9uJywge1xyXG5cdFx0XHRcdFx0dGV4dDogJ0FwcGx5JyxcclxuXHRcdFx0XHRcdGNsczogJ21vZC1idXR0b24nXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0YXBwbHlCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdFx0XHR2b2lkIHRoaXMuaGFuZGxlQ29tcGxldGUoZmFsc2UpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRjb25zdCBhcHBseVJlc3RhcnRCdG4gPSBidXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcblx0XHRcdFx0XHR0ZXh0OiAnQXBwbHkgYW5kIHJlc3RhcnQnLFxyXG5cdFx0XHRcdFx0Y2xzOiAnbW9kLWJ1dHRvbiBtb2QtY3RhJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGFwcGx5UmVzdGFydEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuXHRcdFx0XHRcdHZvaWQgdGhpcy5oYW5kbGVDb21wbGV0ZSh0cnVlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBGYWxsYmFjayBmb3Igb3RoZXIgc3RlcHMgdGhhdCBtaWdodCBiZSB0aGUgbGFzdCBzdGVwXHJcblx0XHRcdFx0Y29uc3QgY29tcGxldGVCdG4gPSBidXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XHJcblx0XHRcdFx0XHR0ZXh0OiAnQ29tcGxldGUgc2V0dXAnLFxyXG5cdFx0XHRcdFx0Y2xzOiAnbW9kLWJ1dHRvbiBtb2QtY3RhJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGNvbXBsZXRlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHRcdFx0dm9pZCB0aGlzLmhhbmRsZUNvbXBsZXRlKGZhbHNlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNraXAgYnV0dG9uIChmb3IgYWxsIHN0ZXBzIGV4Y2VwdCB0aGUgbGFzdClcclxuXHRcdGlmICh0aGlzLnN0YXRlTWFuYWdlci5jYW5Hb05leHQodGhpcy5zdGVwcy5sZW5ndGgpKSB7XHJcblx0XHRcdC8vIERvbid0IHNob3cgXCJTa2lwXCIgYnV0dG9uIG9uIHRoZSBmaXJzdCBzdGVwIChXZWxjb21lU3RlcClcclxuXHRcdFx0aWYgKHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCkuY3VycmVudFN0ZXAgIT09IDApIHtcclxuXHRcdFx0XHRjb25zdCBza2lwQnRuID0gYnV0dG9ucy5jcmVhdGVFbCgnYnV0dG9uJywge1xyXG5cdFx0XHRcdFx0dGV4dDogJ1NraXAnLFxyXG5cdFx0XHRcdFx0Y2xzOiAnbW9kLWJ1dHRvbidcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRza2lwQnRuLmFkZENsYXNzKCd3aXphcmQtc2tpcC1idXR0b24nKTtcclxuXHRcdFx0XHRzZXRDc3NQcm9wcyhza2lwQnRuLCB7IG9wYWNpdHk6ICcwLjYnIH0pO1xyXG5cdFx0XHRcdHNraXBCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdFx0XHQvLyBTa2lwIHdpdGhvdXQgc2F2aW5nIGN1cnJlbnQgc3RlcCBjaGFuZ2VzIHRvIHdpemFyZCBzdGF0ZVxyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIubmV4dFN0ZXAoKTtcclxuXHRcdFx0XHRcdHZvaWQgdGhpcy5yZW5kZXJDdXJyZW50U3RlcCgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIGhhbmRsZUNvbXBsZXRlKHNob3VsZFJlc3RhcnQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGlmICh0aGlzLmlzQ29tcGxldGluZykgcmV0dXJuO1xyXG5cdFx0dGhpcy5pc0NvbXBsZXRpbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdGlmICh0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UgJiYgdGhpcy5jdXJyZW50U3RlcEluc3RhbmNlLnZhbGlkYXRlKCkpIHtcclxuXHRcdFx0XHQvLyBJZiB3ZSdyZSBvbiBGaW5hbGl6ZVN0ZXAsIGFwcGx5IGNvbmZpZ3VyYXRpb24gZmlyc3RcclxuXHRcdFx0XHRpZiAodGhpcy5jdXJyZW50U3RlcEluc3RhbmNlIGluc3RhbmNlb2YgRmluYWxpemVTdGVwKSB7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmN1cnJlbnRTdGVwSW5zdGFuY2UuYXBwbHlDb25maWd1cmF0aW9uKHNob3VsZFJlc3RhcnQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBGb3Igb3RoZXIgc3RlcHMsIGp1c3Qgc2F2ZSB0aGUgY3VycmVudCBzdGVwXHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDdXJyZW50U3RlcFRvV2l6YXJkU3RhdGUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gTWFyayB3aXphcmQgYXMgY29tcGxldGVkIGFuZCBkaXNhYmxlIHN0YXJ0dXAgdHJpZ2dlclxyXG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLndpemFyZENvbXBsZXRlZCA9IHRydWU7XHJcblx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucnVuV2l6YXJkT25TdGFydHVwID0gZmFsc2U7XHJcblx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQ1JJVElDQUw6IFJlbG9hZCBzZXR0aW5ncyBmcm9tIGRpc2sgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgaXMgc3luY2hyb25pemVkXHJcblx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4ubG9hZFNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0dGhpcy5jbG9zZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBUcmlnZ2VyIHJlc3RhcnQgaWYgcmVxdWVzdGVkXHJcblx0XHRcdFx0aWYgKHNob3VsZFJlc3RhcnQpIHtcclxuXHRcdFx0XHRcdC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBOb3RpY2UgaXMgdmlzaWJsZSBhbmQgc2V0dGluZ3MgYXJlIHNhdmVkXHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0XHRcdFx0aW50ZXJmYWNlIEFwcFdpdGhDb21tYW5kcyBleHRlbmRzIEFwcCB7XHJcblx0XHRcdFx0XHRcdFx0Y29tbWFuZHM6IHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4ZWN1dGVDb21tYW5kQnlJZChpZDogc3RyaW5nKTogdm9pZDtcclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdCh0aGlzLmFwcCBhcyB1bmtub3duIGFzIEFwcFdpdGhDb21tYW5kcykuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmRCeUlkKCdhcHA6cmVsb2FkJyk7XHJcblx0XHRcdFx0XHR9LCAxMDAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXBsZXRpbmcgd2l6YXJkOicsIGVycm9yKTtcclxuXHRcdFx0bmV3IE5vdGljZSgnRmFpbGVkIHRvIGNvbXBsZXRlIHNldHVwLiBQbGVhc2UgY2hlY2sgdGhlIGNvbnNvbGUgZm9yIGRldGFpbHMuJyk7XHJcblx0XHR9IGZpbmFsbHkge1xyXG5cdFx0XHR0aGlzLmlzQ29tcGxldGluZyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ3VycmVudFN0ZXBUb1dpemFyZFN0YXRlKCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Ly8gU2F2ZSBjdXJyZW50IHN0ZXAgY2hhbmdlcyB0byB3aXphcmQgc3RhdGUgYW5kIGRhdGEuanNvblxyXG5cdFx0Ly8gVGhpcyBpcyBjYWxsZWQgd2hlbiBORVhUIGlzIGNsaWNrZWQgdG8gZW5zdXJlIGRhdGEuanNvbiBzdGF5cyBpbiBzeW5jXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBCdWlsZCBmaW5hbCBzZXR0aW5ncyBmcm9tIHdpemFyZCBzdGF0ZSAodXBkYXRlcyBwbHVnaW4uc2V0dGluZ3MpXHJcblx0XHRcdHRoaXMuc3RhdGVNYW5hZ2VyLmJ1aWxkRmluYWxTZXR0aW5ncygpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gU2F2ZSB0byBkYXRhLmpzb25cclxuXHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBSZWxvYWQgc2V0dGluZ3MgdG8gZW5zdXJlIHRoZSBwbHVnaW4gaGFzIHRoZSBsYXRlc3QgdmFsdWVzXHJcblx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLmxvYWRTZXR0aW5ncygpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGN1cnJlbnQgc3RlcCB0byBkYXRhLmpzb246JywgZXJyb3IpO1xyXG5cdFx0XHQvLyBEb24ndCBzaG93IGVycm9yIHRvIHVzZXIgLSBqdXN0IGxvZyBpdCwgYXMgdGhpcyBzaG91bGRuJ3QgYmxvY2sgbmF2aWdhdGlvblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBkaXNjYXJkQ3VycmVudFN0ZXBDaGFuZ2VzKCk6IHZvaWQge1xyXG5cdFx0Ly8gRGlzY2FyZCBjaGFuZ2VzIG1hZGUgb24gY3VycmVudCBzdGVwIC0gdGhpcyBpcyBjYWxsZWQgd2hlbiBQUkVWSU9VUyBpcyBjbGlja2VkXHJcblx0XHQvLyBSZWZyZXNoIHRoZSB3aXphcmQgc3RhdGUgdG8gc2hvdyBvcmlnaW5hbCB2YWx1ZXMgZnJvbSBkYXRhLmpzb25cclxuXHRcdHZvaWQgdGhpcy5zdGF0ZU1hbmFnZXIucmVmcmVzaFN0YXRlKCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHNhdmVXaXphcmRTdGF0ZVRvRGF0YUpzb24oc2hvd05vdGlmaWNhdGlvbjogYm9vbGVhbiA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdC8vIFNhdmUgd2l6YXJkIHN0YXRlIGNoYW5nZXMgdG8gZGF0YS5qc29uIHdoZW4gbW9kYWwgaXMgY2xvc2VkXHJcblx0XHQvLyBUaGlzIGVuc3VyZXMgY2hhbmdlcyBhcmUgcHJlc2VydmVkIGV2ZW4gaWYgdXNlciBjbG9zZXMgbW9kYWwgd2l0aG91dCBjb21wbGV0aW5nIHdpemFyZFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gQnVpbGQgZmluYWwgc2V0dGluZ3MgZnJvbSB3aXphcmQgc3RhdGVcclxuXHRcdFx0dGhpcy5zdGF0ZU1hbmFnZXIuYnVpbGRGaW5hbFNldHRpbmdzKCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDaGVjayBpZiBhbnkgY2hhbmdlcyB3ZXJlIGFjdHVhbGx5IG1hZGVcclxuXHRcdFx0Y29uc3QgaGFzQ2hhbmdlcyA9IHRoaXMuaGFzU2V0dGluZ3NDaGFuZ2VkKCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBPbmx5IHNhdmUgdG8gZGF0YS5qc29uIGlmIHRoZXJlIHdlcmUgYWN0dWFsIGNoYW5nZXNcclxuXHRcdFx0aWYgKCFoYXNDaGFuZ2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuOyAvLyBObyBjaGFuZ2VzLCBkb24ndCBzYXZlIGFueXRoaW5nXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIFNhdmUgdG8gZGF0YS5qc29uXHJcblx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gUmVsb2FkIHNldHRpbmdzIHRvIGVuc3VyZSB0aGUgcGx1Z2luIGhhcyB0aGUgbGF0ZXN0IHZhbHVlc1xyXG5cdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5sb2FkU2V0dGluZ3MoKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIE9ubHkgc2hvdyBub3RpZmljYXRpb24gaWYgcmVxdWVzdGVkXHJcblx0XHRcdGlmIChzaG93Tm90aWZpY2F0aW9uKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZSgnQ29uZmlndXJhdGlvbiBzYXZlZCcpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgd2l6YXJkIHN0YXRlIHRvIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdGlmIChzaG93Tm90aWZpY2F0aW9uKSB7XHJcblx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHNhdmUgY29uZmlndXJhdGlvbjogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0cHJpdmF0ZSBjcmVhdGVTZXR0aW5nc1NuYXBzaG90KCk6IFBhcnRpYWw8V2l6YXJkU3RhdGU+IHtcclxuXHRcdC8vIENyZWF0ZSBhIGRlZXAgY29weSBvZiBjdXJyZW50IHN0YXRlIGZvciBjb21wYXJpc29uXHJcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVNYW5hZ2VyLmdldFN0YXRlKCk7XHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cclxuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHtcclxuXHRcdFx0cHJvamVjdERldGVjdGlvbjogc3RhdGUucHJvamVjdERldGVjdGlvbixcclxuXHRcdFx0Y29udGVudFR5cGVzOiBzdGF0ZS5jb250ZW50VHlwZXMsXHJcblx0XHRcdGZyb250bWF0dGVyUHJvcGVydGllczogc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLFxyXG5cdFx0XHRkZWZhdWx0Q29udGVudFR5cGVJZDogc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQsXHJcblx0XHRcdHByZXNldDogc3RhdGUucHJlc2V0LFxyXG5cdFx0XHRlbmFibGVXWVNJV1lHOiBzdGF0ZS5lbmFibGVXWVNJV1lHLFxyXG5cdFx0XHRlbmFibGVkUGx1Z2luczogc3RhdGUuZW5hYmxlZFBsdWdpbnMsXHJcblx0XHRcdGRpc2FibGVkUGx1Z2luczogc3RhdGUuZGlzYWJsZWRQbHVnaW5zLFxyXG5cdFx0XHR0aGVtZTogc3RhdGUudGhlbWUsXHJcblx0XHRcdGJhc2VzQ01TQ29uZmlnOiBzdGF0ZS5iYXNlc0NNU0NvbmZpZyxcclxuXHRcdFx0YXN0cm9Db21wb3NlckNvbmZpZzogc3RhdGUuYXN0cm9Db21wb3NlckNvbmZpZyxcclxuXHRcdFx0c2VvQ29uZmlnOiBzdGF0ZS5zZW9Db25maWcsXHJcblx0XHRcdGNvbW1hbmRlckNvbmZpZzogc3RhdGUuY29tbWFuZGVyQ29uZmlnLFxyXG5cdFx0XHRwcm9wZXJ0eU92ZXJGaWxlTmFtZTogc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUsXHJcblx0XHRcdGltYWdlSW5zZXJ0ZXI6IHN0YXRlLmltYWdlSW5zZXJ0ZXIsXHJcblx0XHRcdGltYWdlTWFuYWdlcjogc3RhdGUuaW1hZ2VNYW5hZ2VyLFxyXG5cdFx0XHRob21lQmFzZTogc3RhdGUuaG9tZUJhc2VcclxuXHRcdH0pKTtcclxuXHR9XHJcblx0XHJcblx0cHJpdmF0ZSBoYXNTZXR0aW5nc0NoYW5nZWQoKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoIXRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRjb25zdCBjdXJyZW50U25hcHNob3QgPSB0aGlzLmNyZWF0ZVNldHRpbmdzU25hcHNob3QoKTtcclxuXHRcdFxyXG5cdFx0Ly8gQ29tcGFyZSBrZXkgc2V0dGluZ3MgdGhhdCBjYW4gYmUgY2hhbmdlZCBpbiB0aGUgd2l6YXJkXHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QucHJvamVjdERldGVjdGlvbikgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QucHJvamVjdERldGVjdGlvbikgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmNvbnRlbnRUeXBlcykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuY29udGVudFR5cGVzKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3QuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5mcm9udG1hdHRlclByb3BlcnRpZXMpIHx8XHJcblx0XHRcdGN1cnJlbnRTbmFwc2hvdC5kZWZhdWx0Q29udGVudFR5cGVJZCAhPT0gdGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5kZWZhdWx0Q29udGVudFR5cGVJZCB8fFxyXG5cdFx0XHRjdXJyZW50U25hcHNob3QucHJlc2V0ICE9PSB0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LnByZXNldCB8fFxyXG5cdFx0XHRjdXJyZW50U25hcHNob3QuZW5hYmxlV1lTSVdZRyAhPT0gdGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5lbmFibGVXWVNJV1lHIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5lbmFibGVkUGx1Z2lucykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuZW5hYmxlZFBsdWdpbnMpIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5kaXNhYmxlZFBsdWdpbnMpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmRpc2FibGVkUGx1Z2lucykgfHxcclxuXHRcdFx0Y3VycmVudFNuYXBzaG90LnRoZW1lICE9PSB0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LnRoZW1lIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5iYXNlc0NNU0NvbmZpZykgIT09IEpTT04uc3RyaW5naWZ5KHRoaXMuaW5pdGlhbFNldHRpbmdzU25hcHNob3QuYmFzZXNDTVNDb25maWcpIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5hc3Ryb0NvbXBvc2VyQ29uZmlnKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5hc3Ryb0NvbXBvc2VyQ29uZmlnKSB8fFxyXG5cdFx0XHRKU09OLnN0cmluZ2lmeShjdXJyZW50U25hcHNob3Quc2VvQ29uZmlnKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5zZW9Db25maWcpIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5jb21tYW5kZXJDb25maWcpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmNvbW1hbmRlckNvbmZpZykgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LnByb3BlcnR5T3ZlckZpbGVOYW1lKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5wcm9wZXJ0eU92ZXJGaWxlTmFtZSkgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmltYWdlSW5zZXJ0ZXIpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmltYWdlSW5zZXJ0ZXIpIHx8XHJcblx0XHRcdEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTbmFwc2hvdC5pbWFnZU1hbmFnZXIpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmluaXRpYWxTZXR0aW5nc1NuYXBzaG90LmltYWdlTWFuYWdlcikgfHxcclxuXHRcdFx0SlNPTi5zdHJpbmdpZnkoY3VycmVudFNuYXBzaG90LmhvbWVCYXNlKSAhPT0gSlNPTi5zdHJpbmdpZnkodGhpcy5pbml0aWFsU2V0dGluZ3NTbmFwc2hvdC5ob21lQmFzZSlcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRnZXRTdGF0ZSgpOiBXaXphcmRTdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuZ2V0U3RhdGUoKTtcclxuXHR9XHJcblxyXG5cdC8vIENhbGxiYWNrIHRvIHNhdmUgc3RhdGUgdG8gcGx1Z2luIHNldHRpbmdzIChrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxyXG5cdHNldFNhdmVDYWxsYmFjayhjYWxsYmFjazogKHN0YXRlOiBXaXphcmRTdGF0ZSkgPT4gUHJvbWlzZTx2b2lkPikge1xyXG5cdFx0Ly8gVGhpcyBpcyBub3cgaGFuZGxlZCBieSBzYXZlQ3VycmVudFN0ZXBUb1dpemFyZFN0YXRlIGFuZCBzYXZlV2l6YXJkU3RhdGVUb0RhdGFKc29uXHJcblx0XHQvLyBCdXQgd2Uga2VlcCB0aGUgbWV0aG9kIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XHJcblx0XHRjb25zb2xlLndhcm4oJ3NldFNhdmVDYWxsYmFjayBpcyBkZXByZWNhdGVkIC0gc3RhdGUgaXMgbm93IG1hbmFnZWQgYXV0b21hdGljYWxseScpO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgSW1hZ2VNYW5hZ2VyQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxudHlwZSBJbWFnZU1hbmFnZXJQbHVnaW4gPSB7XHJcblx0c2V0dGluZ3M/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59O1xyXG5cclxudHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBJbWFnZU1hbmFnZXJQbHVnaW4+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEltYWdlTWFuYWdlckNvbmZpZ3VyYXRvciB7XHJcblx0cHJpdmF0ZSBhcHA6IEFwcDtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgbG9hZENvbmZpZygpOiBQcm9taXNlPEltYWdlTWFuYWdlckNvbmZpZz4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaW1hZ2UtbWFuYWdlcic7XHJcblx0XHRcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIFRyeSB0byB1c2UgcGx1Z2luJ3Mgc2V0dGluZ3MgQVBJIGZpcnN0XHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBpbWFnZU1hbmFnZXJQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGltYWdlTWFuYWdlclBsdWdpbiAmJiBpbWFnZU1hbmFnZXJQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHQvLyBSZXR1cm4gcGx1Z2luIHNldHRpbmdzIGFzIGNvbmZpZ1xyXG5cdFx0XHRcdHJldHVybiBpbWFnZU1hbmFnZXJQbHVnaW4uc2V0dGluZ3MgYXMgSW1hZ2VNYW5hZ2VyQ29uZmlnO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEltYWdlIE1hbmFnZXIgY29uZmlnIGZyb20gcGx1Z2luIEFQSTonLCBlcnJvcik7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXHJcblx0XHRyZXR1cm4gYXdhaXQgdGhpcy5sb2FkQ29uZmlnRmFsbGJhY2soKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgbG9hZENvbmZpZ0ZhbGxiYWNrKCk6IFByb21pc2U8SW1hZ2VNYW5hZ2VyQ29uZmlnPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbWFnZS1tYW5hZ2VyJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblx0XHRcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZ0RhdGEgYXMgSW1hZ2VNYW5hZ2VyQ29uZmlnO1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIEltYWdlIE1hbmFnZXIgZGF0YS5qc29uOicsIGVycm9yKTtcclxuXHRcdFx0XHRyZXR1cm4ge307XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHt9O1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZUNvbmZpZyhjb25maWc6IEltYWdlTWFuYWdlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaW1hZ2UtbWFuYWdlcic7XHJcblx0XHRcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIFRyeSB0byB1c2UgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZCBmaXJzdCAobGlrZSBBc3RybyBDb21wb3NlcilcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IGltYWdlTWFuYWdlclBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LltwbHVnaW5JZF07XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoaW1hZ2VNYW5hZ2VyUGx1Z2luICYmIGltYWdlTWFuYWdlclBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdC8vIFVwZGF0ZSB2aWEgcGx1Z2luIHNldHRpbmdzIEFQSSAobWF0Y2hpbmcgYXN0cm8tbW9kdWxhci1zZXR0aW5ncyBwYXR0ZXJuKVxyXG5cdFx0XHRcdGNvbnN0IHBsdWdpblNldHRpbmdzID0gaW1hZ2VNYW5hZ2VyUGx1Z2luLnNldHRpbmdzO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIHBsdWdpbiBzZXR0aW5nc1xyXG5cdFx0XHRcdE9iamVjdC5hc3NpZ24ocGx1Z2luU2V0dGluZ3MsIGNvbmZpZyk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBpbWFnZU1hbmFnZXJQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBpbWFnZU1hbmFnZXJQbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdJbWFnZU1hbmFnZXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZCAobGlrZSBBc3RybyBDb21wb3NlciBmYWxsYmFjaylcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEltYWdlIE1hbmFnZXIgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gVHJ5IGZhbGxiYWNrIGV2ZW4gaWYgcGx1Z2luIG1ldGhvZCBmYWlsc1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHRcdH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBJbWFnZSBNYW5hZ2VyIGNvbmZpZyB2aWEgZmFsbGJhY2s6JywgZmFsbGJhY2tFcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogSW1hZ2VNYW5hZ2VyQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbWFnZS1tYW5hZ2VyJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblx0XHRcclxuXHRcdGxldCBleGlzdGluZ0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XHJcblx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcclxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgZGF0YSBpZiBmaWxlIGV4aXN0c1xyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBJbWFnZSBNYW5hZ2VyIGRhdGEuanNvbiwgc3RhcnRpbmcgZnJlc2g6JywgZXJyb3IpO1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IHt9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIGV4aXN0aW5nIGRhdGEgKHByZXNlcnZpbmcgZXhpc3Rpbmcgc2V0dGluZ3Mgbm90IGluIGNvbmZpZylcclxuXHRcdGNvbnN0IG1lcmdlZERhdGEgPSB7XHJcblx0XHRcdC4uLmV4aXN0aW5nRGF0YSxcclxuXHRcdFx0Li4uY29uZmlnXHJcblx0XHR9O1xyXG5cdFx0XHJcblx0XHQvLyBUcnkgdG8gbW9kaWZ5IGZpcnN0LCBpZiBmaWxlIGRvZXNuJ3QgZXhpc3QgaXQgd2lsbCB0aHJvdywgdGhlbiB3ZSBjcmVhdGVcclxuXHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gRW5zdXJlIHBsdWdpbiBkaXJlY3RvcnkgZXhpc3RzXHJcblx0XHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdFx0aWYgKCFwbHVnaW5EaXJGaWxlKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0XHQvLyBJZ25vcmUgXCJhbHJlYWR5IGV4aXN0c1wiIGVycm9yc1xyXG5cdFx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG5cdFx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaWxlXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Ly8gSWYgZmlsZSB3YXMgY3JlYXRlZCBiZXR3ZWVuIGNoZWNrIGFuZCBjcmVhdGUsIHRyeSB0byBtb2RpZnkgaXRcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpIHx8IGVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcmV0cnlGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0XHRcdGlmIChyZXRyeUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkocmV0cnlGaWxlLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBIb21lQmFzZUNvbmZpZyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbnR5cGUgSG9tZUJhc2VQbHVnaW4gPSB7XHJcblx0c2V0dGluZ3M/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59O1xyXG5cclxudHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBIb21lQmFzZVBsdWdpbj47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgSG9tZUJhc2VDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRDb25maWcoKTogUHJvbWlzZTxIb21lQmFzZUNvbmZpZz4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzZXR0aW5ncyBBUEkgZmlyc3RcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IGhvbWVCYXNlUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChob21lQmFzZVBsdWdpbiAmJiBob21lQmFzZVBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdC8vIFJldHVybiBwbHVnaW4gc2V0dGluZ3MgYXMgY29uZmlnXHJcblx0XHRcdFx0cmV0dXJuIGhvbWVCYXNlUGx1Z2luLnNldHRpbmdzIGFzIEhvbWVCYXNlQ29uZmlnO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEhvbWUgQmFzZSBjb25maWcgZnJvbSBwbHVnaW4gQVBJOicsIGVycm9yKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdHJldHVybiBhd2FpdCB0aGlzLmxvYWRDb25maWdGYWxsYmFjaygpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBsb2FkQ29uZmlnRmFsbGJhY2soKTogUHJvbWlzZTxIb21lQmFzZUNvbmZpZz4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblx0XHRcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZ0RhdGEgYXMgSG9tZUJhc2VDb25maWc7XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZXhpc3RpbmcgSG9tZSBCYXNlIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdFx0cmV0dXJuIHt9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiB7fTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoY29uZmlnOiBIb21lQmFzZUNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyKVxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc3QgaG9tZUJhc2VQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGhvbWVCYXNlUGx1Z2luICYmIGhvbWVCYXNlUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Ly8gVXBkYXRlIHZpYSBwbHVnaW4gc2V0dGluZ3MgQVBJIChtYXRjaGluZyBhc3Ryby1tb2R1bGFyLXNldHRpbmdzIHBhdHRlcm4pXHJcblx0XHRcdFx0Y29uc3QgcGx1Z2luU2V0dGluZ3MgPSBob21lQmFzZVBsdWdpbi5zZXR0aW5ncztcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBNZXJnZSBjb25maWcgaW50byBwbHVnaW4gc2V0dGluZ3NcclxuXHRcdFx0XHRPYmplY3QuYXNzaWduKHBsdWdpblNldHRpbmdzLCBjb25maWcpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmICh0eXBlb2YgaG9tZUJhc2VQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBob21lQmFzZVBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0hvbWVCYXNlQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2QgKGxpa2UgQXN0cm8gQ29tcG9zZXIgZmFsbGJhY2spXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBIb21lIEJhc2UgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gVHJ5IGZhbGxiYWNrIGV2ZW4gaWYgcGx1Z2luIG1ldGhvZCBmYWlsc1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHRcdH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBIb21lIEJhc2UgY29uZmlnIHZpYSBmYWxsYmFjazonLCBmYWxsYmFja0Vycm9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnOiBIb21lQmFzZUNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnaG9tZS1iYXNlJztcclxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdGNvbnN0IHBsdWdpbkRhdGFQYXRoID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9L2RhdGEuanNvbmA7XHJcblx0XHRcclxuXHRcdGxldCBleGlzdGluZ0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XHJcblx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcclxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgZGF0YSBpZiBmaWxlIGV4aXN0c1xyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBIb21lIEJhc2UgZGF0YS5qc29uLCBzdGFydGluZyBmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0ge307XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gTWVyZ2UgY29uZmlnIGludG8gZXhpc3RpbmcgZGF0YSAocHJlc2VydmluZyBleGlzdGluZyBzZXR0aW5ncyBub3QgaW4gY29uZmlnKVxyXG5cdFx0Y29uc3QgbWVyZ2VkRGF0YSA9IHtcclxuXHRcdFx0Li4uZXhpc3RpbmdEYXRhLFxyXG5cdFx0XHQuLi5jb25maWdcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdC8vIFRyeSB0byBtb2RpZnkgZmlyc3QsIGlmIGZpbGUgZG9lc24ndCBleGlzdCBpdCB3aWxsIHRocm93LCB0aGVuIHdlIGNyZWF0ZVxyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EaXIpO1xyXG5cdFx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKHBsdWdpbkRpcik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZSBcImFscmVhZHkgZXhpc3RzXCIgZXJyb3JzXHJcblx0XHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbGVcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHQvLyBJZiBmaWxlIHdhcyBjcmVhdGVkIGJldHdlZW4gY2hlY2sgYW5kIGNyZWF0ZSwgdHJ5IHRvIG1vZGlmeSBpdFxyXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgfHwgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpKSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRcdFx0aWYgKHJldHJ5RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShyZXRyeUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IEV4cGxvcmVyRm9jdXNDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG50eXBlIFBsdWdpbldpdGhTZXR0aW5ncyA9IHtcclxuXHRzZXR0aW5ncz86IEV4cGxvcmVyRm9jdXNDb25maWc7XHJcblx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufTtcclxuXHJcbnR5cGUgUGx1Z2luc0FQSSA9IHtcclxuXHRwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgUGx1Z2luV2l0aFNldHRpbmdzPjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBFeHBsb3JlckZvY3VzQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlQ29uZmlnKGNvbmZpZzogRXhwbG9yZXJGb2N1c0NvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnZXhwbG9yZXItZm9jdXMnO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIGxpdmUgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBleHBsb3JlckZvY3VzUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChleHBsb3JlckZvY3VzUGx1Z2luICYmIGV4cGxvcmVyRm9jdXNQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdFeHBsb3JlckZvY3VzQ29uZmlnOiBVc2luZyBwbHVnaW4uc2V0dGluZ3MgQVBJJyk7XHJcblx0XHRcdFx0Y29uc3Qgc2V0dGluZ3MgPSBleHBsb3JlckZvY3VzUGx1Z2luLnNldHRpbmdzO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEFwcGx5IGNvbmZpZyB0byBsaXZlIHNldHRpbmdzXHJcblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnKSkge1xyXG5cdFx0XHRcdFx0KHNldHRpbmdzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXldID0gdmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFNhdmUgc2V0dGluZ3MgdmlhIHBsdWdpbiBBUElcclxuXHRcdFx0XHRpZiAodHlwZW9mIGV4cGxvcmVyRm9jdXNQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBleHBsb3JlckZvY3VzUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRXhwbG9yZXJGb2N1c0NvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kIGlmIHBsdWdpbiBub3QgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0V4cGxvcmVyRm9jdXNDb25maWc6IFBsdWdpbiBBUEkgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2sgZmlsZSBtZXRob2QnKTtcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEV4cGxvcmVyIEZvY3VzIGNvbmZpZzonLCBlcnJvcik7XHJcblx0XHRcdC8vIFRyeSBmYWxsYmFjayBhbnl3YXlcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGxvYWRDb25maWcoKTogUHJvbWlzZTxFeHBsb3JlckZvY3VzQ29uZmlnIHwgbnVsbD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnZXhwbG9yZXItZm9jdXMnO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKTtcclxuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZShjb250ZW50KSBhcyBFeHBsb3JlckZvY3VzQ29uZmlnO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEV4cGxvcmVyIEZvY3VzIGNvbmZpZzonLCBlcnJvcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogRXhwbG9yZXJGb2N1c0NvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnZXhwbG9yZXItZm9jdXMnO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBleHBsb3Jlci1mb2N1cyBkYXRhLmpzb246JywgZXJyb3IpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTWVyZ2Ugd2l0aCBvdXIgY29uZmlnXHJcblx0XHRjb25zdCBtZXJnZWREYXRhID0ge1xyXG5cdFx0XHQuLi5leGlzdGluZ0RhdGEsXHJcblx0XHRcdC4uLmNvbmZpZ1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRjb25zdCBwbHVnaW5EaXJGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcblx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGb2xkZXIgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2F2ZSB0byBmaWxlXHJcblx0XHRjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMik7XHJcblx0XHRpZiAoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIGNvbnRlbnQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdGNvbnNvbGUuZGVidWcoJ0V4cGxvcmVyRm9jdXNDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCBleHBsb3Jlci1mb2N1cyBjb25maWcgdmlhIGZhbGxiYWNrJyk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBDb21tYW5kZXJDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG50eXBlIEVkaXRpbmdUb29sYmFyUGx1Z2luID0ge1xyXG5cdGVuYWJsZWQ/OiBib29sZWFuO1xyXG5cdHNldHRpbmdzPzoge1xyXG5cdFx0Y01lbnVWaXNpYmlsaXR5PzogYm9vbGVhbjtcclxuXHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XHJcblx0fTtcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG5cdGxvYWRTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcblx0cmVmcmVzaD86ICgpID0+IHZvaWQ7XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIEVkaXRpbmdUb29sYmFyUGx1Z2luPjtcclxuXHRlbmFibGVQbHVnaW4/OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuXHRkaXNhYmxlUGx1Z2luPzogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgQ29tbWFuZGVyQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZUNvbW1hbmRlckNvbmZpZyhlbmFibGVXWVNJV1lHOiBib29sZWFuKTogQ29tbWFuZGVyQ29uZmlnIHtcclxuXHRcdC8vIFdZU0lXWUcgaXMgbm93IGhhbmRsZWQgYnkgdG9nZ2xpbmcgdGhlIGNvbW1hbmQgZGlyZWN0bHksIG5vdCB2aWEgY29tbWFuZGVyXHJcblx0XHQvLyBUaGlzIGNvbmZpZyBpcyBrZXB0IGZvciBjb21wYXRpYmlsaXR5IGJ1dCB3b24ndCBhZGQgY29tbWFuZGVyIGJ1dHRvbnNcclxuXHRcdGNvbnN0IGNvbmZpZzogQ29tbWFuZGVyQ29uZmlnID0ge1xyXG5cdFx0XHRwYWdlSGVhZGVyQ29tbWFuZHM6IFtdXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBjb25maWc7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbmFibGUvZGlzYWJsZSB0aGUgZWRpdGluZyB0b29sYmFyIHBsdWdpbiAobm90IHZpYSBjb21tYW5kZXIgYnV0dG9uKVxyXG5cdCAqIFdoZW4gZW5hYmxlZCwgdGhlIHRvb2xiYXIgd2lsbCBiZSBhdmFpbGFibGUgdmlhIGl0cyBvd24gXCJTaG93L2hpZGUgdG9vbGJhclwiIGNvbW1hbmRcclxuXHQgKi9cclxuXHRhc3luYyB0b2dnbGVFZGl0aW5nVG9vbGJhckNvbW1hbmQoYXBwOiBBcHAsIGVuYWJsZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc29sZS5kZWJ1ZyhgQ29tbWFuZGVyQ29uZmlnOiB0b2dnbGVFZGl0aW5nVG9vbGJhckNvbW1hbmQgY2FsbGVkIHdpdGggZW5hYmxlPSR7ZW5hYmxlfWApO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9IChhcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRpZiAoIXBsdWdpbnMpIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0NvbW1hbmRlckNvbmZpZzogUGx1Z2lucyBBUEkgbm90IGF2YWlsYWJsZScpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZWRpdGluZ1Rvb2xiYXJQbHVnaW4gPSBwbHVnaW5zLnBsdWdpbnM/LlsnZWRpdGluZy10b29sYmFyJ107XHJcblx0XHRcdGlmICghZWRpdGluZ1Rvb2xiYXJQbHVnaW4pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0NvbW1hbmRlckNvbmZpZzogRWRpdGluZyBUb29sYmFyIHBsdWdpbiBub3QgZm91bmQnKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoYENvbW1hbmRlckNvbmZpZzogRWRpdGluZyBUb29sYmFyIHBsdWdpbiBmb3VuZCwgZW5hYmxlZD0ke2VkaXRpbmdUb29sYmFyUGx1Z2luLmVuYWJsZWR9YCk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoYENvbW1hbmRlckNvbmZpZzogUGx1Z2luIHNldHRpbmdzIGF2YWlsYWJsZTpgLCAhIWVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzKTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChlZGl0aW5nVG9vbGJhclBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYENvbW1hbmRlckNvbmZpZzogQ3VycmVudCBjTWVudVZpc2liaWxpdHk6YCwgZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MuY01lbnVWaXNpYmlsaXR5KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyKVxyXG5cdFx0XHRpZiAoZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MgJiYgdHlwZW9mIGVkaXRpbmdUb29sYmFyUGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbW1hbmRlckNvbmZpZzogVXNpbmcgcGx1Z2luLnNhdmVTZXR0aW5ncygpIG1ldGhvZCcpO1xyXG5cdFx0XHRcdC8vIFVwZGF0ZSBjTWVudVZpc2liaWxpdHkgdmlhIHBsdWdpbiBzZXR0aW5ncyBBUElcclxuXHRcdFx0XHRjb25zdCBvbGRWYWx1ZSA9IGVkaXRpbmdUb29sYmFyUGx1Z2luLnNldHRpbmdzLmNNZW51VmlzaWJpbGl0eTtcclxuXHRcdFx0XHRlZGl0aW5nVG9vbGJhclBsdWdpbi5zZXR0aW5ncy5jTWVudVZpc2liaWxpdHkgPSBlbmFibGU7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgQ29tbWFuZGVyQ29uZmlnOiBTZXQgY01lbnVWaXNpYmlsaXR5IGZyb20gJHtvbGRWYWx1ZX0gdG8gJHtlbmFibGV9YCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0YXdhaXQgZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2F2ZVNldHRpbmdzKCk7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29tbWFuZGVyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgZWRpdGluZy10b29sYmFyIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBEaXNwYXRjaCB0aGUgZXZlbnQgdGhhdCBlZGl0aW5nLXRvb2xiYXIgbGlzdGVucyBmb3IgdG8gdHJpZ2dlciBhIHJlYnVpbGRcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdDb21tYW5kZXJDb25maWc6IERpc3BhdGNoaW5nIGVkaXRpbmdUb29sYmFyLU5ld0NvbW1hbmQgZXZlbnQnKTtcclxuXHRcdFx0XHR3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJlZGl0aW5nVG9vbGJhci1OZXdDb21tYW5kXCIpKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBJZiBlbmFibGluZywgd2UgbmVlZCB0byByZWxvYWQgdGhlIHBsdWdpbiBvciB0cmlnZ2VyIGEgcmVmcmVzaFxyXG5cdFx0XHRcdC8vIFRoZSBjb21tYW5kIGV4ZWN1dGlvbiBhbG9uZSBtYXkgbm90IGJlIGVub3VnaCAtIHRoZSBwbHVnaW4gbmVlZHMgdG8gcmVhZCB0aGUgbmV3IHNldHRpbmdzXHJcblx0XHRcdFx0aWYgKGVuYWJsZSkge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29tbWFuZGVyQ29uZmlnOiBXYWl0aW5nIGZvciBzZXR0aW5ncyB0byBwZXJzaXN0Li4uJyk7XHJcblx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vIFRyeSB0byByZWxvYWQgdGhlIHBsdWdpbidzIHNldHRpbmdzXHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIGVkaXRpbmdUb29sYmFyUGx1Z2luLmxvYWRTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdDb21tYW5kZXJDb25maWc6IFJlbG9hZGluZyBlZGl0aW5nIHRvb2xiYXIgcGx1Z2luIHNldHRpbmdzJyk7XHJcblx0XHRcdFx0XHRcdGF3YWl0IGVkaXRpbmdUb29sYmFyUGx1Z2luLmxvYWRTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvLyBBbHNvIHRyeSB0byB0cmlnZ2VyIGEgcmVmcmVzaCBpZiB0aGUgcGx1Z2luIGhhcyB0aGF0IG1ldGhvZFxyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBlZGl0aW5nVG9vbGJhclBsdWdpbi5yZWZyZXNoID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbW1hbmRlckNvbmZpZzogUmVmcmVzaGluZyBlZGl0aW5nIHRvb2xiYXIgcGx1Z2luJyk7XHJcblx0XHRcdFx0XHRcdGVkaXRpbmdUb29sYmFyUGx1Z2luLnJlZnJlc2goKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbW1hbmRlckNvbmZpZzogUGx1Z2luIHNhdmVTZXR0aW5ncyBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjaycpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZCAobGlrZSBBc3RybyBDb21wb3NlciBmYWxsYmFjaylcclxuXHRcdFx0YXdhaXQgdGhpcy50b2dnbGVFZGl0aW5nVG9vbGJhckNvbW1hbmRGYWxsYmFjayhhcHAsIGVuYWJsZSk7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb21tYW5kZXJDb25maWc6IEZhaWxlZCB0byB0b2dnbGUgZWRpdGluZyB0b29sYmFyIHBsdWdpbjonLCBlcnJvcik7XHJcblx0XHRcdC8vIFRyeSBmYWxsYmFjayBldmVuIGlmIHBsdWdpbiBtZXRob2QgZmFpbHNcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLnRvZ2dsZUVkaXRpbmdUb29sYmFyQ29tbWFuZEZhbGxiYWNrKGFwcCwgZW5hYmxlKTtcclxuXHRcdFx0fSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xyXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvbW1hbmRlckNvbmZpZzogRmFpbGVkIHRvIHRvZ2dsZSBlZGl0aW5nIHRvb2xiYXIgdmlhIGZhbGxiYWNrOicsIGZhbGxiYWNrRXJyb3IpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHRvZ2dsZUVkaXRpbmdUb29sYmFyQ29tbWFuZEZhbGxiYWNrKGFwcDogQXBwLCBlbmFibGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ2VkaXRpbmctdG9vbGJhcic7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSBhcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0Ly8gQWx3YXlzIHJlYWQgZXhpc3RpbmcgZGF0YSBmaXJzdCAoZmlsZSBsaWtlbHkgZXhpc3RzKVxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcclxuXHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCBhcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIGVkaXRpbmctdG9vbGJhciBkYXRhLmpzb24sIHN0YXJ0aW5nIGZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCBjTWVudVZpc2liaWxpdHlcclxuXHRcdGV4aXN0aW5nRGF0YS5jTWVudVZpc2liaWxpdHkgPSBlbmFibGU7XHJcblxyXG5cdFx0Ly8gQWx3YXlzIHRyeSB0byBtb2RpZnkgZmlyc3QgKGZpbGUgbGlrZWx5IGV4aXN0cylcclxuXHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdGF3YWl0IGFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdDb21tYW5kZXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCBlZGl0aW5nLXRvb2xiYXIgdmlhIGZpbGUgbW9kaWZ5Jyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBGaWxlIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxyXG5cdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdFx0aWYgKCFwbHVnaW5EaXJGaWxlKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGF3YWl0IGFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdFx0Ly8gSWdub3JlIFwiYWxyZWFkeSBleGlzdHNcIiBvciBcIkZvbGRlciBhbHJlYWR5IGV4aXN0c1wiIGVycm9yc1xyXG5cdFx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG5cdFx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGb2xkZXIgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIEZvbGRlciBleGlzdHMsIGNvbnRpbnVlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmlsZVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IGFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbW1hbmRlckNvbmZpZzogU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgZWRpdGluZy10b29sYmFyIGRhdGEuanNvbicpO1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdC8vIElmIGZpbGUgd2FzIGNyZWF0ZWQgYmV0d2VlbiBjaGVjayBhbmQgY3JlYXRlLCB0cnkgdG8gbW9kaWZ5IGl0XHJcblx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xyXG5cdFx0XHRcdGlmIChlcnJvck1lc3NhZ2UgJiYgKGVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSB8fCBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHJldHJ5RmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRcdFx0aWYgKHJldHJ5RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IGFwcC52YXVsdC5tb2RpZnkocmV0cnlGaWxlLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29tbWFuZGVyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgZWRpdGluZy10b29sYmFyIHZpYSByZXRyeSBtb2RpZnknKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIEZpbGUgZXhpc3RzIGJ1dCBjYW4ndCBiZSBmb3VuZCAtIHJldHJ5IHdpdGggZGVsYXlcclxuXHRcdFx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xyXG5cdFx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGUyID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcdFx0XHRcdGlmIChyZXRyeUZpbGUyIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRcdFx0XHRhd2FpdCBhcHAudmF1bHQubW9kaWZ5KHJldHJ5RmlsZTIsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbW1hbmRlckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIGVkaXRpbmctdG9vbGJhciB2aWEgZGVsYXllZCByZXRyeSBtb2RpZnknKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gUmVtb3ZpbmcgdGhlIHRvZ2dsZSBjb21tYW5kIGV4ZWN1dGlvbiBhcyBzZXR0aW5nIGNNZW51VmlzaWJpbGl0eSB0byB0cnVlIFxyXG5cdFx0Ly8gaW4gZGF0YS5qc29uIHNob3VsZCBiZSBzdWZmaWNpZW50IGFuZCBwcmV2ZW50cyB0b2dnbGluZyBpdCBiYWNrIHRvIFxyXG5cdFx0Ly8gaGlkZGVuIGlmIGl0IHdhcyBhbHJlYWR5IHZpc2libGUuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgdmlzaWJpbGl0eSBvZiB0aGUgZWRpdGluZyB0b29sYmFyXHJcblx0ICovXHJcblx0YXN5bmMgZ2V0RWRpdGluZ1Rvb2xiYXJWaXNpYmlsaXR5KGFwcDogQXBwKTogUHJvbWlzZTxib29sZWFuIHwgdW5kZWZpbmVkPiB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKGFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IGVkaXRpbmdUb29sYmFyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uWydlZGl0aW5nLXRvb2xiYXInXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChlZGl0aW5nVG9vbGJhclBsdWdpbj8uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHRyZXR1cm4gZWRpdGluZ1Rvb2xiYXJQbHVnaW4uc2V0dGluZ3MuY01lbnVWaXNpYmlsaXR5O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZFxyXG5cdFx0XHRjb25zdCBjb25maWdEaXIgPSBhcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy9lZGl0aW5nLXRvb2xiYXIvZGF0YS5qc29uYDtcclxuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCBhcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIHsgY01lbnVWaXNpYmlsaXR5PzogYm9vbGVhbiB9O1xyXG5cdFx0XHRcdHJldHVybiBleGlzdGluZ0RhdGEuY01lbnVWaXNpYmlsaXR5O1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRjb25zb2xlLndhcm4oJ0NvbW1hbmRlckNvbmZpZzogRmFpbGVkIHRvIGdldCBlZGl0aW5nIHRvb2xiYXIgdmlzaWJpbGl0eTonLCBlcnJvcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgc2F2ZUNvbmZpZyhjb25maWc6IENvbW1hbmRlckNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnY21kcic7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKSkgYXMgeyBwYWdlSGVhZGVyPzogQXJyYXk8eyBpZD86IHN0cmluZzsgW2tleTogc3RyaW5nXTogdW5rbm93biB9PjsgW2tleTogc3RyaW5nXTogdW5rbm93biB9O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIE1lcmdlIHBhZ2VIZWFkZXIgY29tbWFuZHNcclxuXHRcdFx0XHRjb25zdCBleGlzdGluZ1BhZ2VIZWFkZXIgPSBleGlzdGluZ0RhdGEucGFnZUhlYWRlciB8fCBbXTtcclxuXHRcdFx0XHRjb25zdCB0b29sYmFyQ29tbWFuZCA9IHtcclxuXHRcdFx0XHRcdGlkOiAnZWRpdGluZy10b29sYmFyOmhpZGUtc2hvdy1tZW51JyxcclxuXHRcdFx0XHRcdGljb246ICdsdWNpZGUtY2hldnJvbnMtdXAtZG93bicsXHJcblx0XHRcdFx0XHRuYW1lOiAnVG9nZ2xlIGVkaXRpbmcgdG9vbGJhcicsXHJcblx0XHRcdFx0XHRtb2RlOiAnZGVza3RvcCdcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHQvLyBSZW1vdmUgZXhpc3RpbmcgdG9vbGJhciBjb21tYW5kIGlmIHByZXNlbnRcclxuXHRcdFx0XHRjb25zdCBmaWx0ZXJlZFBhZ2VIZWFkZXIgPSBleGlzdGluZ1BhZ2VIZWFkZXIuZmlsdGVyKFxyXG5cdFx0XHRcdFx0KGNtZDogeyBpZD86IHN0cmluZyB9KSA9PiBjbWQuaWQgIT09ICdlZGl0aW5nLXRvb2xiYXI6aGlkZS1zaG93LW1lbnUnXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0Ly8gQWRkIHRvb2xiYXIgY29tbWFuZCBpZiBlbmFibGVkXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5wYWdlSGVhZGVyQ29tbWFuZHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0ZmlsdGVyZWRQYWdlSGVhZGVyLnB1c2godG9vbGJhckNvbW1hbmQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgbWVyZ2VkRGF0YSA9IHtcclxuXHRcdFx0XHRcdC4uLmV4aXN0aW5nRGF0YSxcclxuXHRcdFx0XHRcdHBhZ2VIZWFkZXI6IGZpbHRlcmVkUGFnZUhlYWRlclxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSwgbnVsbCwgMikpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBDb21tYW5kZXIgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBWYXVsdENNU1NldHRpbmdzIH0gZnJvbSAnLi4vLi4vc2V0dGluZ3MnO1xyXG5pbXBvcnQgVmF1bHRDTVNQbHVnaW4gZnJvbSAnLi4vLi4vbWFpbic7XHJcbmltcG9ydCB7IEltYWdlTWFuYWdlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0ltYWdlTWFuYWdlckNvbmZpZyc7XHJcbmltcG9ydCB7IEhvbWVCYXNlQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvSG9tZUJhc2VDb25maWcnO1xyXG5pbXBvcnQgeyBFeHBsb3JlckZvY3VzQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvRXhwbG9yZXJGb2N1c0NvbmZpZyc7XHJcbmltcG9ydCB7IENvbW1hbmRlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbW1hbmRlckNvbmZpZyc7XHJcblxyXG5leHBvcnQgY2xhc3MgV2l6YXJkU3RhdGVNYW5hZ2VyIHtcclxuXHRwcml2YXRlIHN0YXRlOiBXaXphcmRTdGF0ZTtcclxuXHRwcml2YXRlIHBsdWdpbjogUGx1Z2luO1xyXG5cdHByaXZhdGUgY29tbWFuZGVyQ29uZmlndXJhdG9yOiBDb21tYW5kZXJDb25maWd1cmF0b3I7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBsdWdpbjogUGx1Z2luKSB7XHJcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcclxuXHRcdHRoaXMuY29tbWFuZGVyQ29uZmlndXJhdG9yID0gbmV3IENvbW1hbmRlckNvbmZpZ3VyYXRvcihwbHVnaW4uYXBwKTtcclxuXHRcdGNvbnN0IHNldHRpbmdzID0gKHBsdWdpbiBhcyBWYXVsdENNU1BsdWdpbikuc2V0dGluZ3M7XHJcblx0XHR0aGlzLnN0YXRlID0gdGhpcy5pbml0aWFsaXplU3RhdGUoc2V0dGluZ3MpO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpbml0aWFsaXplU3RhdGUoc2V0dGluZ3M6IFZhdWx0Q01TU2V0dGluZ3MpOiBXaXphcmRTdGF0ZSB7XHJcblx0XHQvLyBJbml0aWFsaXplIHByb2plY3QgZGV0ZWN0aW9uIGZyb20gc2F2ZWQgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXHJcblx0XHRjb25zdCBzYXZlZFByb2plY3REZXRlY3Rpb24gPSBzZXR0aW5ncy5wcm9qZWN0Um9vdCAmJiBzZXR0aW5ncy5jb25maWdGaWxlUGF0aCA/IHtcclxuXHRcdFx0cHJvamVjdFJvb3Q6IHNldHRpbmdzLnByb2plY3RSb290LFxyXG5cdFx0XHRjb25maWdGaWxlUGF0aDogc2V0dGluZ3MuY29uZmlnRmlsZVBhdGgsXHJcblx0XHRcdHZhdWx0TG9jYXRpb246ICdjb250ZW50JyBhcyBjb25zdFxyXG5cdFx0fSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHQvLyBUcnkgdG8gaW5mZXIgYXR0YWNobWVudCBzZXR0aW5ncyBmcm9tIE9ic2lkaWFuIGlmIG5vdCBleHBsaWNpdGx5IHNhdmVkIGluIG91ciBzZXR0aW5nc1xyXG5cdFx0bGV0IGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSBzZXR0aW5ncy5hdHRhY2htZW50SGFuZGxpbmdNb2RlO1xyXG5cdFx0bGV0IGF0dGFjaG1lbnRGb2xkZXJOYW1lID0gc2V0dGluZ3MuYXR0YWNobWVudEZvbGRlck5hbWU7XHJcblxyXG5cdFx0aWYgKCFhdHRhY2htZW50SGFuZGxpbmdNb2RlKSB7XHJcblx0XHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0IGFzIHsgY29uZmlnPzogeyBuZXdGaWxlTG9jYXRpb24/OiBzdHJpbmc7IG5ld0ZpbGVGb2xkZXJQYXRoPzogc3RyaW5nOyBhdHRhY2htZW50Rm9sZGVyUGF0aD86IHN0cmluZzsgbmV3TGlua0Zvcm1hdD86IHN0cmluZyB9IH07XHJcblx0XHRcdGNvbnN0IG9ic2lkaWFuQ29uZmlnID0gdmF1bHQuY29uZmlnO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKG9ic2lkaWFuQ29uZmlnPy5hdHRhY2htZW50Rm9sZGVyUGF0aCkge1xyXG5cdFx0XHRcdGNvbnN0IGZvbGRlclBhdGggPSBvYnNpZGlhbkNvbmZpZy5hdHRhY2htZW50Rm9sZGVyUGF0aDtcclxuXHRcdFx0XHRpZiAoZm9sZGVyUGF0aCA9PT0gJy4vJykge1xyXG5cdFx0XHRcdFx0YXR0YWNobWVudEhhbmRsaW5nTW9kZSA9ICdzYW1lLWZvbGRlcic7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChmb2xkZXJQYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuXHRcdFx0XHRcdGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc3ViZm9sZGVyJztcclxuXHRcdFx0XHRcdGF0dGFjaG1lbnRGb2xkZXJOYW1lID0gZm9sZGVyUGF0aC5zdWJzdHJpbmcoMik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc3BlY2lmaWVkLWZvbGRlcic7XHJcblx0XHRcdFx0XHRhdHRhY2htZW50Rm9sZGVyTmFtZSA9IGZvbGRlclBhdGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y3VycmVudFN0ZXA6IDAsXHJcblx0XHRcdHByb2plY3REZXRlY3Rpb246IHNhdmVkUHJvamVjdERldGVjdGlvbixcclxuXHRcdFx0Y29udGVudFR5cGVzOiBzZXR0aW5ncy5jb250ZW50VHlwZXMgfHwgW10sXHJcblx0XHRcdGZyb250bWF0dGVyUHJvcGVydGllczogc2V0dGluZ3MuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIHx8IHt9LFxyXG5cdFx0XHRkZWZhdWx0Q29udGVudFR5cGVJZDogc2V0dGluZ3MuZGVmYXVsdENvbnRlbnRUeXBlSWQsXHJcblx0XHRcdGF0dGFjaG1lbnRIYW5kbGluZ01vZGU6IGF0dGFjaG1lbnRIYW5kbGluZ01vZGUgfHwgJ3N1YmZvbGRlcicsXHJcblx0XHRcdGF0dGFjaG1lbnRGb2xkZXJOYW1lOiBhdHRhY2htZW50Rm9sZGVyTmFtZSxcclxuXHRcdFx0cHJlc2V0OiBzZXR0aW5ncy5wcmVzZXQgfHwgJ3ZhbmlsbGEnLFxyXG5cdFx0XHRwcmVzZXROYW1lOiBzZXR0aW5ncy5wcmVzZXROYW1lIHx8ICcnLFxyXG5cdFx0XHRwcmVzZXRzUmVwbzogc2V0dGluZ3MucHJlc2V0c1JlcG8gfHwgJ2RhdmlkdmtpbWJhbGwvdmF1bHQtY21zLXByZXNldHMnLFxyXG5cdFx0XHRlbmFibGVXWVNJV1lHOiBzZXR0aW5ncy5lbmFibGVXWVNJV1lHID8/IGZhbHNlLFxyXG5cdFx0XHRlbmFibGVNZHhTdXBwb3J0OiBzZXR0aW5ncy5lbmFibGVNZHhTdXBwb3J0LFxyXG5cdFx0XHRlbmFibGVkUGx1Z2luczogc2V0dGluZ3MuZW5hYmxlZFBsdWdpbnMgfHwgW10sXHJcblx0XHRcdGRpc2FibGVkUGx1Z2luczogc2V0dGluZ3MuZGlzYWJsZWRQbHVnaW5zIHx8IFtdLFxyXG5cdFx0XHR0aGVtZTogc2V0dGluZ3MudGhlbWUgfHwgJycsXHJcblx0XHRcdGJhc2VzQ01TQ29uZmlnOiBzZXR0aW5ncy5iYXNlc0NNU0NvbmZpZyB8fCB7IHZpZXdzOiBbXSB9LFxyXG5cdFx0XHRhc3Ryb0NvbXBvc2VyQ29uZmlnOiBzZXR0aW5ncy5hc3Ryb0NvbXBvc2VyQ29uZmlnIHx8IHtcclxuXHRcdFx0XHRjdXN0b21Db250ZW50VHlwZXM6IFtdLFxyXG5cdFx0XHRcdGRlZmF1bHRUZW1wbGF0ZTogJycsXHJcblx0XHRcdFx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdFx0XHRcdHRlcm1pbmFsUHJvamVjdFJvb3RQYXRoOiAnJ1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRzZW9Db25maWc6IHNldHRpbmdzLnNlb0NvbmZpZyB8fCB7XHJcblx0XHRcdFx0dGl0bGVQcm9wZXJ0eTogJ3RpdGxlJyxcclxuXHRcdFx0XHRzY2FuRGlyZWN0b3JpZXM6ICcnLFxyXG5cdFx0XHRcdHVzZUZpbGVuYW1lQXNUaXRsZTogZmFsc2UsXHJcblx0XHRcdFx0dXNlRmlsZW5hbWVBc1NsdWc6IHRydWUsXHJcblx0XHRcdFx0ZW5hYmxlTURYU3VwcG9ydDogc2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjb21tYW5kZXJDb25maWc6IHNldHRpbmdzLmNvbW1hbmRlckNvbmZpZyB8fCB7IHBhZ2VIZWFkZXJDb21tYW5kczogW10gfSxcclxuXHRcdFx0cHJvcGVydHlPdmVyRmlsZU5hbWU6IHNldHRpbmdzLnByb3BlcnR5T3ZlckZpbGVOYW1lIHx8IHsgcHJvcGVydHlLZXk6ICd0aXRsZScgfSxcclxuXHRcdFx0aW1hZ2VJbnNlcnRlcjogc2V0dGluZ3MuaW1hZ2VJbnNlcnRlciB8fCB7IHZhbHVlRm9ybWF0OiAnW1thdHRhY2htZW50cy97aW1hZ2UtdXJsfV1dJywgaW5zZXJ0Rm9ybWF0OiAnW1thdHRhY2htZW50cy97aW1hZ2UtdXJsfV1dJyB9LFxyXG5cdFx0XHRpbWFnZU1hbmFnZXI6IHNldHRpbmdzLmltYWdlTWFuYWdlciB8fCB7fSxcclxuXHRcdFx0aG9tZUJhc2U6IHNldHRpbmdzLmhvbWVCYXNlIHx8IHt9LFxyXG5cdFx0XHRleHBsb3JlckZvY3VzOiBzZXR0aW5ncy5leHBsb3JlckZvY3VzIHx8IHt9LFxyXG5cdFx0XHRpZ25vcmVDb25maWc6IHNldHRpbmdzLmlnbm9yZUNvbmZpZyB8fCB7IGdpdElnbm9yZUNvbmZpZ3VyZWQ6IGZhbHNlLCB2aXRlSWdub3JlQ29uZmlndXJlZDogZmFsc2UgfVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdGdldFN0YXRlKCk6IFdpemFyZFN0YXRlIHtcclxuXHRcdHJldHVybiB0aGlzLnN0YXRlO1xyXG5cdH1cclxuXHJcblx0dXBkYXRlU3RhdGUodXBkYXRlczogUGFydGlhbDxXaXphcmRTdGF0ZT4pOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUgPSB7IC4uLnRoaXMuc3RhdGUsIC4uLnVwZGF0ZXMgfTtcclxuXHR9XHJcblxyXG5cdHNldFN0YXRlKHVwZGF0ZXM6IFBhcnRpYWw8V2l6YXJkU3RhdGU+KTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlID0geyAuLi50aGlzLnN0YXRlLCAuLi51cGRhdGVzIH07XHJcblx0fVxyXG5cclxuXHRuZXh0U3RlcCgpOiB2b2lkIHtcclxuXHRcdC8vIGN1cnJlbnRTdGVwIGlzIDAtaW5kZXhlZCwgc28gd2UgaW5jcmVtZW50IGl0XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnRTdGVwKys7XHJcblx0fVxyXG5cclxuXHRwcmV2aW91c1N0ZXAoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5zdGF0ZS5jdXJyZW50U3RlcCA+IDApIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50U3RlcC0tO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Y2FuR29OZXh0KHRvdGFsU3RlcHM6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFN0ZXAgPCB0b3RhbFN0ZXBzIC0gMTtcclxuXHR9XHJcblxyXG5cdGNhbkdvUHJldmlvdXMoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50U3RlcCA+IDA7XHJcblx0fVxyXG5cclxuXHRnZXRQcm9ncmVzcyh0b3RhbFN0ZXBzOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0aWYgKHRvdGFsU3RlcHMgPT09IDApIHJldHVybiAwO1xyXG5cdFx0cmV0dXJuICgodGhpcy5zdGF0ZS5jdXJyZW50U3RlcCArIDEpIC8gdG90YWxTdGVwcykgKiAxMDA7XHJcblx0fVxyXG5cclxuXHRhc3luYyByZWZyZXNoU3RhdGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHQvLyBSZWZyZXNoIHRoZSB3aXphcmQgc3RhdGUgd2l0aCBjdXJyZW50IHBsdWdpbiBzZXR0aW5nc1xyXG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSAodGhpcy5wbHVnaW4gYXMgVmF1bHRDTVNQbHVnaW4pLnNldHRpbmdzO1xyXG5cdFx0XHJcblx0XHQvLyBVcGRhdGUgcHJvamVjdCBkZXRlY3Rpb25cclxuXHRcdGlmIChzZXR0aW5ncy5wcm9qZWN0Um9vdCAmJiBzZXR0aW5ncy5jb25maWdGaWxlUGF0aCkge1xyXG5cdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24gPSB7XHJcblx0XHRcdFx0cHJvamVjdFJvb3Q6IHNldHRpbmdzLnByb2plY3RSb290LFxyXG5cdFx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiBzZXR0aW5ncy5jb25maWdGaWxlUGF0aCxcclxuXHRcdFx0XHR2YXVsdExvY2F0aW9uOiAnY29udGVudCdcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gVXBkYXRlIGFsbCBvdGhlciBzZXR0aW5nc1xyXG5cdFx0dGhpcy5zdGF0ZS5jb250ZW50VHlwZXMgPSBzZXR0aW5ncy5jb250ZW50VHlwZXMgfHwgW107XHJcblx0XHR0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyA9IHNldHRpbmdzLmZyb250bWF0dGVyUHJvcGVydGllcyB8fCB7fTtcclxuXHRcdHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQgPSBzZXR0aW5ncy5kZWZhdWx0Q29udGVudFR5cGVJZDtcclxuXHRcdFxyXG5cdFx0Ly8gVXNlIHNhdmVkIHNldHRpbmdzIGZvciBhdHRhY2htZW50IGhhbmRsaW5nLCBvciBpbmZlciBmcm9tIE9ic2lkaWFuIGlmIG5vdCBzZXRcclxuXHRcdGlmIChzZXR0aW5ncy5hdHRhY2htZW50SGFuZGxpbmdNb2RlKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9IHNldHRpbmdzLmF0dGFjaG1lbnRIYW5kbGluZ01vZGU7XHJcblx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgPSBzZXR0aW5ncy5hdHRhY2htZW50Rm9sZGVyTmFtZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0IGFzIHsgY29uZmlnPzogeyBuZXdGaWxlTG9jYXRpb24/OiBzdHJpbmc7IG5ld0ZpbGVGb2xkZXJQYXRoPzogc3RyaW5nOyBhdHRhY2htZW50Rm9sZGVyUGF0aD86IHN0cmluZzsgbmV3TGlua0Zvcm1hdD86IHN0cmluZyB9IH07XHJcblx0XHRcdGNvbnN0IG9ic2lkaWFuQ29uZmlnID0gdmF1bHQuY29uZmlnO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKG9ic2lkaWFuQ29uZmlnPy5hdHRhY2htZW50Rm9sZGVyUGF0aCkge1xyXG5cdFx0XHRcdGNvbnN0IGZvbGRlclBhdGggPSBvYnNpZGlhbkNvbmZpZy5hdHRhY2htZW50Rm9sZGVyUGF0aDtcclxuXHRcdFx0XHRpZiAoZm9sZGVyUGF0aCA9PT0gJy4vJykge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID0gJ3NhbWUtZm9sZGVyJztcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChmb2xkZXJQYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9ICdzdWJmb2xkZXInO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSA9IGZvbGRlclBhdGguc3Vic3RyaW5nKDIpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSAnc3BlY2lmaWVkLWZvbGRlcic7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gZm9sZGVyUGF0aDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID0gJ3N1YmZvbGRlcic7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHR0aGlzLnN0YXRlLnByZXNldCA9IHNldHRpbmdzLnByZXNldCB8fCAndmFuaWxsYSc7XHJcblx0XHR0aGlzLnN0YXRlLnByZXNldE5hbWUgPSBzZXR0aW5ncy5wcmVzZXROYW1lIHx8ICcnO1xyXG5cdFx0dGhpcy5zdGF0ZS5wcmVzZXRzUmVwbyA9IHNldHRpbmdzLnByZXNldHNSZXBvIHx8ICd2YXVsdGNtcy92YXVsdC1jbXMtcHJlc2V0cyc7XHJcblx0XHRcclxuXHRcdC8vIFN5bmMgZW5hYmxlV1lTSVdZRyB3aXRoIGFjdHVhbCBwbHVnaW4gc3RhdGVcclxuXHRcdGNvbnN0IGFjdHVhbFZpc2liaWxpdHkgPSBhd2FpdCB0aGlzLmNvbW1hbmRlckNvbmZpZ3VyYXRvci5nZXRFZGl0aW5nVG9vbGJhclZpc2liaWxpdHkodGhpcy5wbHVnaW4uYXBwKTtcclxuXHRcdGlmIChhY3R1YWxWaXNpYmlsaXR5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVXWVNJV1lHID0gYWN0dWFsVmlzaWJpbGl0eTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlV1lTSVdZRyA9IHNldHRpbmdzLmVuYWJsZVdZU0lXWUcgPz8gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID0gc2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydDtcclxuXHRcdHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMgPSBzZXR0aW5ncy5lbmFibGVkUGx1Z2lucyB8fCBbXTtcclxuXHRcdHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zID0gc2V0dGluZ3MuZGlzYWJsZWRQbHVnaW5zIHx8IFtdO1xyXG5cdFx0dGhpcy5zdGF0ZS50aGVtZSA9IHNldHRpbmdzLnRoZW1lIHx8ICcnO1xyXG5cdFx0dGhpcy5zdGF0ZS5iYXNlc0NNU0NvbmZpZyA9IHNldHRpbmdzLmJhc2VzQ01TQ29uZmlnIHx8IHsgdmlld3M6IFtdIH07XHJcblx0XHR0aGlzLnN0YXRlLmFzdHJvQ29tcG9zZXJDb25maWcgPSBzZXR0aW5ncy5hc3Ryb0NvbXBvc2VyQ29uZmlnIHx8IHtcclxuXHRcdFx0Y3VzdG9tQ29udGVudFR5cGVzOiBbXSxcclxuXHRcdFx0ZGVmYXVsdFRlbXBsYXRlOiAnJyxcclxuXHRcdFx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdFx0XHR0ZXJtaW5hbFByb2plY3RSb290UGF0aDogJydcclxuXHRcdH07XHJcblx0XHR0aGlzLnN0YXRlLnNlb0NvbmZpZyA9IHNldHRpbmdzLnNlb0NvbmZpZyB8fCB7XHJcblx0XHRcdHRpdGxlUHJvcGVydHk6ICd0aXRsZScsXHJcblx0XHRcdHNjYW5EaXJlY3RvcmllczogJycsXHJcblx0XHRcdHVzZUZpbGVuYW1lQXNUaXRsZTogZmFsc2UsXHJcblx0XHRcdHVzZUZpbGVuYW1lQXNTbHVnOiB0cnVlXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5zdGF0ZS5jb21tYW5kZXJDb25maWcgPSBzZXR0aW5ncy5jb21tYW5kZXJDb25maWcgfHwgeyBwYWdlSGVhZGVyQ29tbWFuZHM6IFtdIH07XHJcblx0XHR0aGlzLnN0YXRlLnByb3BlcnR5T3ZlckZpbGVOYW1lID0gc2V0dGluZ3MucHJvcGVydHlPdmVyRmlsZU5hbWUgfHwgeyBwcm9wZXJ0eUtleTogJ3RpdGxlJyB9O1xyXG5cdFx0dGhpcy5zdGF0ZS5pbWFnZUluc2VydGVyID0gc2V0dGluZ3MuaW1hZ2VJbnNlcnRlciB8fCB7IHZhbHVlRm9ybWF0OiAnW1thdHRhY2htZW50cy97aW1hZ2UtdXJsfV1dJywgaW5zZXJ0Rm9ybWF0OiAnW1thdHRhY2htZW50cy97aW1hZ2UtdXJsfV1dJyB9O1xyXG5cdFx0dGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzID0gc2V0dGluZ3MuZXhwbG9yZXJGb2N1cyB8fCB7fTtcclxuXHRcdFxyXG5cdFx0Ly8gTG9hZCBjb25maWdzIGZyb20gcGx1Z2luIGRhdGEuanNvbiBmaWxlcyBpZiB0aGV5J3JlIGVtcHR5XHJcblx0XHRpZiAoIXRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyIHx8IE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjb25zdCBpbWFnZU1hbmFnZXJDb25maWd1cmF0b3IgPSBuZXcgSW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yKHRoaXMucGx1Z2luLmFwcCk7XHJcblx0XHRcdFx0Y29uc3QgbG9hZGVkQ29uZmlnID0gYXdhaXQgaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yLmxvYWRDb25maWcoKTtcclxuXHRcdFx0XHRpZiAobG9hZGVkQ29uZmlnICYmIE9iamVjdC5rZXlzKGxvYWRlZENvbmZpZykubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5pbWFnZU1hbmFnZXIgPSBsb2FkZWRDb25maWc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuaW1hZ2VNYW5hZ2VyID0gc2V0dGluZ3MuaW1hZ2VNYW5hZ2VyIHx8IHt9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEltYWdlIE1hbmFnZXIgY29uZmlnIGR1cmluZyByZWZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmltYWdlTWFuYWdlciA9IHNldHRpbmdzLmltYWdlTWFuYWdlciB8fCB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5pbWFnZU1hbmFnZXIgPSBzZXR0aW5ncy5pbWFnZU1hbmFnZXIgfHwge307XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGlmICghdGhpcy5zdGF0ZS5ob21lQmFzZSB8fCBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLmhvbWVCYXNlKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjb25zdCBob21lQmFzZUNvbmZpZ3VyYXRvciA9IG5ldyBIb21lQmFzZUNvbmZpZ3VyYXRvcih0aGlzLnBsdWdpbi5hcHApO1xyXG5cdFx0XHRcdGNvbnN0IGxvYWRlZENvbmZpZyA9IGF3YWl0IGhvbWVCYXNlQ29uZmlndXJhdG9yLmxvYWRDb25maWcoKTtcclxuXHRcdFx0XHRpZiAobG9hZGVkQ29uZmlnICYmIE9iamVjdC5rZXlzKGxvYWRlZENvbmZpZykubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5ob21lQmFzZSA9IGxvYWRlZENvbmZpZztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5ob21lQmFzZSA9IHNldHRpbmdzLmhvbWVCYXNlIHx8IHt9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIEhvbWUgQmFzZSBjb25maWcgZHVyaW5nIHJlZnJlc2g6JywgZXJyb3IpO1xyXG5cdFx0XHRcdHRoaXMuc3RhdGUuaG9tZUJhc2UgPSBzZXR0aW5ncy5ob21lQmFzZSB8fCB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5ob21lQmFzZSA9IHNldHRpbmdzLmhvbWVCYXNlIHx8IHt9O1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZiAoIXRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cyB8fCBPYmplY3Qua2V5cyh0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXMpLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnN0IGV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3IgPSBuZXcgRXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvcih0aGlzLnBsdWdpbi5hcHApO1xyXG5cdFx0XHRcdGNvbnN0IGxvYWRlZENvbmZpZyA9IGF3YWl0IGV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3IubG9hZENvbmZpZygpO1xyXG5cdFx0XHRcdGlmIChsb2FkZWRDb25maWcgJiYgT2JqZWN0LmtleXMobG9hZGVkQ29uZmlnKS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXMgPSBsb2FkZWRDb25maWc7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZXhwbG9yZXJGb2N1cyA9IHNldHRpbmdzLmV4cGxvcmVyRm9jdXMgfHwge307XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIGxvYWQgRXhwbG9yZXIgRm9jdXMgY29uZmlnIGR1cmluZyByZWZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXMgPSBzZXR0aW5ncy5leHBsb3JlckZvY3VzIHx8IHt9O1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXMgPSBzZXR0aW5ncy5leHBsb3JlckZvY3VzIHx8IHt9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YnVpbGRGaW5hbFNldHRpbmdzKCk6IHZvaWQge1xyXG5cdFx0Ly8gVXBkYXRlIHBsdWdpbi5zZXR0aW5ncyBkaXJlY3RseSBmcm9tIHdpemFyZCBzdGF0ZVxyXG5cdFx0Y29uc3Qgc2V0dGluZ3MgPSAodGhpcy5wbHVnaW4gYXMgVmF1bHRDTVNQbHVnaW4pLnNldHRpbmdzO1xyXG5cdFx0XHJcblx0XHRzZXR0aW5ncy5wcm9qZWN0Um9vdCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3QgfHwgJyc7XHJcblx0XHRzZXR0aW5ncy5jb25maWdGaWxlUGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8uY29uZmlnRmlsZVBhdGggfHwgJyc7XHJcblx0XHRzZXR0aW5ncy5jb250ZW50VHlwZXMgPSB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcztcclxuXHRcdHNldHRpbmdzLmZyb250bWF0dGVyUHJvcGVydGllcyA9IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzO1xyXG5cdFx0c2V0dGluZ3MuZGVmYXVsdENvbnRlbnRUeXBlSWQgPSB0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkO1xyXG5cdFx0c2V0dGluZ3MuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9IHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZTtcclxuXHRcdHNldHRpbmdzLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gdGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZTtcclxuXHRcdHNldHRpbmdzLnByZXNldCA9IHRoaXMuc3RhdGUucHJlc2V0O1xyXG5cdFx0c2V0dGluZ3MucHJlc2V0TmFtZSA9IHRoaXMuc3RhdGUucHJlc2V0TmFtZSB8fCAnJztcclxuXHRcdHNldHRpbmdzLnByZXNldHNSZXBvID0gdGhpcy5zdGF0ZS5wcmVzZXRzUmVwbyB8fCAnZGF2aWR2a2ltYmFsbC92YXVsdC1jbXMtcHJlc2V0cyc7XHJcblx0XHRzZXR0aW5ncy5lbmFibGVXWVNJV1lHID0gdGhpcy5zdGF0ZS5lbmFibGVXWVNJV1lHO1xyXG5cdFx0c2V0dGluZ3MuZW5hYmxlTWR4U3VwcG9ydCA9IHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZTtcclxuXHRcdHNldHRpbmdzLmVuYWJsZWRQbHVnaW5zID0gdGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucztcclxuXHRcdHNldHRpbmdzLmRpc2FibGVkUGx1Z2lucyA9IHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zO1xyXG5cdFx0c2V0dGluZ3MudGhlbWUgPSB0aGlzLnN0YXRlLnRoZW1lO1xyXG5cdFx0c2V0dGluZ3MuYmFzZXNDTVNDb25maWcgPSB0aGlzLnN0YXRlLmJhc2VzQ01TQ29uZmlnO1xyXG5cdFx0c2V0dGluZ3MuYXN0cm9Db21wb3NlckNvbmZpZyA9IHRoaXMuc3RhdGUuYXN0cm9Db21wb3NlckNvbmZpZztcclxuXHRcdHNldHRpbmdzLnNlb0NvbmZpZyA9IHRoaXMuc3RhdGUuc2VvQ29uZmlnO1xyXG5cdFx0c2V0dGluZ3MuY29tbWFuZGVyQ29uZmlnID0gdGhpcy5zdGF0ZS5jb21tYW5kZXJDb25maWc7XHJcblx0XHRzZXR0aW5ncy5wcm9wZXJ0eU92ZXJGaWxlTmFtZSA9IHRoaXMuc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWU7XHJcblx0XHQvLyBDbGVhbiB1cCBvbGQgc3RydWN0dXJlIGlmIGl0IGV4aXN0c1xyXG5cdFx0Y29uc3Qgc2V0dGluZ3NSZWNvcmQgPSBzZXR0aW5ncyBhcyB1bmtub3duIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0aWYgKHNldHRpbmdzUmVjb3JkLnVpVHdlYWtlcikge1xyXG5cdFx0XHRkZWxldGUgc2V0dGluZ3NSZWNvcmQudWlUd2Vha2VyO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHNldHRpbmdzUmVjb3JkLnRhYkJhckNvbW1hbmRzKSB7XHJcblx0XHRcdGRlbGV0ZSBzZXR0aW5nc1JlY29yZC50YWJCYXJDb21tYW5kcztcclxuXHRcdH1cclxuXHRcdHNldHRpbmdzLmltYWdlSW5zZXJ0ZXIgPSB0aGlzLnN0YXRlLmltYWdlSW5zZXJ0ZXI7XHJcblx0XHRzZXR0aW5ncy5pbWFnZU1hbmFnZXIgPSB0aGlzLnN0YXRlLmltYWdlTWFuYWdlcjtcclxuXHRcdHNldHRpbmdzLmhvbWVCYXNlID0gdGhpcy5zdGF0ZS5ob21lQmFzZTtcclxuXHRcdHNldHRpbmdzLmV4cGxvcmVyRm9jdXMgPSB0aGlzLnN0YXRlLmV4cGxvcmVyRm9jdXM7XHJcblx0XHRzZXR0aW5ncy5pZ25vcmVDb25maWcgPSB0aGlzLnN0YXRlLmlnbm9yZUNvbmZpZztcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVdpemFyZFN0ZXAge1xyXG5cdHByb3RlY3RlZCBhcHA6IEFwcDtcclxuXHRwcm90ZWN0ZWQgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50O1xyXG5cdHByb3RlY3RlZCBzdGF0ZTogV2l6YXJkU3RhdGU7XHJcblx0cHJvdGVjdGVkIG9uTmV4dDogKCkgPT4gdm9pZDtcclxuXHRwcm90ZWN0ZWQgb25CYWNrOiAoKSA9PiB2b2lkO1xyXG5cdHByb3RlY3RlZCBvbkNhbmNlbDogKCkgPT4gdm9pZDtcclxuXHJcblx0Y29uc3RydWN0b3IoXHJcblx0XHRhcHA6IEFwcCxcclxuXHRcdGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcclxuXHRcdHN0YXRlOiBXaXphcmRTdGF0ZSxcclxuXHRcdG9uTmV4dDogKCkgPT4gdm9pZCxcclxuXHRcdG9uQmFjazogKCkgPT4gdm9pZCxcclxuXHRcdG9uQ2FuY2VsOiAoKSA9PiB2b2lkXHJcblx0KSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHRcdHRoaXMuY29udGFpbmVyRWwgPSBjb250YWluZXJFbDtcclxuXHRcdHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHRcdHRoaXMub25OZXh0ID0gb25OZXh0O1xyXG5cdFx0dGhpcy5vbkJhY2sgPSBvbkJhY2s7XHJcblx0XHR0aGlzLm9uQ2FuY2VsID0gb25DYW5jZWw7XHJcblx0fVxyXG5cclxuXHRhYnN0cmFjdCBkaXNwbGF5KCk6IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xyXG5cdGFic3RyYWN0IHZhbGlkYXRlKCk6IGJvb2xlYW47XHJcblx0YWJzdHJhY3QgZ2V0VGl0bGUoKTogc3RyaW5nO1xyXG5cdGFic3RyYWN0IGdldERlc2NyaXB0aW9uKCk6IHN0cmluZztcclxufVxyXG5cclxuIiwgImltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XHJcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XHJcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcblxyXG5pbnRlcmZhY2UgT2JzaWRpYW5TZXR0aW5nIHtcclxuXHRvcGVuKCk6IHZvaWQ7XHJcblx0b3BlblRhYkJ5SWQoaWQ6IHN0cmluZyk6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBPYnNpZGlhbkFwcFdpdGhTZXR0aW5nIHtcclxuXHRzZXR0aW5nOiBPYnNpZGlhblNldHRpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBXZWxjb21lU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcclxuXHRkaXNwbGF5KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnV2VsY29tZSB0byBWYXVsdCBDTVMgc2V0dXAnIH0pO1xyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRcdHRleHQ6ICdUaGlzIHdpemFyZCB3aWxsIGhlbHAgeW91IGNvbmZpZ3VyZSB5b3VyIFZhdWx0IENNUyBzZXR1cC4gV2VcXCdsbCBndWlkZSB5b3UgdGhyb3VnaDonIFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgbGlzdCA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCd1bCcpO1xyXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0bGlzdC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdEZXRlY3RpbmcgeW91ciBBc3RybyBwcm9qZWN0IHN0cnVjdHVyZScgfSk7XHJcblx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ0lkZW50aWZ5aW5nIHlvdXIgY29udGVudCB0eXBlcycgfSk7XHJcblx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ01hcHBpbmcgZnJvbnRtYXR0ZXIgcHJvcGVydGllcycgfSk7XHJcblx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ0NvbmZpZ3VyaW5nIHBsdWdpbnMgYW5kIHRoZW1lcycgfSk7XHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRsaXN0LmNyZWF0ZUVsKCdsaScsIHsgdGV4dDogJ1NldHRpbmcgdXAgQmFzZXMgQ01TIHZpZXdzJyB9KTtcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2VcclxuXHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnQ29uZmlndXJpbmcgQXN0cm8gQ29tcG9zZXIgYW5kIFNFTyBwbHVnaW5zJyB9KTtcclxuXHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdHRleHQ6ICdDaG9vc2UgYW4gb3B0aW9uIHRvIGNvbnRpbnVlOicgXHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCBidXR0b25Db250YWluZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoJ3dpemFyZC13ZWxjb21lLWJ1dHRvbnMnKTtcclxuXHRcdHNldENzc1Byb3BzKGJ1dHRvbkNvbnRhaW5lciwge1xyXG5cdFx0XHRkaXNwbGF5OiAnZmxleCcsXHJcblx0XHRcdGdhcDogJzEwcHgnLFxyXG5cdFx0XHRtYXJnaW5Ub3A6ICcyMHB4J1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgZ2V0U3RhcnRlZEJ0biA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbCgnYnV0dG9uJywge1xyXG5cdFx0XHR0ZXh0OiAnR2V0IHN0YXJ0ZWQnLFxyXG5cdFx0XHRjbHM6ICdtb2QtYnV0dG9uIG1vZC1jdGEnXHJcblx0XHR9KTtcclxuXHRcdGdldFN0YXJ0ZWRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdHRoaXMub25OZXh0KCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCBzZWxlY3RQcmVzZXRCdG4gPSBidXR0b25Db250YWluZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHtcclxuXHRcdFx0dGV4dDogJ1NlbGVjdCBwcmVzZXQnLFxyXG5cdFx0XHRjbHM6ICdtb2QtYnV0dG9uJ1xyXG5cdFx0fSk7XHJcblx0XHRzZWxlY3RQcmVzZXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcblx0XHRcdC8vIENsb3NlIG1vZGFsIGFuZCBvcGVuIHNldHRpbmdzIHRhYlxyXG5cdFx0XHR0aGlzLm9uQ2FuY2VsKCk7XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zdCBhcHBXaXRoU2V0dGluZyA9IHRoaXMuYXBwIGFzIHVua25vd24gYXMgT2JzaWRpYW5BcHBXaXRoU2V0dGluZztcclxuXHRcdFx0aWYgKGFwcFdpdGhTZXR0aW5nLnNldHRpbmcgJiYgdHlwZW9mIGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGFwcFdpdGhTZXR0aW5nLnNldHRpbmcub3BlbigpO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgYXBwV2l0aFNldHRpbmcuc2V0dGluZy5vcGVuVGFiQnlJZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0YXBwV2l0aFNldHRpbmcuc2V0dGluZy5vcGVuVGFiQnlJZCgndmF1bHQtY21zJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdXZWxjb21lJztcclxuXHR9XHJcblxyXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gJ0ludHJvZHVjdGlvbiB0byBWYXVsdCBDTVMgc2V0dXAnO1xyXG5cdH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBOb3RpY2UgfSBmcm9tICdvYnNpZGlhbic7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzIChtYXkgbm90IGJlIGluIHR5cGVzIHlldClcclxuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XHJcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XHJcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXNcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlc1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XHJcbmltcG9ydCB7IFdpemFyZFN0YXRlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBQcm9qZWN0RGV0ZWN0b3IgfSBmcm9tICcuLi8uLi91dGlscy9Qcm9qZWN0RGV0ZWN0b3InO1xyXG5pbXBvcnQgeyBNZHhEZXRlY3RvciB9IGZyb20gJy4uLy4uL3V0aWxzL01keERldGVjdG9yJztcclxuaW1wb3J0IHsgQ29udGVudFR5cGVEZXRlY3RvciB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbnRlbnRUeXBlRGV0ZWN0b3InO1xyXG5cclxuZXhwb3J0IGNsYXNzIFByb2plY3REZXRlY3Rpb25TdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xyXG5cdHByaXZhdGUgcHJvamVjdERldGVjdG9yOiBQcm9qZWN0RGV0ZWN0b3I7XHJcblx0cHJpdmF0ZSBtZHhEZXRlY3RvcjogTWR4RGV0ZWN0b3I7XHJcblx0cHJpdmF0ZSBjb250ZW50VHlwZURldGVjdG9yOiBDb250ZW50VHlwZURldGVjdG9yO1xyXG5cdHByaXZhdGUgZGV0ZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRwcml2YXRlIHByb2plY3RSb290RGlzcGxheTogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuXHRwcml2YXRlIGNvbmZpZ0ZpbGVEaXNwbGF5OiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xyXG5cdFx0c3VwZXIoYXBwLCBjb250YWluZXJFbCwgc3RhdGUsIG9uTmV4dCwgb25CYWNrLCBvbkNhbmNlbCk7XHJcblx0XHR0aGlzLnByb2plY3REZXRlY3RvciA9IG5ldyBQcm9qZWN0RGV0ZWN0b3IoYXBwKTtcclxuXHRcdHRoaXMubWR4RGV0ZWN0b3IgPSBuZXcgTWR4RGV0ZWN0b3IoYXBwKTtcclxuXHRcdHRoaXMuY29udGVudFR5cGVEZXRlY3RvciA9IG5ldyBDb250ZW50VHlwZURldGVjdG9yKGFwcCk7XHJcblx0fVxyXG5cclxuXHRhc3luYyBkaXNwbGF5KCk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAuZGlzcGxheTogY2FsbGVkJyk7XHJcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcblx0XHQvLyBDaGVjayBpZiB3ZSBoYXZlIHNhdmVkIHByb2plY3QgZGV0ZWN0aW9uIHZhbHVlc1xyXG5cdFx0Y29uc3QgaGFzU2F2ZWRWYWx1ZXMgPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290ICYmIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8uY29uZmlnRmlsZVBhdGg7XHJcblx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcC5kaXNwbGF5OiBoYXNTYXZlZFZhbHVlcyA9JywgaGFzU2F2ZWRWYWx1ZXMpO1xyXG5cdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAuZGlzcGxheTogY3VycmVudCBlbmFibGVNZHhTdXBwb3J0ID0nLCB0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0XHJcblx0XHRpZiAoIWhhc1NhdmVkVmFsdWVzKSB7XHJcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3QgZGV0ZWN0aW9uJyB9KTtcclxuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxyXG5cdFx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIkFzdHJvXCIgaXMgYSBwcm9wZXIgbm91biAoZnJhbWV3b3JrIG5hbWUpIGFuZCBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRcdFx0dGV4dDogJ0RldGVjdGluZyB5b3VyIEFzdHJvIHByb2plY3Qgc3RydWN0dXJlLi4uJyBcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCByZXN1bHQgPSB0aGlzLnByb2plY3REZXRlY3Rvci5kZXRlY3RQcm9qZWN0KCk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwLmRpc3BsYXk6IGRldGVjdGlvbiByZXN1bHQgPScsIHJlc3VsdCk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAocmVzdWx0KSB7XHJcblx0XHRcdFx0Ly8gQ29udmVydCBhYnNvbHV0ZSBwYXRocyB0byByZWxhdGl2ZSBwYXRocyAobGlrZSBicm93c2UgYnV0dG9uIGRvZXMpXHJcblx0XHRcdFx0Y29uc3QgcmVsYXRpdmVQcm9qZWN0Um9vdCA9IHRoaXMudG9SZWxhdGl2ZVBhdGgocmVzdWx0LnByb2plY3RSb290KTtcclxuXHRcdFx0XHRjb25zdCByZWxhdGl2ZUNvbmZpZ0ZpbGVQYXRoID0gdGhpcy50b1JlbGF0aXZlUGF0aChyZXN1bHQuY29uZmlnRmlsZVBhdGgpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEluaXRpYWxpemUgc3RhdGUgd2l0aCBkZXRlY3RlZCB2YWx1ZXMgKGNvbnZlcnRlZCB0byByZWxhdGl2ZSBwYXRocylcclxuXHRcdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24gPSB7XHJcblx0XHRcdFx0XHRwcm9qZWN0Um9vdDogcmVsYXRpdmVQcm9qZWN0Um9vdCxcclxuXHRcdFx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiByZWxhdGl2ZUNvbmZpZ0ZpbGVQYXRoLFxyXG5cdFx0XHRcdFx0dmF1bHRMb2NhdGlvbjogcmVzdWx0LnZhdWx0TG9jYXRpb25cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwLmRpc3BsYXk6IHNldCBwcm9qZWN0RGV0ZWN0aW9uID0nLCB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xyXG5cdFx0XHRcdHRoaXMuZGV0ZWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIE5vIGRldGVjdGlvbiwgc2hvdyBtYW51YWwgc2VsZWN0aW9uXHJcblx0XHRcdFx0dGhpcy5kZXRlY3RlZCA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBVc2Ugc2F2ZWQgdmFsdWVzXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwLmRpc3BsYXk6IHVzaW5nIHNhdmVkIHByb2plY3REZXRlY3Rpb24gPScsIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbik7XHJcblx0XHRcdHRoaXMuZGV0ZWN0ZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uICYmICh0aGlzLmRldGVjdGVkIHx8IGhhc1NhdmVkVmFsdWVzKSkge1xyXG5cclxuXHRcdFx0Ly8gQWRkIHNsaWdodCBkZWxheSBiZWZvcmUgc2hvd2luZyBkZXRlY3RlZCBjb250ZW50IChsaWtlIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MpXHJcblx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuXHJcblx0XHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3QgZGV0ZWN0ZWQnIH0pO1xyXG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdHRleHQ6ICdQcm9qZWN0IHN0cnVjdHVyZSBkZXRlY3RlZCBzdWNjZXNzZnVsbHkuIFlvdSBjYW4gbW9kaWZ5IHRoZSBwYXRocyBiZWxvdyBpZiBuZWVkZWQsIHRoZW4gY2xpY2sgXCJOZXh0XCIgdG8gY29udGludWUuJyBcclxuXHRcdFx0fSk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBQcm9qZWN0IFJvb3QgcGlja2VyICh3aXRoIGJyb3dzZSBidXR0b24gZXZlbiB3aGVuIGRldGVjdGVkKVxyXG5cdFx0XHRjb25zdCBwcm9qZWN0Um9vdFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0XHQuc2V0TmFtZSgnUHJvamVjdCByb290JylcclxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJBc3Ryb1wiIGlzIGEgcHJvcGVyIG5vdW4gKGZyYW1ld29yayBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdC5zZXREZXNjKCdTZWxlY3QgdGhlIGZvbGRlciBjb250YWluaW5nIHlvdXIgQXN0cm8gcHJvamVjdCByb290Jyk7XHJcblxyXG5cdFx0XHQvLyBEaXNwbGF5IGN1cnJlbnQgc2VsZWN0aW9uXHJcblx0XHRcdHRoaXMucHJvamVjdFJvb3REaXNwbGF5ID0gcHJvamVjdFJvb3RTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoe1xyXG5cdFx0XHRcdHRleHQ6IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCB8fCAnTm8gZm9sZGVyIHNlbGVjdGVkJyxcclxuXHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtcGF0aC1kaXNwbGF5J1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0c2V0Q3NzUHJvcHModGhpcy5wcm9qZWN0Um9vdERpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW5vcm1hbCknIH0pO1xyXG5cclxuXHRcdFx0cHJvamVjdFJvb3RTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0Jyb3dzZS4uLicpXHJcblx0XHRcdFx0LnNldEN0YSgpXHJcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xyXG5cdFx0XHRcdFx0KCgpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRQYXRoID0gdGhpcy5zZWxlY3RGb2xkZXIoKTtcclxuXHRcdFx0XHRcdFx0aWYgKHNlbGVjdGVkUGF0aCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiEucHJvamVjdFJvb3QgPSBzZWxlY3RlZFBhdGg7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMucHJvamVjdFJvb3REaXNwbGF5KSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnByb2plY3RSb290RGlzcGxheS50ZXh0Q29udGVudCA9IHNlbGVjdGVkUGF0aDtcclxuXHRcdFx0XHRcdFx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0Ly8gVXBkYXRlIGRldGVjdGVkIGZsYWcgaWYgdXNlciBjaGFuZ2VzXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5kZXRlY3RlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KSgpO1xyXG5cdFx0XHRcdH0pKTtcclxuXHJcblx0XHRcdC8vIENvbmZpZyBGaWxlIHBpY2tlciAod2l0aCBicm93c2UgYnV0dG9uIGV2ZW4gd2hlbiBkZXRlY3RlZClcclxuXHRcdFx0Y29uc3QgY29uZmlnRmlsZVNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0XHQuc2V0TmFtZSgnQ29uZmlnIGZpbGUnKVxyXG5cdFx0XHRcdC5zZXREZXNjKCdTZWxlY3QgeW91ciBBc3RybyBjb25maWcgZmlsZSAoYXN0cm8uY29uZmlnLm1qcywgYXN0cm8uY29uZmlnLmpzLCBzcmMvY29uZmlnLnRzLCBldGMuKScpO1xyXG5cclxuXHRcdFx0Ly8gRGlzcGxheSBjdXJyZW50IHNlbGVjdGlvblxyXG5cdFx0XHR0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5ID0gY29uZmlnRmlsZVNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdih7XHJcblx0XHRcdFx0dGV4dDogdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoIHx8ICdObyBmaWxlIHNlbGVjdGVkJyxcclxuXHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtcGF0aC1kaXNwbGF5J1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0c2V0Q3NzUHJvcHModGhpcy5jb25maWdGaWxlRGlzcGxheSwgeyBjb2xvcjogJ3ZhcigtLXRleHQtbm9ybWFsKScgfSk7XHJcblxyXG5cdFx0XHRjb25maWdGaWxlU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdCcm93c2UuLi4nKVxyXG5cdFx0XHRcdC5zZXRDdGEoKVxyXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcclxuXHRcdFx0XHRcdCgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRlZmF1bHRQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdCB8fCB0aGlzLmdldFZhdWx0UGF0aCgpO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZFBhdGggPSB0aGlzLnNlbGVjdENvbmZpZ0ZpbGUoZGVmYXVsdFBhdGgpO1xyXG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0ZWRQYXRoKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uIS5jb25maWdGaWxlUGF0aCA9IHNlbGVjdGVkUGF0aDtcclxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5jb25maWdGaWxlRGlzcGxheSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jb25maWdGaWxlRGlzcGxheS50ZXh0Q29udGVudCA9IHNlbGVjdGVkUGF0aDtcclxuXHRcdFx0XHRcdFx0XHRcdHNldENzc1Byb3BzKHRoaXMuY29uZmlnRmlsZURpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW5vcm1hbCknIH0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgZGV0ZWN0ZWQgZmxhZyBpZiB1c2VyIGNoYW5nZXNcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmRldGVjdGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdFx0Ly8gTURYIFN1cHBvcnQgY2hlY2tib3hcclxuXHRcdFx0Ly8gQXV0by1kZXRlY3QgTURYIGZpbGVzIGlmIHByb2plY3QgaXMgZGV0ZWN0ZWRcclxuXHRcdFx0bGV0IGF1dG9EZXRlY3RlZE1keCA9IGZhbHNlO1xyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBTdGFydGluZyBNRFggZGV0ZWN0aW9uJyk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogcHJvamVjdERldGVjdGlvbiA9JywgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb2plY3REZXRlY3Rpb25TdGVwOiBleGlzdGluZyBjb250ZW50VHlwZXMgPScsIHRoaXMuc3RhdGUuY29udGVudFR5cGVzLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vIEdldCBjb250ZW50IHR5cGVzIC0gdXNlIGV4aXN0aW5nIG9uZXMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZGV0ZWN0IHRoZW1cclxuXHRcdFx0XHRcdGxldCBjb250ZW50VHlwZXNUb1VzZSA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzO1xyXG5cdFx0XHRcdFx0aWYgKGNvbnRlbnRUeXBlc1RvVXNlLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogTm8gY29udGVudCB0eXBlcyBpbiBzdGF0ZSwgZGV0ZWN0aW5nIG5vdy4uLicpO1xyXG5cdFx0XHRcdFx0XHQvLyBDb250ZW50IHR5cGVzIG5vdCBkZXRlY3RlZCB5ZXQsIGRldGVjdCB0aGVtIG5vdyBmb3IgTURYIHNjYW5uaW5nXHJcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlc1RvVXNlID0gdGhpcy5jb250ZW50VHlwZURldGVjdG9yLmRldGVjdENvbnRlbnRUeXBlcyh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogRGV0ZWN0ZWQgY29udGVudCB0eXBlcyA9JywgY29udGVudFR5cGVzVG9Vc2UubGVuZ3RoLCBjb250ZW50VHlwZXNUb1VzZS5tYXAoY3QgPT4gYCR7Y3QubmFtZX0gKCR7Y3QuZm9sZGVyfSwgZW5hYmxlZDogJHtjdC5lbmFibGVkfSlgKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogVXNpbmcgZXhpc3RpbmcgY29udGVudCB0eXBlcyA9JywgY29udGVudFR5cGVzVG9Vc2UubWFwKGN0ID0+IGAke2N0Lm5hbWV9ICgke2N0LmZvbGRlcn0sIGVuYWJsZWQ6ICR7Y3QuZW5hYmxlZH0pYCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRpZiAoY29udGVudFR5cGVzVG9Vc2UubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogQ2FsbGluZyBtZHhEZXRlY3Rvci5kZXRlY3RNZHhVc2FnZS4uLicpO1xyXG5cdFx0XHRcdFx0XHRhdXRvRGV0ZWN0ZWRNZHggPSB0aGlzLm1keERldGVjdG9yLmRldGVjdE1keFVzYWdlKFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbixcclxuXHRcdFx0XHRcdFx0XHRjb250ZW50VHlwZXNUb1VzZVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogTURYIGRldGVjdGlvbiByZXN1bHQgPScsIGF1dG9EZXRlY3RlZE1keCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogTm8gY29udGVudCB0eXBlcyB0byBzY2FuJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0XHRcdC8vIElmIGRldGVjdGlvbiBmYWlscywgZGVmYXVsdCB0byBmYWxzZVxyXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcignUHJvamVjdERldGVjdGlvblN0ZXA6IE1EWCBkZXRlY3Rpb24gZmFpbGVkOicsIGVycm9yKTtcclxuXHRcdFx0XHRcdGF1dG9EZXRlY3RlZE1keCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogTm8gcHJvamVjdERldGVjdGlvbiwgc2tpcHBpbmcgTURYIGRldGVjdGlvbicpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBbHdheXMgdXBkYXRlIGVuYWJsZU1keFN1cHBvcnQgd2l0aCBhdXRvLWRldGVjdGlvbiByZXN1bHQgaWYgaXQgaGFzbid0IGJlZW4gc2V0L2RldGVjdGVkIHlldFxyXG5cdFx0XHQvLyBUaGlzIGVuc3VyZXMgZGV0ZWN0aW9uIHJ1bnMgb24gZmlyc3QgcnVuIGJ1dCByZW1lbWJlcnMgdXNlcidzIG1hbnVhbCBjaG9pY2UgdGhlcmVhZnRlclxyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPSBhdXRvRGV0ZWN0ZWRNZHg7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXA6IFNldCBlbmFibGVNZHhTdXBwb3J0IHRvJywgYXV0b0RldGVjdGVkTWR4LCAnYmFzZWQgb24gYXV0by1kZXRlY3Rpb24nKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcDogZW5hYmxlTWR4U3VwcG9ydCBhbHJlYWR5IHNldCB0bycsIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCwgJywgc2tpcHBpbmcgYXV0by1kZXRlY3Rpb24gb3ZlcndyaXRlJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1keFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJNRFhcIiBpcyBhbiBhY3JvbnltIChmaWxlIGZvcm1hdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdC5zZXROYW1lKCdNRFggZmlsZSBzdXBwb3J0JylcclxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJNRFhcIiBpcyBhbiBhY3JvbnltIChmaWxlIGZvcm1hdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdC5zZXREZXNjKCdFbmFibGUgTURYIGZpbGUgc3VwcG9ydCBmb3IgQXN0cm8gQ29tcG9zZXIsIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lLCBTRU8sIGFuZCBVSSBUd2Vha2VyIHBsdWdpbnMuJyk7XHJcblx0XHRcdFxyXG5cdFx0XHRtZHhTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xyXG5cdFx0XHRcdHRvZ2dsZVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZSlcclxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2hvdyBhdXRvLWRldGVjdGlvbiBtZXNzYWdlIGlmIE1EWCB3YXMgZGV0ZWN0ZWRcclxuXHRcdFx0XHRpZiAoYXV0b0RldGVjdGVkTWR4ICYmIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgYXV0b0RldGVjdE1zZyA9IG1keFNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdih7XHJcblx0XHRcdFx0XHRcdHRleHQ6ICdNRFggZmlsZXMgZGV0ZWN0ZWQgaW4gY29udGVudCBmb2xkZXJzJyxcclxuXHRcdFx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLWF1dG8tZGV0ZWN0LW1zZydcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoYXV0b0RldGVjdE1zZywgeyBcclxuXHRcdFx0XHRcdFx0Y29sb3I6ICd2YXIoLS10ZXh0LW11dGVkKScsIFxyXG5cdFx0XHRcdFx0XHRmb250U2l6ZTogJzAuOWVtJyxcclxuXHRcdFx0XHRcdFx0bWFyZ2luVG9wOiAnNHB4J1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3QgZGV0ZWN0aW9uIGZhaWxlZCcgfSk7XHJcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJBc3Ryb1wiIGlzIGEgcHJvcGVyIG5vdW4gKGZyYW1ld29yayBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdHRleHQ6ICdDb3VsZCBub3QgZGV0ZWN0IEFzdHJvIHByb2plY3Qgc3RydWN0dXJlLiBQbGVhc2Ugc2VsZWN0IHlvdXIgQXN0cm8gcHJvamVjdCByb290IGFuZCBjb25maWcgZmlsZSBtYW51YWxseS4nIFxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIEluaXRpYWxpemUgc3RhdGUgaWYgbmVlZGVkXHJcblx0XHRcdGlmICghdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uID0ge1xyXG5cdFx0XHRcdFx0cHJvamVjdFJvb3Q6ICcnLFxyXG5cdFx0XHRcdFx0Y29uZmlnRmlsZVBhdGg6ICcnLFxyXG5cdFx0XHRcdFx0dmF1bHRMb2NhdGlvbjogJ3Jvb3QnXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUHJvamVjdCBSb290IHBpY2tlclxyXG5cdFx0XHRjb25zdCBwcm9qZWN0Um9vdFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0XHQuc2V0TmFtZSgnUHJvamVjdCByb290JylcclxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJBc3Ryb1wiIGlzIGEgcHJvcGVyIG5vdW4gKGZyYW1ld29yayBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdC5zZXREZXNjKCdTZWxlY3QgdGhlIGZvbGRlciBjb250YWluaW5nIHlvdXIgQXN0cm8gcHJvamVjdCByb290Jyk7XHJcblxyXG5cdFx0XHQvLyBEaXNwbGF5IGN1cnJlbnQgc2VsZWN0aW9uXHJcblx0XHRcdHRoaXMucHJvamVjdFJvb3REaXNwbGF5ID0gcHJvamVjdFJvb3RTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoe1xyXG5cdFx0XHRcdHRleHQ6IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCB8fCAnTm8gZm9sZGVyIHNlbGVjdGVkJyxcclxuXHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtcGF0aC1kaXNwbGF5J1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCkge1xyXG5cdFx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLnByb2plY3RSb290RGlzcGxheSwgeyBjb2xvcjogJ3ZhcigtLXRleHQtbXV0ZWQpJyB9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJvamVjdFJvb3RTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXHJcblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0Jyb3dzZS4uLicpXHJcblx0XHRcdFx0LnNldEN0YSgpXHJcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xyXG5cdFx0XHRcdFx0KCgpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRQYXRoID0gdGhpcy5zZWxlY3RGb2xkZXIoKTtcclxuXHRcdFx0XHRcdFx0aWYgKHNlbGVjdGVkUGF0aCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiEucHJvamVjdFJvb3QgPSBzZWxlY3RlZFBhdGg7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMucHJvamVjdFJvb3REaXNwbGF5KSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnByb2plY3RSb290RGlzcGxheS50ZXh0Q29udGVudCA9IHNlbGVjdGVkUGF0aDtcclxuXHRcdFx0XHRcdFx0XHRcdHNldENzc1Byb3BzKHRoaXMucHJvamVjdFJvb3REaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKCk7XHJcblx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdFx0Ly8gQ29uZmlnIEZpbGUgcGlja2VyXHJcblx0XHRcdGNvbnN0IGNvbmZpZ0ZpbGVTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXHJcblx0XHRcdFx0LnNldE5hbWUoJ0NvbmZpZyBmaWxlJylcclxuXHRcdFx0XHQuc2V0RGVzYygnU2VsZWN0IHlvdXIgQXN0cm8gY29uZmlnIGZpbGUgKGFzdHJvLmNvbmZpZy5tanMsIGFzdHJvLmNvbmZpZy5qcywgc3JjL2NvbmZpZy50cywgZXRjLiknKTtcclxuXHJcblx0XHRcdC8vIERpc3BsYXkgY3VycmVudCBzZWxlY3Rpb25cclxuXHRcdFx0dGhpcy5jb25maWdGaWxlRGlzcGxheSA9IGNvbmZpZ0ZpbGVTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoe1xyXG5cdFx0XHRcdHRleHQ6IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aCB8fCAnTm8gZmlsZSBzZWxlY3RlZCcsXHJcblx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLXBhdGgtZGlzcGxheSdcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmICh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGgpIHtcclxuXHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1ub3JtYWwpJyB9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzZXRDc3NQcm9wcyh0aGlzLmNvbmZpZ0ZpbGVEaXNwbGF5LCB7IGNvbG9yOiAndmFyKC0tdGV4dC1tdXRlZCknIH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25maWdGaWxlU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxyXG5cdFx0XHRcdC5zZXRCdXR0b25UZXh0KCdCcm93c2UuLi4nKVxyXG5cdFx0XHRcdC5zZXRDdGEoKVxyXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcclxuXHRcdFx0XHRcdCgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRlZmF1bHRQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdCB8fCB0aGlzLmdldFZhdWx0UGF0aCgpO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZFBhdGggPSB0aGlzLnNlbGVjdENvbmZpZ0ZpbGUoZGVmYXVsdFBhdGgpO1xyXG5cdFx0XHRcdFx0XHRpZiAoc2VsZWN0ZWRQYXRoKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uIS5jb25maWdGaWxlUGF0aCA9IHNlbGVjdGVkUGF0aDtcclxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5jb25maWdGaWxlRGlzcGxheSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jb25maWdGaWxlRGlzcGxheS50ZXh0Q29udGVudCA9IHNlbGVjdGVkUGF0aDtcclxuXHRcdFx0XHRcdFx0XHRcdHNldENzc1Byb3BzKHRoaXMuY29uZmlnRmlsZURpc3BsYXksIHsgY29sb3I6ICd2YXIoLS10ZXh0LW5vcm1hbCknIH0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSkoKTtcclxuXHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0XHQvLyBNRFggU3VwcG9ydCBjaGVja2JveCAoZm9yIG1hbnVhbCBwcm9qZWN0IHNlbGVjdGlvbilcclxuXHRcdFx0Ly8gVHJ5IHRvIGF1dG8tZGV0ZWN0IE1EWCBpZiB3ZSBoYXZlIHByb2plY3QgZGV0ZWN0aW9uXHJcblx0XHRcdGxldCBhdXRvRGV0ZWN0ZWRNZHggPSBmYWxzZTtcclxuXHRcdFx0aWYgKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbiAmJiB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QgJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoKSB7XHJcblx0XHRcdFx0Ly8gVHJ5IHRvIGRldGVjdCBjb250ZW50IHR5cGVzIGZpcnN0XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkQ29udGVudFR5cGVzID0gdGhpcy5jb250ZW50VHlwZURldGVjdG9yLmRldGVjdENvbnRlbnRUeXBlcyh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xyXG5cdFx0XHRcdFx0aWYgKGRldGVjdGVkQ29udGVudFR5cGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0YXV0b0RldGVjdGVkTWR4ID0gdGhpcy5tZHhEZXRlY3Rvci5kZXRlY3RNZHhVc2FnZShcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24sXHJcblx0XHRcdFx0XHRcdFx0ZGV0ZWN0ZWRDb250ZW50VHlwZXNcclxuXHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGNhdGNoIHtcclxuXHRcdFx0XHRcdC8vIElmIGRldGVjdGlvbiBmYWlscywgZGVmYXVsdCB0byBmYWxzZVxyXG5cdFx0XHRcdFx0YXV0b0RldGVjdGVkTWR4ID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBbHdheXMgdXBkYXRlIGVuYWJsZU1keFN1cHBvcnQgd2l0aCBhdXRvLWRldGVjdGlvbiByZXN1bHQgaWYgaXQgaGFzbid0IGJlZW4gc2V0L2RldGVjdGVkIHlldFxyXG5cdFx0XHQvLyBUaGlzIGVuc3VyZXMgZGV0ZWN0aW9uIHJ1bnMgb24gZmlyc3QgcnVuIGJ1dCByZW1lbWJlcnMgdXNlcidzIG1hbnVhbCBjaG9pY2UgdGhlcmVhZnRlclxyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPSBhdXRvRGV0ZWN0ZWRNZHg7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvamVjdERldGVjdGlvblN0ZXAgKG1hbnVhbCk6IFNldCBlbmFibGVNZHhTdXBwb3J0IHRvJywgYXV0b0RldGVjdGVkTWR4LCAnYmFzZWQgb24gYXV0by1kZXRlY3Rpb24nKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9qZWN0RGV0ZWN0aW9uU3RlcCAobWFudWFsKTogZW5hYmxlTWR4U3VwcG9ydCBhbHJlYWR5IHNldCB0bycsIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCwgJywgc2tpcHBpbmcgYXV0by1kZXRlY3Rpb24gb3ZlcndyaXRlJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1keFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJNRFhcIiBpcyBhbiBhY3JvbnltIChmaWxlIGZvcm1hdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdC5zZXROYW1lKCdNRFggZmlsZSBzdXBwb3J0JylcclxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJNRFhcIiBpcyBhbiBhY3JvbnltIChmaWxlIGZvcm1hdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHRcdC5zZXREZXNjKCdFbmFibGUgTURYIGZpbGUgc3VwcG9ydCBmb3IgQXN0cm8gQ29tcG9zZXIsIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lLCBTRU8sIGFuZCBVSSBUd2Vha2VyIHBsdWdpbnMuJyk7XHJcblx0XHRcdFxyXG5cdFx0XHRtZHhTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4ge1xyXG5cdFx0XHRcdHRvZ2dsZVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA/PyBmYWxzZSlcclxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2hvdyBhdXRvLWRldGVjdGlvbiBtZXNzYWdlIGlmIE1EWCB3YXMgZGV0ZWN0ZWRcclxuXHRcdFx0XHRpZiAoYXV0b0RldGVjdGVkTWR4ICYmIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgYXV0b0RldGVjdE1zZyA9IG1keFNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdih7XHJcblx0XHRcdFx0XHRcdHRleHQ6ICdNRFggZmlsZXMgZGV0ZWN0ZWQgaW4gY29udGVudCBmb2xkZXJzJyxcclxuXHRcdFx0XHRcdFx0Y2xzOiAndmF1bHQtY21zLWF1dG8tZGV0ZWN0LW1zZydcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoYXV0b0RldGVjdE1zZywgeyBcclxuXHRcdFx0XHRcdFx0Y29sb3I6ICd2YXIoLS10ZXh0LW11dGVkKScsIFxyXG5cdFx0XHRcdFx0XHRmb250U2l6ZTogJzAuOWVtJyxcclxuXHRcdFx0XHRcdFx0bWFyZ2luVG9wOiAnNHB4J1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIE9wZW4gbmF0aXZlIGZvbGRlciBwaWNrZXIgZGlhbG9nXHJcblx0ICovXHJcblx0cHJpdmF0ZSBzZWxlY3RGb2xkZXIoKTogc3RyaW5nIHwgbnVsbCB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgbXVsdGlwbGUgd2F5cyB0byBhY2Nlc3MgRWxlY3Ryb24gZGlhbG9nIEFQSVxyXG5cdFx0XHRsZXQgZGlhbG9nOiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfCBudWxsID0gbnVsbDtcclxuXHJcblx0XHRcdC8vIE1ldGhvZCAxOiBUcnkgQGVsZWN0cm9uL3JlbW90ZSAobmV3ZXIgRWxlY3Ryb24gdmVyc2lvbnMpXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmXHJcblx0XHRcdFx0Y29uc3QgZWxlY3Ryb25SZW1vdGUgPSByZXF1aXJlKCdAZWxlY3Ryb24vcmVtb3RlJykgYXMgeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfTtcclxuXHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvblJlbW90ZT8uZGlhbG9nIHx8IG51bGw7XHJcblx0XHRcdH0gY2F0Y2gge1xyXG5cdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNZXRob2QgMjogVHJ5IGVsZWN0cm9uLnJlbW90ZS5kaWFsb2cgKG9sZGVyIEVsZWN0cm9uIHZlcnNpb25zKVxyXG5cdFx0XHRpZiAoIWRpYWxvZykge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgbm8tdW5kZWZcclxuXHRcdFx0XHRcdGNvbnN0IGVsZWN0cm9uID0gKCh3aW5kb3cgYXMgeyByZXF1aXJlPzogKG1vZHVsZTogc3RyaW5nKSA9PiB1bmtub3duIH0pLnJlcXVpcmU/LignZWxlY3Ryb24nKSB8fCByZXF1aXJlKCdlbGVjdHJvbicpKSBhcyB7IHJlbW90ZT86IHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH0gfTtcclxuXHRcdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uPy5yZW1vdGU/LmRpYWxvZyB8fCBudWxsO1xyXG5cdFx0XHRcdH0gY2F0Y2gge1xyXG5cdFx0XHRcdFx0Ly8gTm90IGF2YWlsYWJsZSwgdHJ5IG5leHQgbWV0aG9kXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNZXRob2QgMzogVHJ5IGVsZWN0cm9uLmRpYWxvZyBkaXJlY3RseSAobWFpbiBwcm9jZXNzLCBtYXkgbm90IHdvcmspXHJcblx0XHRcdGlmICghZGlhbG9nKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZlxyXG5cdFx0XHRcdFx0Y29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpIGFzIHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH07XHJcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8uZGlhbG9nIHx8IG51bGw7XHJcblx0XHRcdFx0fSBjYXRjaCB7XHJcblx0XHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIWRpYWxvZyB8fCB0eXBlb2YgZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRWxlY3Ryb24gZGlhbG9nIEFQSSBub3QgYXZhaWxhYmxlJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuZ2V0VmF1bHRQYXRoKCk7XHJcblx0XHRcdGxldCBkZWZhdWx0UGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3QgfHwgdmF1bHRQYXRoO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ29udmVydCByZWxhdGl2ZSBwYXRoIHRvIGFic29sdXRlIGlmIG5lZWRlZFxyXG5cdFx0XHRpZiAoZGVmYXVsdFBhdGggJiYgIXBhdGguaXNBYnNvbHV0ZShkZWZhdWx0UGF0aCkpIHtcclxuXHRcdFx0XHRkZWZhdWx0UGF0aCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIGRlZmF1bHRQYXRoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyh7XHJcblx0XHRcdFx0dGl0bGU6ICdTZWxlY3QgQXN0cm8gUHJvamVjdCBSb290IEZvbGRlcicsXHJcblx0XHRcdFx0ZGVmYXVsdFBhdGg6IGRlZmF1bHRQYXRoLFxyXG5cdFx0XHRcdHByb3BlcnRpZXM6IFsnb3BlbkRpcmVjdG9yeSddXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGgubm9ybWFsaXplKHJlc3VsdFswXSk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMudG9SZWxhdGl2ZVBhdGgoYWJzb2x1dGVQYXRoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3Igb3BlbmluZyBmb2xkZXIgcGlja2VyOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gU2hvdyB1c2VyLWZyaWVuZGx5IGVycm9yXHJcblx0XHRcdG5ldyBOb3RpY2UoJ1VuYWJsZSB0byBvcGVuIGZvbGRlciBwaWNrZXIuIFBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyBPYnNpZGlhbiBvbiBkZXNrdG9wLicpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3BlbiBuYXRpdmUgZmlsZSBwaWNrZXIgZGlhbG9nIGZvciBjb25maWcgZmlsZVxyXG5cdCAqL1xyXG5cdHByaXZhdGUgc2VsZWN0Q29uZmlnRmlsZShkZWZhdWx0UGF0aD86IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IG11bHRpcGxlIHdheXMgdG8gYWNjZXNzIEVsZWN0cm9uIGRpYWxvZyBBUElcclxuXHRcdFx0bGV0IGRpYWxvZzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBmaWx0ZXJzPzogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IGV4dGVuc2lvbnM6IHN0cmluZ1tdIH0+OyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IHwgbnVsbCA9IG51bGw7XHJcblxyXG5cdFx0Ly8gTWV0aG9kIDE6IFRyeSBAZWxlY3Ryb24vcmVtb3RlIChuZXdlciBFbGVjdHJvbiB2ZXJzaW9ucylcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZlxyXG5cdFx0XHRjb25zdCBlbGVjdHJvblJlbW90ZSA9IHJlcXVpcmUoJ0BlbGVjdHJvbi9yZW1vdGUnKSBhcyB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgZmlsdGVycz86IEFycmF5PHsgbmFtZTogc3RyaW5nOyBleHRlbnNpb25zOiBzdHJpbmdbXSB9PjsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9O1xyXG5cdFx0XHRkaWFsb2cgPSBlbGVjdHJvblJlbW90ZT8uZGlhbG9nIHx8IG51bGw7XHJcblx0XHR9IGNhdGNoIHtcclxuXHRcdFx0Ly8gTm90IGF2YWlsYWJsZSwgdHJ5IG5leHQgbWV0aG9kXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTWV0aG9kIDI6IFRyeSBlbGVjdHJvbi5yZW1vdGUuZGlhbG9nIChvbGRlciBFbGVjdHJvbiB2ZXJzaW9ucylcclxuXHRcdGlmICghZGlhbG9nKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmXHJcblx0XHRcdFx0Y29uc3QgZWxlY3Ryb24gPSAoKHdpbmRvdyBhcyB7IHJlcXVpcmU/OiAobW9kdWxlOiBzdHJpbmcpID0+IHVua25vd24gfSkucmVxdWlyZT8uKCdlbGVjdHJvbicpIHx8IHJlcXVpcmUoJ2VsZWN0cm9uJykpIGFzIHsgcmVtb3RlPzogeyBkaWFsb2c/OiB7IHNob3dPcGVuRGlhbG9nU3luYz86IChvcHRpb25zOiB7IHRpdGxlOiBzdHJpbmc7IGRlZmF1bHRQYXRoOiBzdHJpbmc7IGZpbHRlcnM/OiBBcnJheTx7IG5hbWU6IHN0cmluZzsgZXh0ZW5zaW9uczogc3RyaW5nW10gfT47IHByb3BlcnRpZXM6IHN0cmluZ1tdIH0pID0+IHN0cmluZ1tdIHwgdW5kZWZpbmVkIH0gfSB9O1xyXG5cdFx0XHRcdGRpYWxvZyA9IGVsZWN0cm9uPy5yZW1vdGU/LmRpYWxvZyB8fCBudWxsO1xyXG5cdFx0XHR9IGNhdGNoIHtcclxuXHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlLCB0cnkgbmV4dCBtZXRob2RcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1ldGhvZCAzOiBUcnkgZWxlY3Ryb24uZGlhbG9nIGRpcmVjdGx5IChtYWluIHByb2Nlc3MsIG1heSBub3Qgd29yaylcclxuXHRcdGlmICghZGlhbG9nKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmXHJcblx0XHRcdFx0Y29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpIGFzIHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBmaWx0ZXJzPzogQXJyYXk8eyBuYW1lOiBzdHJpbmc7IGV4dGVuc2lvbnM6IHN0cmluZ1tdIH0+OyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH07XHJcblx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb24/LmRpYWxvZyB8fCBudWxsO1xyXG5cdFx0XHR9IGNhdGNoIHtcclxuXHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRcdGlmICghZGlhbG9nIHx8IHR5cGVvZiBkaWFsb2cuc2hvd09wZW5EaWFsb2dTeW5jICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBkaWFsb2cgQVBJIG5vdCBhdmFpbGFibGUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgdmF1bHRQYXRoID0gdGhpcy5nZXRWYXVsdFBhdGgoKTtcclxuXHRcdFx0bGV0IHN0YXJ0UGF0aCA9IGRlZmF1bHRQYXRoIHx8IHZhdWx0UGF0aDtcclxuXHRcdFx0XHJcblx0XHRcdC8vIElmIHdlIGhhdmUgYSBkZXRlY3RlZCBjb25maWcgZmlsZSBwYXRoLCB1c2UgaXRzIGRpcmVjdG9yeVxyXG5cdFx0XHRpZiAoIWRlZmF1bHRQYXRoICYmIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8uY29uZmlnRmlsZVBhdGgpIHtcclxuXHRcdFx0XHRjb25zdCBjb25maWdQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoO1xyXG5cdFx0XHRcdGlmIChwYXRoLmlzQWJzb2x1dGUoY29uZmlnUGF0aCkpIHtcclxuXHRcdFx0XHRcdHN0YXJ0UGF0aCA9IHBhdGguZGlybmFtZShjb25maWdQYXRoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnRQYXRoID0gcGF0aC5kaXJuYW1lKHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgsIGNvbmZpZ1BhdGgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZGVmYXVsdFBhdGggJiYgIXBhdGguaXNBYnNvbHV0ZShkZWZhdWx0UGF0aCkpIHtcclxuXHRcdFx0XHQvLyBDb252ZXJ0IHJlbGF0aXZlIHBhdGggdG8gYWJzb2x1dGUgaWYgbmVlZGVkXHJcblx0XHRcdFx0c3RhcnRQYXRoID0gcGF0aC5yZXNvbHZlKHZhdWx0UGF0aCwgZGVmYXVsdFBhdGgpO1xyXG5cdFx0XHRcdC8vIElmIGl0J3MgYSBmaWxlIHBhdGgsIHVzZSBpdHMgZGlyZWN0b3J5XHJcblx0XHRcdFx0aWYgKHBhdGguZXh0bmFtZShzdGFydFBhdGgpKSB7XHJcblx0XHRcdFx0XHRzdGFydFBhdGggPSBwYXRoLmRpcm5hbWUoc3RhcnRQYXRoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZGVmYXVsdFBhdGggJiYgcGF0aC5pc0Fic29sdXRlKGRlZmF1bHRQYXRoKSkge1xyXG5cdFx0XHRcdC8vIElmIGl0J3MgYSBmaWxlIHBhdGgsIHVzZSBpdHMgZGlyZWN0b3J5XHJcblx0XHRcdFx0aWYgKHBhdGguZXh0bmFtZShkZWZhdWx0UGF0aCkpIHtcclxuXHRcdFx0XHRcdHN0YXJ0UGF0aCA9IHBhdGguZGlybmFtZShkZWZhdWx0UGF0aCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0YXJ0UGF0aCA9IGRlZmF1bHRQYXRoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyh7XHJcblx0XHRcdFx0dGl0bGU6ICdTZWxlY3QgQXN0cm8gQ29uZmlnIEZpbGUnLFxyXG5cdFx0XHRcdGRlZmF1bHRQYXRoOiBzdGFydFBhdGgsXHJcblx0XHRcdFx0ZmlsdGVyczogW1xyXG5cdFx0XHRcdFx0eyBuYW1lOiAnQXN0cm8gQ29uZmlnIEZpbGVzJywgZXh0ZW5zaW9uczogWyd0cycsICdtanMnLCAnanMnLCAnbXRzJywgJ2NqcyddIH0sXHJcblx0XHRcdFx0XHR7IG5hbWU6ICdBbGwgRmlsZXMnLCBleHRlbnNpb25zOiBbJyonXSB9XHJcblx0XHRcdFx0XSxcclxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBbJ29wZW5GaWxlJ11cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0Y29uc3QgYWJzb2x1dGVQYXRoID0gcGF0aC5ub3JtYWxpemUocmVzdWx0WzBdKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50b1JlbGF0aXZlUGF0aChhYnNvbHV0ZVBhdGgpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBvcGVuaW5nIGZpbGUgcGlja2VyOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gU2hvdyB1c2VyLWZyaWVuZGx5IGVycm9yXHJcblx0XHRcdG5ldyBOb3RpY2UoJ1VuYWJsZSB0byBvcGVuIGZpbGUgcGlja2VyLiBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgT2JzaWRpYW4gb24gZGVza3RvcC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdmF1bHQgcGF0aFxyXG5cdCAqL1xyXG5cdHByaXZhdGUgZ2V0VmF1bHRQYXRoKCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XHJcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHRcdC8vIFJlc29sdmUgcGF0aCAoY29udmVydCByZWxhdGl2ZSB0byBhYnNvbHV0ZSwgbm9ybWFsaXplIHNlcGFyYXRvcnMpXHJcblx0XHRpZiAodmF1bHRQYXRoKSB7XHJcblx0XHRcdC8vIElmIGFscmVhZHkgYWJzb2x1dGUsIHJldHVybiBhcy1pcyAobm9ybWFsaXplZClcclxuXHRcdFx0aWYgKHZhdWx0UGF0aC5zdGFydHNXaXRoKCcvJykgfHwgL15bQS1aXTovLnRlc3QodmF1bHRQYXRoKSkge1xyXG5cdFx0XHRcdHJldHVybiB2YXVsdFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIEZvciByZWxhdGl2ZSBwYXRocywgd2UnZCBuZWVkIHRvIHJlc29sdmUsIGJ1dCBpbiBPYnNpZGlhbiBjb250ZXh0LCBiYXNlUGF0aCBzaG91bGQgYmUgYWJzb2x1dGVcclxuXHRcdFx0cmV0dXJuIHZhdWx0UGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcblx0XHR9XHJcblx0XHQvLyBGYWxsYmFjayAtIGluIE9ic2lkaWFuIGNvbnRleHQgdGhpcyBzaG91bGRuJ3QgaGFwcGVuXHJcblx0XHRyZXR1cm4gJy8nO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydCBhYnNvbHV0ZSBwYXRoIHRvIHJlbGF0aXZlIHBhdGggZnJvbSB2YXVsdCByb290XHJcblx0ICovXHJcblx0cHJpdmF0ZSB0b1JlbGF0aXZlUGF0aChhYnNvbHV0ZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XHJcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHRcdGlmICghdmF1bHRQYXRoKSB7XHJcblx0XHRcdHJldHVybiBhYnNvbHV0ZVBhdGg7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGNvbnN0IHZhdWx0Tm9ybWFsaXplZCA9IHZhdWx0UGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuXHRcdGNvbnN0IGFic29sdXRlTm9ybWFsaXplZCA9IGFic29sdXRlUGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuXHRcdFxyXG5cdFx0Ly8gSWYgdGhlIGFic29sdXRlIHBhdGggaXMgd2l0aGluIHRoZSB2YXVsdCwgcmV0dXJuIHJlbGF0aXZlIHBhdGhcclxuXHRcdGlmIChhYnNvbHV0ZU5vcm1hbGl6ZWQuc3RhcnRzV2l0aCh2YXVsdE5vcm1hbGl6ZWQpKSB7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlID0gYWJzb2x1dGVOb3JtYWxpemVkLnNsaWNlKHZhdWx0Tm9ybWFsaXplZC5sZW5ndGgpO1xyXG5cdFx0XHQvLyBSZW1vdmUgbGVhZGluZyBwYXRoIHNlcGFyYXRvclxyXG5cdFx0XHRjb25zdCB0cmltbWVkUmVsYXRpdmUgPSByZWxhdGl2ZS5zdGFydHNXaXRoKCcvJykgPyByZWxhdGl2ZS5zbGljZSgxKSA6IHJlbGF0aXZlO1xyXG5cdFx0XHRyZXR1cm4gdHJpbW1lZFJlbGF0aXZlIHx8ICcuJztcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gSWYgcGF0aCBpcyBvdXRzaWRlIHZhdWx0LCBjYWxjdWxhdGUgcmVsYXRpdmUgcGF0aCBtYW51YWxseVxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gU3BsaXQgcGF0aHMgaW50byBwYXJ0c1xyXG5cdFx0XHRjb25zdCB2YXVsdFBhcnRzID0gdmF1bHROb3JtYWxpemVkLnNwbGl0KCcvJykuZmlsdGVyKHAgPT4gcCk7XHJcblx0XHRcdGNvbnN0IGFic29sdXRlUGFydHMgPSBhYnNvbHV0ZU5vcm1hbGl6ZWQuc3BsaXQoJy8nKS5maWx0ZXIocCA9PiBwKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIEZpbmQgY29tbW9uIHByZWZpeFxyXG5cdFx0XHRsZXQgY29tbW9uTGVuZ3RoID0gMDtcclxuXHRcdFx0d2hpbGUgKGNvbW1vbkxlbmd0aCA8IHZhdWx0UGFydHMubGVuZ3RoICYmIGNvbW1vbkxlbmd0aCA8IGFic29sdXRlUGFydHMubGVuZ3RoICYmIHZhdWx0UGFydHNbY29tbW9uTGVuZ3RoXSA9PT0gYWJzb2x1dGVQYXJ0c1tjb21tb25MZW5ndGhdKSB7XHJcblx0XHRcdFx0Y29tbW9uTGVuZ3RoKys7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIENhbGN1bGF0ZSByZWxhdGl2ZSBwYXRoXHJcblx0XHRcdGNvbnN0IHVwTGV2ZWxzID0gdmF1bHRQYXJ0cy5sZW5ndGggLSBjb21tb25MZW5ndGg7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlUGFydHMgPSBhYnNvbHV0ZVBhcnRzLnNsaWNlKGNvbW1vbkxlbmd0aCk7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlID0gKHVwTGV2ZWxzID4gMCA/ICcuLi8nLnJlcGVhdCh1cExldmVscykgOiAnJykgKyByZWxhdGl2ZVBhcnRzLmpvaW4oJy8nKTtcclxuXHRcdFx0cmV0dXJuIHJlbGF0aXZlIHx8IGFic29sdXRlUGF0aDtcclxuXHRcdH0gY2F0Y2gge1xyXG5cdFx0XHQvLyBJZiByZWxhdGl2ZSBwYXRoIGNhbGN1bGF0aW9uIGZhaWxzLCByZXR1cm4gYWJzb2x1dGUgcGF0aFxyXG5cdFx0XHRyZXR1cm4gYWJzb2x1dGVQYXRoO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFsaWRhdGUoKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5kZXRlY3RlZCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBWYWxpZGF0ZSB0aGF0IGJvdGggcGF0aHMgYXJlIHNldCBhbmQgZXhpc3RcclxuXHRcdGNvbnN0IHByb2plY3RSb290ID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdDtcclxuXHRcdGNvbnN0IGNvbmZpZ0ZpbGVQYXRoID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aDtcclxuXHJcblx0XHRpZiAoIXByb2plY3RSb290IHx8ICFjb25maWdGaWxlUGF0aCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgcGF0aHMgZXhpc3QgKHJlc29sdmUgcmVsYXRpdmUgcGF0aHMgdG8gYWJzb2x1dGUpXHJcblx0XHR0cnkge1xyXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSB0aGlzLmdldFZhdWx0UGF0aCgpO1xyXG5cdFx0XHRjb25zdCByZXNvbHZlZFByb2plY3RSb290ID0gcGF0aC5pc0Fic29sdXRlKHByb2plY3RSb290KSA/IHByb2plY3RSb290IDogcGF0aC5qb2luKHZhdWx0UGF0aCwgcHJvamVjdFJvb3QpO1xyXG5cdFx0XHRjb25zdCByZXNvbHZlZENvbmZpZ0ZpbGVQYXRoID0gcGF0aC5pc0Fic29sdXRlKGNvbmZpZ0ZpbGVQYXRoKSA/IGNvbmZpZ0ZpbGVQYXRoIDogcGF0aC5qb2luKHZhdWx0UGF0aCwgY29uZmlnRmlsZVBhdGgpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKCFmcy5leGlzdHNTeW5jKHJlc29sdmVkUHJvamVjdFJvb3QpIHx8ICFmcy5zdGF0U3luYyhyZXNvbHZlZFByb2plY3RSb290KS5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghZnMuZXhpc3RzU3luYyhyZXNvbHZlZENvbmZpZ0ZpbGVQYXRoKSB8fCAhZnMuc3RhdFN5bmMocmVzb2x2ZWRDb25maWdGaWxlUGF0aCkuaXNGaWxlKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGNhdGNoIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiAnUHJvamVjdCBkZXRlY3Rpb24nO1xyXG5cdH1cclxuXHJcblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiAnRGV0ZWN0IEFzdHJvIHByb2plY3Qgc3RydWN0dXJlJztcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXNcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlc1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCB7IFByb2plY3REZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvamVjdERldGVjdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRkZXRlY3RQcm9qZWN0KCk6IFByb2plY3REZXRlY3Rpb25SZXN1bHQgfCBudWxsIHtcclxuXHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XHJcblx0XHRjb25zdCBhZGFwdGVyID0gdmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XHJcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHRcdFxyXG5cdFx0aWYgKCF2YXVsdFBhdGgpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2VhcmNoIHVwd2FyZCBmcm9tIHZhdWx0IHBhdGggZm9yIGFzdHJvLmNvbmZpZyBmaWxlc1xyXG5cdFx0Y29uc3QgY29uZmlnUmVzdWx0ID0gdGhpcy5zZWFyY2hVcHdhcmRGb3JDb25maWcodmF1bHRQYXRoKTtcclxuXHRcdFxyXG5cdFx0aWYgKCFjb25maWdSZXN1bHQpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIHZhdWx0IGxvY2F0aW9uIHJlbGF0aXZlIHRvIHByb2plY3RcclxuXHRcdGNvbnN0IHZhdWx0TG9jYXRpb24gPSB0aGlzLmRldGVjdFZhdWx0TG9jYXRpb24odmF1bHRQYXRoLCBjb25maWdSZXN1bHQucHJvamVjdFJvb3QpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHByb2plY3RSb290OiBjb25maWdSZXN1bHQucHJvamVjdFJvb3QsXHJcblx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiBjb25maWdSZXN1bHQuY29uZmlnRmlsZVBhdGgsXHJcblx0XHRcdHZhdWx0TG9jYXRpb25cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZWFyY2ggdXB3YXJkIGZyb20gdGhlIHZhdWx0IHBhdGggdG8gZmluZCBhbiBBc3RybyBjb25maWcgZmlsZS5cclxuXHQgKiBUaGlzIGFsbG93cyB0aGUgdmF1bHQgdG8gYmUgYW55d2hlcmUgd2l0aGluIHRoZSBBc3RybyBwcm9qZWN0IHN0cnVjdHVyZS5cclxuXHQgKiBCaWFzIHRvd2FyZHMgc3JjL2NvbmZpZy50cyBpZiBpdCBleGlzdHMgYWxvbmdzaWRlIGEgcm9vdCBjb25maWcgZmlsZS5cclxuXHQgKi9cclxuXHRwcml2YXRlIHNlYXJjaFVwd2FyZEZvckNvbmZpZyhzdGFydFBhdGg6IHN0cmluZyk6IHsgcHJvamVjdFJvb3Q6IHN0cmluZzsgY29uZmlnRmlsZVBhdGg6IHN0cmluZyB9IHwgbnVsbCB7XHJcblx0XHRjb25zdCByb290Q29uZmlnRmlsZU5hbWVzID0gW1xyXG5cdFx0XHQnYXN0cm8uY29uZmlnLm1qcycsXHJcblx0XHRcdCdhc3Ryby5jb25maWcudHMnLFxyXG5cdFx0XHQnYXN0cm8uY29uZmlnLmpzJyxcclxuXHRcdFx0J2FzdHJvLmNvbmZpZy5tdHMnLFxyXG5cdFx0XHQnYXN0cm8uY29uZmlnLmNqcydcclxuXHRcdF07XHJcblx0XHRjb25zdCBzcmNDb25maWdGaWxlTmFtZSA9ICdzcmMvY29uZmlnLnRzJztcclxuXHJcblx0XHRsZXQgY3VycmVudERpciA9IHBhdGgucmVzb2x2ZShzdGFydFBhdGgpO1xyXG5cdFx0Y29uc3Qgcm9vdCA9IHBhdGgucGFyc2UoY3VycmVudERpcikucm9vdDtcclxuXHJcblx0XHQvLyBXYWxrIHVwIHRoZSBkaXJlY3RvcnkgdHJlZVxyXG5cdFx0d2hpbGUgKGN1cnJlbnREaXIgIT09IHJvb3QpIHtcclxuXHRcdFx0Ly8gMS4gQ2hlY2sgZm9yIHNyYy9jb25maWcudHMgZmlyc3QgKHRoZSBwcmlvcml0aXplZCBjaG9pY2UpXHJcblx0XHRcdGNvbnN0IHNyY0NvbmZpZ1BhdGggPSBwYXRoLmpvaW4oY3VycmVudERpciwgc3JjQ29uZmlnRmlsZU5hbWUpO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGlmIChmcy5leGlzdHNTeW5jKHNyY0NvbmZpZ1BhdGgpICYmIGZzLnN0YXRTeW5jKHNyY0NvbmZpZ1BhdGgpLmlzRmlsZSgpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRwcm9qZWN0Um9vdDogY3VycmVudERpcixcclxuXHRcdFx0XHRcdFx0Y29uZmlnRmlsZVBhdGg6IHNyY0NvbmZpZ1BhdGhcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoIHtcclxuXHRcdFx0XHQvLyBDb250aW51ZSB0byBjaGVjayByb290IGNvbmZpZ3MgaWYgc3JjIGNoZWNrIGZhaWxzXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDIuIENoZWNrIGZvciByb290LWxldmVsIGNvbmZpZyBmaWxlcyAocHJpb3JpdGl6aW5nIC5tanMpXHJcblx0XHRcdGZvciAoY29uc3QgZmlsZU5hbWUgb2Ygcm9vdENvbmZpZ0ZpbGVOYW1lcykge1xyXG5cdFx0XHRcdGNvbnN0IGNvbmZpZ1BhdGggPSBwYXRoLmpvaW4oY3VycmVudERpciwgZmlsZU5hbWUpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRpZiAoZnMuZXhpc3RzU3luYyhjb25maWdQYXRoKSAmJiBmcy5zdGF0U3luYyhjb25maWdQYXRoKS5pc0ZpbGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHByb2plY3RSb290OiBjdXJyZW50RGlyLFxyXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ0ZpbGVQYXRoOiBjb25maWdQYXRoXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaCB7XHJcblx0XHRcdFx0XHQvLyBDb250aW51ZSBzZWFyY2hpbmdcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE1vdmUgdXAgb25lIGRpcmVjdG9yeVxyXG5cdFx0XHRjb25zdCBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoY3VycmVudERpcik7XHJcblx0XHRcdGlmIChwYXJlbnREaXIgPT09IGN1cnJlbnREaXIpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRjdXJyZW50RGlyID0gcGFyZW50RGlyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lIHZhdWx0IGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBkZXRlY3RlZCBwcm9qZWN0IHJvb3QuXHJcblx0ICovXHJcblx0cHJpdmF0ZSBkZXRlY3RWYXVsdExvY2F0aW9uKHZhdWx0UGF0aDogc3RyaW5nLCBwcm9qZWN0Um9vdDogc3RyaW5nKTogJ2NvbnRlbnQnIHwgJ25lc3RlZC1jb250ZW50JyB8ICdyb290JyB7XHJcblx0XHRjb25zdCBub3JtYWxpemVkVmF1bHRQYXRoID0gcGF0aC5ub3JtYWxpemUodmF1bHRQYXRoKTtcclxuXHRcdGNvbnN0IG5vcm1hbGl6ZWRQcm9qZWN0Um9vdCA9IHBhdGgubm9ybWFsaXplKHByb2plY3RSb290KTtcclxuXHRcdFxyXG5cdFx0Ly8gQ2hlY2sgaWYgdmF1bHQgaXMgd2l0aGluIHByb2plY3Qgcm9vdFxyXG5cdFx0aWYgKCFub3JtYWxpemVkVmF1bHRQYXRoLnN0YXJ0c1dpdGgobm9ybWFsaXplZFByb2plY3RSb290KSkge1xyXG5cdFx0XHRyZXR1cm4gJ3Jvb3QnO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEdldCByZWxhdGl2ZSBwYXRoIGZyb20gcHJvamVjdCByb290IHRvIHZhdWx0XHJcblx0XHRjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKG5vcm1hbGl6ZWRQcm9qZWN0Um9vdCwgbm9ybWFsaXplZFZhdWx0UGF0aCk7XHJcblx0XHRjb25zdCBwYXRoUGFydHMgPSByZWxhdGl2ZVBhdGguc3BsaXQocGF0aC5zZXApLmZpbHRlcihwYXJ0ID0+IHBhcnQubGVuZ3RoID4gMCk7XHJcblx0XHRcclxuXHRcdC8vIENoZWNrIGlmIHZhdWx0IGlzIGluIGEgZm9sZGVyIG5hbWVkIFwiY29udGVudFwiIHdpdGggcGFyZW50IFwic3JjXCJcclxuXHRcdGNvbnN0IGNvbnRlbnRJbmRleCA9IHBhdGhQYXJ0cy5maW5kSW5kZXgocGFydCA9PiBwYXJ0LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50Jyk7XHJcblx0XHRpZiAoY29udGVudEluZGV4ID4gMCkge1xyXG5cdFx0XHRjb25zdCBwYXJlbnRJbmRleCA9IGNvbnRlbnRJbmRleCAtIDE7XHJcblx0XHRcdGlmIChwYXJlbnRJbmRleCA+PSAwICYmIHBhdGhQYXJ0c1twYXJlbnRJbmRleF0udG9Mb3dlckNhc2UoKSA9PT0gJ3NyYycpIHtcclxuXHRcdFx0XHRyZXR1cm4gJ2NvbnRlbnQnO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIENoZWNrIGZvciBuZXN0ZWQgY29udGVudCBmb2xkZXJzIChzcmMvY29udGVudC9wb3N0cywgZXRjLilcclxuXHRcdGNvbnN0IHNyY0luZGV4ID0gcGF0aFBhcnRzLmZpbmRJbmRleChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSA9PT0gJ3NyYycpO1xyXG5cdFx0aWYgKHNyY0luZGV4ID49IDAgJiYgc3JjSW5kZXggPCBwYXRoUGFydHMubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRjb25zdCBuZXh0UGFydCA9IHBhdGhQYXJ0c1tzcmNJbmRleCArIDFdO1xyXG5cdFx0XHRpZiAobmV4dFBhcnQudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQnKSB7XHJcblx0XHRcdFx0cmV0dXJuICduZXN0ZWQtY29udGVudCc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuICdyb290JztcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAgfSBmcm9tICdvYnNpZGlhbic7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXNcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1ub2RlanMtbW9kdWxlc1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCB7IFByb2plY3REZXRlY3Rpb25SZXN1bHQsIENvbnRlbnRUeXBlQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1keERldGVjdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlY3QgaWYgTURYIGZpbGVzIGFyZSBwcmVzZW50IGluIHRoZSBjb250ZW50IGZvbGRlcnNcclxuXHQgKiBTY2FucyBhbGwgY29udGVudCB0eXBlIGZvbGRlcnMgKHBvc3RzLCBwYWdlcywgZXRjLikgZm9yIC5tZHggZmlsZXNcclxuXHQgKi9cclxuXHRkZXRlY3RNZHhVc2FnZShcclxuXHRcdHByb2plY3REZXRlY3Rpb246IFByb2plY3REZXRlY3Rpb25SZXN1bHQsXHJcblx0XHRjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW11cclxuXHQpOiBib29sZWFuIHtcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yLmRldGVjdE1keFVzYWdlOiBjYWxsZWQgd2l0aCcsIHtcclxuXHRcdFx0cHJvamVjdFJvb3Q6IHByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290LFxyXG5cdFx0XHR2YXVsdExvY2F0aW9uOiBwcm9qZWN0RGV0ZWN0aW9uPy52YXVsdExvY2F0aW9uLFxyXG5cdFx0XHRjb250ZW50VHlwZXNDb3VudDogY29udGVudFR5cGVzPy5sZW5ndGhcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICghcHJvamVjdERldGVjdGlvbikge1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogTm8gcHJvamVjdERldGVjdGlvbiwgcmV0dXJuaW5nIGZhbHNlJyk7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB2YXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xyXG5cdFx0Y29uc3QgYWRhcHRlciA9IHZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xyXG5cdFx0Y29uc3QgdmF1bHRQYXRoID0gYWRhcHRlci5iYXNlUGF0aCB8fCBhZGFwdGVyLnBhdGg7XHJcblx0XHRcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiB2YXVsdFBhdGggPScsIHZhdWx0UGF0aCk7XHJcblx0XHRcclxuXHRcdGlmICghdmF1bHRQYXRoKSB7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBObyB2YXVsdFBhdGgsIHJldHVybmluZyBmYWxzZScpO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gR2V0IHByb2plY3Qgcm9vdCBwYXRoXHJcblx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3Q7XHJcblx0XHRsZXQgcHJvamVjdFJvb3RQYXRoOiBzdHJpbmc7XHJcblx0XHRcclxuXHRcdGlmIChwYXRoLmlzQWJzb2x1dGUocHJvamVjdFJvb3QpKSB7XHJcblx0XHRcdHByb2plY3RSb290UGF0aCA9IHByb2plY3RSb290O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gUmVzb2x2ZSByZWxhdGl2ZSBwYXRoIGZyb20gdmF1bHQgcm9vdFxyXG5cdFx0XHRwcm9qZWN0Um9vdFBhdGggPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCBwcm9qZWN0Um9vdCk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBwcm9qZWN0Um9vdFBhdGggPScsIHByb2plY3RSb290UGF0aCk7XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIGNvbnRlbnQgZGlyZWN0b3J5IGJhc2VkIG9uIHZhdWx0IGxvY2F0aW9uXHJcblx0XHRsZXQgY29udGVudEJhc2VQYXRoOiBzdHJpbmc7XHJcblx0XHRpZiAocHJvamVjdERldGVjdGlvbi52YXVsdExvY2F0aW9uID09PSAnY29udGVudCcpIHtcclxuXHRcdFx0Ly8gVmF1bHQgaXMgYXQgc3JjL2NvbnRlbnQsIHNvIGNvbnRlbnQgaXMgYXQgdmF1bHQgcm9vdFxyXG5cdFx0XHRjb250ZW50QmFzZVBhdGggPSB2YXVsdFBhdGg7XHJcblx0XHR9IGVsc2UgaWYgKHByb2plY3REZXRlY3Rpb24udmF1bHRMb2NhdGlvbiA9PT0gJ25lc3RlZC1jb250ZW50Jykge1xyXG5cdFx0XHQvLyBWYXVsdCBpcyBuZXN0ZWQgaW4gc3JjL2NvbnRlbnQvc29tZXRoaW5nLCBnbyB1cCB0byBzcmMvY29udGVudFxyXG5cdFx0XHRjb250ZW50QmFzZVBhdGggPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCAnLi4nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFZhdWx0IGlzIGF0IHJvb3QsIGNvbnRlbnQgc2hvdWxkIGJlIGF0IHByb2plY3RSb290L3NyYy9jb250ZW50XHJcblx0XHRcdGNvbnRlbnRCYXNlUGF0aCA9IHBhdGguam9pbihwcm9qZWN0Um9vdFBhdGgsICdzcmMnLCAnY29udGVudCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBjb250ZW50QmFzZVBhdGggPScsIGNvbnRlbnRCYXNlUGF0aCk7XHJcblx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogdmF1bHRMb2NhdGlvbiA9JywgcHJvamVjdERldGVjdGlvbi52YXVsdExvY2F0aW9uKTtcclxuXHRcdGNvbnNvbGUuZGVidWcoJ01keERldGVjdG9yOiBjb250ZW50VHlwZXMgdG8gc2NhbiA9JywgY29udGVudFR5cGVzLm1hcChjdCA9PiBgJHtjdC5uYW1lfSAoJHtjdC5mb2xkZXJ9KWApKTtcclxuXHJcblx0XHQvLyBTY2FuIGVhY2ggY29udGVudCB0eXBlIGZvbGRlciBmb3IgLm1keCBmaWxlcyAoY2hlY2sgYm90aCBlbmFibGVkIGFuZCBkaXNhYmxlZClcclxuXHRcdC8vIFdlIHNjYW4gYWxsIGNvbnRlbnQgdHlwZXMgYmVjYXVzZSBNRFggZmlsZXMgbWlnaHQgZXhpc3QgZXZlbiBpZiB0aGUgdHlwZSBpcyBkaXNhYmxlZFxyXG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBjb250ZW50VHlwZXMpIHtcclxuXHRcdFx0bGV0IGNvbnRlbnRUeXBlUGF0aDogc3RyaW5nO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSWYgY29udGVudFR5cGUuZm9sZGVyIGFscmVhZHkgY29udGFpbnMgc3JjL2NvbnRlbnQgKHZhdWx0IGF0IHByb2plY3Qgcm9vdCksXHJcblx0XHRcdC8vIHVzZSBpdCByZWxhdGl2ZSB0byBwcm9qZWN0IHJvb3QuIE90aGVyd2lzZSwgdXNlIGl0IHJlbGF0aXZlIHRvIGNvbnRlbnRCYXNlUGF0aC5cclxuXHRcdFx0aWYgKGNvbnRlbnRUeXBlLmZvbGRlci5zdGFydHNXaXRoKCdzcmMvY29udGVudC8nKSkge1xyXG5cdFx0XHRcdGNvbnRlbnRUeXBlUGF0aCA9IHBhdGguam9pbihwcm9qZWN0Um9vdFBhdGgsIGNvbnRlbnRUeXBlLmZvbGRlcik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29udGVudFR5cGVQYXRoID0gcGF0aC5qb2luKGNvbnRlbnRCYXNlUGF0aCwgY29udGVudFR5cGUuZm9sZGVyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IHNjYW5uaW5nJywgY29udGVudFR5cGVQYXRoLCAnKGVuYWJsZWQ6JywgY29udGVudFR5cGUuZW5hYmxlZCwgJyknKTtcclxuXHRcdFx0XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0aWYgKGZzLmV4aXN0c1N5bmMoY29udGVudFR5cGVQYXRoKSAmJiBmcy5zdGF0U3luYyhjb250ZW50VHlwZVBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGZvdW5kTWR4ID0gdGhpcy5zY2FuRGlyZWN0b3J5Rm9yTWR4KGNvbnRlbnRUeXBlUGF0aCk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogZm91bmQgTURYIGluJywgY29udGVudFR5cGVQYXRoLCAnPScsIGZvdW5kTWR4KTtcclxuXHRcdFx0XHRcdGlmIChmb3VuZE1keCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gRm91bmQgYXQgbGVhc3Qgb25lIC5tZHggZmlsZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3RvcjogcGF0aCBkb2VzIG5vdCBleGlzdCBvciBpcyBub3QgYSBkaXJlY3Rvcnk6JywgY29udGVudFR5cGVQYXRoLCAnZXhpc3RzOicsIGZzLmV4aXN0c1N5bmMoY29udGVudFR5cGVQYXRoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHRcdC8vIENvbnRpbnVlIHRvIG5leHQgZm9sZGVyIGlmIHRoaXMgb25lIGZhaWxzXHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnTWR4RGV0ZWN0b3I6IGVycm9yIHNjYW5uaW5nJywgY29udGVudFR5cGVQYXRoLCBlcnJvcik7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjb25zb2xlLmRlYnVnKCdNZHhEZXRlY3Rvcjogbm8gTURYIGZpbGVzIGZvdW5kJyk7XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVjdXJzaXZlbHkgc2NhbiBhIGRpcmVjdG9yeSBmb3IgLm1keCBmaWxlc1xyXG5cdCAqL1xyXG5cdHByaXZhdGUgc2NhbkRpcmVjdG9yeUZvck1keChkaXJQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IGVudHJpZXMgPSBmcy5yZWFkZGlyU3luYyhkaXJQYXRoLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuXHRcdFx0XHRjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJQYXRoLCBlbnRyeS5uYW1lKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoZW50cnkuaXNGaWxlKCkgJiYgZW50cnkubmFtZS5lbmRzV2l0aCgnLm1keCcpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTsgLy8gRm91bmQgYW4gLm1keCBmaWxlXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0XHQvLyBSZWN1cnNpdmVseSBzY2FuIHN1YmRpcmVjdG9yaWVzXHJcblx0XHRcdFx0XHRpZiAodGhpcy5zY2FuRGlyZWN0b3J5Rm9yTWR4KGZ1bGxQYXRoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2gge1xyXG5cdFx0XHQvLyBJZiB3ZSBjYW4ndCByZWFkIHRoZSBkaXJlY3RvcnksIHJldHVybiBmYWxzZVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZvbGRlciB9IGZyb20gJ29ic2lkaWFuJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbm9kZWpzLW1vZHVsZXNcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBDb250ZW50VHlwZUNvbmZpZywgUHJvamVjdERldGVjdGlvblJlc3VsdCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIENvbnRlbnRUeXBlRGV0ZWN0b3Ige1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdH1cblxuXHRkZXRlY3RDb250ZW50VHlwZXMocHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQpOiBDb250ZW50VHlwZUNvbmZpZ1tdIHtcblx0XHQvLyBGaW5kIHRoZSBjb3JyZWN0IHNyYy9jb250ZW50IGRpcmVjdG9yeVxuXHRcdGNvbnN0IGNvbnRlbnRGb2xkZXIgPSB0aGlzLmZpbmRDb250ZW50RGlyZWN0b3J5KHByb2plY3REZXRlY3Rpb24pO1xuXHRcdFxuXHRcdGlmICghY29udGVudEZvbGRlcikge1xuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gb2xkIGJlaGF2aW9yIGlmIHdlIGNhbid0IGZpbmQgc3JjL2NvbnRlbnRcblx0XHRcdHJldHVybiB0aGlzLmRldGVjdENvbnRlbnRUeXBlc0Zyb21WYXVsdFJvb3QoKTtcblx0XHR9XG5cblx0XHRjb25zdCBjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10gPSBbXTtcblx0XHRjb25zdCBmb2xkZXJzID0gdGhpcy5nZXRUb3BMZXZlbEZvbGRlcnMoY29udGVudEZvbGRlcik7XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBmb2xkZXIgb2YgZm9sZGVycykge1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSB0aGlzLmRldGVjdENvbnRlbnRUeXBlKGZvbGRlcik7XG5cdFx0XHRpZiAoY29udGVudFR5cGUpIHtcblx0XHRcdFx0Y29udGVudFR5cGVzLnB1c2goY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gY29udGVudFR5cGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmQgdGhlIHNyYy9jb250ZW50IGRpcmVjdG9yeSByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSB2YXVsdCBpcyBsb2NhdGVkLlxuXHQgKiBIYW5kbGVzIGNhc2VzIHdoZXJlIHZhdWx0IGlzIGF0OlxuXHQgKiAtIHNyYyBsZXZlbCAobmVlZCB0byBnbyBpbnRvIHNyYy9jb250ZW50KVxuXHQgKiAtIHNyYy9jb250ZW50IGxldmVsIChhbHJlYWR5IHRoZXJlKVxuXHQgKiAtIHNyYy9jb250ZW50L3Bvc3QgbGV2ZWwgKHZhdWx0IGlzIGluc2lkZSBhIGNvbnRlbnQgdHlwZSwgY2FuJ3QgYWNjZXNzIHBhcmVudCwgcmV0dXJuIG51bGwgdG8gdXNlIGZhbGxiYWNrKVxuXHQgKi9cblx0cHJpdmF0ZSBmaW5kQ29udGVudERpcmVjdG9yeShwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCk6IFRGb2xkZXIgfCBudWxsIHtcblx0XHRpZiAoIXByb2plY3REZXRlY3Rpb24gfHwgIXByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGNvbnN0IHZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XG5cdFx0Y29uc3QgYWRhcHRlciA9IHZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xuXHRcdGNvbnN0IHZhdWx0UGF0aCA9IGFkYXB0ZXIuYmFzZVBhdGggfHwgYWRhcHRlci5wYXRoO1xuXHRcdFxuXHRcdGlmICghdmF1bHRQYXRoKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBSZXNvbHZlIHByb2plY3Qgcm9vdCB0byBhYnNvbHV0ZSBwYXRoXG5cdFx0Ly8gSGFuZGxlIGJvdGggYWJzb2x1dGUgYW5kIHJlbGF0aXZlIHBhdGhzXG5cdFx0bGV0IHByb2plY3RSb290OiBzdHJpbmc7XG5cdFx0aWYgKHBhdGguaXNBYnNvbHV0ZShwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KSkge1xuXHRcdFx0cHJvamVjdFJvb3QgPSBwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBSZWxhdGl2ZSBwYXRoIC0gcmVzb2x2ZSByZWxhdGl2ZSB0byB2YXVsdFxuXHRcdFx0cHJvamVjdFJvb3QgPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCBwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNyYy9jb250ZW50IHBhdGhcblx0XHRjb25zdCBleHBlY3RlZENvbnRlbnRQYXRoID0gcGF0aC5qb2luKHByb2plY3RSb290LCAnc3JjJywgJ2NvbnRlbnQnKTtcblx0XHRcblx0XHQvLyBDaGVjayBpZiBzcmMvY29udGVudCBleGlzdHMgaW4gdGhlIGZpbGUgc3lzdGVtXG5cdFx0aWYgKCFmcy5leGlzdHNTeW5jKGV4cGVjdGVkQ29udGVudFBhdGgpIHx8ICFmcy5zdGF0U3luYyhleHBlY3RlZENvbnRlbnRQYXRoKS5pc0RpcmVjdG9yeSgpKSB7XG5cdFx0XHQvLyBzcmMvY29udGVudCBkb2Vzbid0IGV4aXN0LCBjYW4ndCBmaW5kIGl0XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBOb3cgZmluZCB0aGUgY29ycmVzcG9uZGluZyBURm9sZGVyIGluIE9ic2lkaWFuJ3MgdmF1bHQgc3RydWN0dXJlXG5cdFx0Ly8gV2UgbmVlZCB0byBuYXZpZ2F0ZSBmcm9tIHZhdWx0IHJvb3QgdG8gc3JjL2NvbnRlbnRcblx0XHRjb25zdCB2YXVsdFJvb3QgPSB2YXVsdC5nZXRSb290KCk7XG5cdFx0aWYgKCEodmF1bHRSb290IGluc3RhbmNlb2YgVEZvbGRlcikpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSByZWxhdGl2ZSBwYXRoIGZyb20gdmF1bHQgdG8gc3JjL2NvbnRlbnRcblx0XHRjb25zdCB2YXVsdE5vcm1hbGl6ZWQgPSBwYXRoLnJlc29sdmUodmF1bHRQYXRoKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGNvbnN0IGNvbnRlbnROb3JtYWxpemVkID0gcGF0aC5yZXNvbHZlKGV4cGVjdGVkQ29udGVudFBhdGgpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XG5cdFx0Ly8gSWYgc3JjL2NvbnRlbnQgaXMgd2l0aGluIHRoZSB2YXVsdCwgZmluZCBpdCBieSBwYXRoXG5cdFx0aWYgKGNvbnRlbnROb3JtYWxpemVkLnN0YXJ0c1dpdGgodmF1bHROb3JtYWxpemVkKSkge1xuXHRcdFx0Y29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZShwYXRoLnJlc29sdmUodmF1bHRQYXRoKSwgcGF0aC5yZXNvbHZlKGV4cGVjdGVkQ29udGVudFBhdGgpKTtcblx0XHRcdC8vIE5vcm1hbGl6ZSB0byB1c2UgZm9yd2FyZCBzbGFzaGVzIGZvciBPYnNpZGlhblxuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZFJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlUGF0aC5zcGxpdChwYXRoLnNlcCkuam9pbignLycpO1xuXHRcdFx0Y29uc3QgcGF0aFBhcnRzID0gbm9ybWFsaXplZFJlbGF0aXZlUGF0aC5zcGxpdCgnLycpLmZpbHRlcihwYXJ0ID0+IHBhcnQubGVuZ3RoID4gMCk7XG5cdFx0XHRcblx0XHRcdC8vIElmIHJlbGF0aXZlIHBhdGggaXMgZW1wdHksIHZhdWx0IHJvb3QgSVMgc3JjL2NvbnRlbnRcblx0XHRcdGlmIChwYXRoUGFydHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiB2YXVsdFJvb3Q7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIE5hdmlnYXRlIGZyb20gdmF1bHQgcm9vdCB0byBzcmMvY29udGVudFxuXHRcdFx0bGV0IGN1cnJlbnRGb2xkZXI6IFRGb2xkZXIgPSB2YXVsdFJvb3Q7XG5cdFx0XHRmb3IgKGNvbnN0IHBhcnQgb2YgcGF0aFBhcnRzKSB7XG5cdFx0XHRcdGlmICghY3VycmVudEZvbGRlci5jaGlsZHJlbikge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBjaGlsZCA9IGN1cnJlbnRGb2xkZXIuY2hpbGRyZW4uZmluZChjID0+IGMgaW5zdGFuY2VvZiBURm9sZGVyICYmIGMubmFtZSA9PT0gcGFydCk7XG5cdFx0XHRcdGlmICghKGNoaWxkIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y3VycmVudEZvbGRlciA9IGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY3VycmVudEZvbGRlcjtcblx0XHR9XG5cblx0XHQvLyBJZiBzcmMvY29udGVudCBpcyBvdXRzaWRlL2Fib3ZlIHRoZSB2YXVsdCAoZS5nLiwgdmF1bHQgaXMgYXQgc3JjL2NvbnRlbnQvcG9zdCksXG5cdFx0Ly8gd2UgY2FuJ3QgYWNjZXNzIGl0IHZpYSBPYnNpZGlhbidzIEFQSS4gUmV0dXJuIG51bGwgdG8gdXNlIGZhbGxiYWNrIGJlaGF2aW9yLlxuXHRcdC8vIFRoZSBmYWxsYmFjayB3aWxsIHNjYW4gdGhlIHZhdWx0IHJvb3QsIHdoaWNoIGluIHRoaXMgY2FzZSB3b3VsZCBiZSBhIGNvbnRlbnQgdHlwZSBmb2xkZXIuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogRmFsbGJhY2s6IGRldGVjdCBjb250ZW50IHR5cGVzIGZyb20gdmF1bHQgcm9vdCAob2xkIGJlaGF2aW9yKVxuXHQgKiBUaGlzIGlzIHVzZWQgd2hlbiB3ZSBjYW4ndCBmaW5kIHNyYy9jb250ZW50LCBlLmcuLCB3aGVuIHZhdWx0IGlzIGluc2lkZSBhIGNvbnRlbnQgdHlwZSBmb2xkZXJcblx0ICovXG5cdHByaXZhdGUgZGV0ZWN0Q29udGVudFR5cGVzRnJvbVZhdWx0Um9vdCgpOiBDb250ZW50VHlwZUNvbmZpZ1tdIHtcblx0XHRjb25zdCB2YXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuXHRcdGNvbnN0IHJvb3QgPSB2YXVsdC5nZXRSb290KCk7XG5cdFx0XG5cdFx0aWYgKCEocm9vdCBpbnN0YW5jZW9mIFRGb2xkZXIpKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gW107XG5cdFx0Y29uc3QgZm9sZGVycyA9IHRoaXMuZ2V0VG9wTGV2ZWxGb2xkZXJzKHJvb3QpO1xuXHRcdFxuXHRcdC8vIElmIHZhdWx0IHJvb3QgaGFzIGZvbGRlcnMsIHRyZWF0IHRoZW0gYXMgY29udGVudCB0eXBlc1xuXHRcdC8vIChUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgdmF1bHQgaXMgYXQgc3JjL2NvbnRlbnQvcG9zdCBhbmQgcG9zdCBoYXMgc3ViZm9sZGVycylcblx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBmb2xkZXJzKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IHRoaXMuZGV0ZWN0Q29udGVudFR5cGUoZm9sZGVyKTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRjb250ZW50VHlwZXMucHVzaChjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIElmIG5vIGZvbGRlcnMgZm91bmQgYnV0IHdlIGhhdmUgYSB2YXVsdCByb290IHdpdGggYSBtZWFuaW5nZnVsIG5hbWUsXG5cdFx0Ly8gYW5kIGl0J3MgbGlrZWx5IGEgY29udGVudCB0eXBlIGZvbGRlciAoZS5nLiwgdmF1bHQgaXMgYXQgc3JjL2NvbnRlbnQvcG9zdCksXG5cdFx0Ly8gd2UgY291bGQgdHJlYXQgdGhlIHZhdWx0IHJvb3QgaXRzZWxmIGFzIGEgY29udGVudCB0eXBlLlxuXHRcdC8vIEhvd2V2ZXIsIHRoaXMgaXMgdHJpY2t5IGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyB0aGUgdmF1bHQgcm9vdCdzIG5hbWUgaW4gcmVsYXRpb24gdG8gdGhlIHByb2plY3QuXG5cdFx0Ly8gRm9yIG5vdywgd2UnbGwgb25seSBkZXRlY3QgZm9sZGVycyB3aXRoaW4gdGhlIHZhdWx0IHJvb3QuXG5cdFx0XG5cdFx0cmV0dXJuIGNvbnRlbnRUeXBlcztcblx0fVxuXG5cdHByaXZhdGUgZ2V0VG9wTGV2ZWxGb2xkZXJzKGZvbGRlcjogVEZvbGRlcik6IFRGb2xkZXJbXSB7XG5cdFx0Y29uc3QgZm9sZGVyczogVEZvbGRlcltdID0gW107XG5cdFx0XG5cdFx0aWYgKCFmb2xkZXIuY2hpbGRyZW4pIHtcblx0XHRcdHJldHVybiBmb2xkZXJzO1xuXHRcdH1cblx0XHRcblx0XHRmb3IgKGNvbnN0IGNoaWxkIG9mIGZvbGRlci5jaGlsZHJlbikge1xuXHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVEZvbGRlcikge1xuXHRcdFx0XHQvLyBTa2lwIHNwZWNpYWwgZm9sZGVyc1xuXHRcdFx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XG5cdFx0XHRcdGlmICghY2hpbGQubmFtZS5zdGFydHNXaXRoKCcuJykgJiYgXG5cdFx0XHRcdFx0Y2hpbGQubmFtZSAhPT0gJ2Jhc2VzJyAmJiBcblx0XHRcdFx0XHRjaGlsZC5uYW1lICE9PSAnX2Jhc2VzJyAmJlxuXHRcdFx0XHRcdGNoaWxkLm5hbWUgIT09ICdub2RlX21vZHVsZXMnICYmXG5cdFx0XHRcdFx0Y2hpbGQubmFtZSAhPT0gY29uZmlnRGlyKSB7XG5cdFx0XHRcdFx0Zm9sZGVycy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZm9sZGVycztcblx0fVxuXG5cdHByaXZhdGUgZGV0ZWN0Q29udGVudFR5cGUoZm9sZGVyOiBURm9sZGVyKTogQ29udGVudFR5cGVDb25maWcgfCBudWxsIHtcblx0XHRjb25zdCBuYW1lID0gdGhpcy5jYXBpdGFsaXplRmlyc3QoZm9sZGVyLm5hbWUpO1xuXHRcdFxuXHRcdC8vIEFsbCBkaXNjb3ZlcmVkIGNvbnRlbnQgZm9sZGVycyBhcmUgZW5hYmxlZCBieSBkZWZhdWx0XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiBgY29udGVudC10eXBlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTEpfWAsXG5cdFx0XHRuYW1lLFxuXHRcdFx0Zm9sZGVyOiBmb2xkZXIucGF0aCwgLy8gVXNlIHZhdWx0LXJlbGF0aXZlIHBhdGggaW5zdGVhZCBvZiBqdXN0IHRoZSBmb2xkZXIgbmFtZVxuXHRcdFx0ZmlsZU9yZ2FuaXphdGlvbjogJ2ZpbGUnLFxuXHRcdFx0ZW5hYmxlZDogdHJ1ZSwgLy8gRW5hYmxlIGFsbCBkaXNjb3ZlcmVkIGNvbnRlbnQgdHlwZXMgYnkgZGVmYXVsdFxuXHRcdFx0aW5kZXhGaWxlTmFtZTogJ2luZGV4J1xuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIGNhcGl0YWxpemVGaXJzdChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBOb3RpY2UsIFRGb2xkZXIsIFRGaWxlLCBBYnN0cmFjdElucHV0U3VnZ2VzdCwgc2V0SWNvbiB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiBmb3Igc2V0Q3NzUHJvcHMgKG1heSBub3QgYmUgaW4gdHlwZXMgeWV0KVxyXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcclxuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcclxuXHRcdGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcclxuXHR9XHJcbn1cclxuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcclxuaW1wb3J0IHsgV2l6YXJkU3RhdGUsIENvbnRlbnRUeXBlQ29uZmlnIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBDb250ZW50VHlwZURldGVjdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvQ29udGVudFR5cGVEZXRlY3Rvcic7XHJcbmltcG9ydCB7IEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IgfSBmcm9tICcuLi8uLi91dGlscy9Bc3Ryb0NvbXBvc2VyQ29uZmlnJztcclxuXHJcbi8vIEZvbGRlciBuYW1lIHN1Z2dlc3RlciBmb3IgYXR0YWNobWVudCBmb2xkZXJcclxuY2xhc3MgRm9sZGVyTmFtZVN1Z2dlc3QgZXh0ZW5kcyBBYnN0cmFjdElucHV0U3VnZ2VzdDxzdHJpbmc+IHtcclxuXHRwcml2YXRlIGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQ7XHJcblx0cHJpdmF0ZSBtb2RlOiAnc3BlY2lmaWVkLWZvbGRlcicgfCAnc3ViZm9sZGVyJztcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGlucHV0RWw6IEhUTUxJbnB1dEVsZW1lbnQsIG1vZGU6ICdzcGVjaWZpZWQtZm9sZGVyJyB8ICdzdWJmb2xkZXInKSB7XHJcblx0XHRzdXBlcihhcHAsIGlucHV0RWwpO1xyXG5cdFx0dGhpcy5pbnB1dEVsID0gaW5wdXRFbDtcclxuXHRcdHRoaXMubW9kZSA9IG1vZGU7XHJcblx0fVxyXG5cclxuXHRnZXRTdWdnZXN0aW9ucyhpbnB1dFN0cjogc3RyaW5nKTogc3RyaW5nW10ge1xyXG5cdFx0Y29uc3Qgc3VnZ2VzdGlvbnM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBsb3dlcklucHV0ID0gaW5wdXRTdHIudG9Mb3dlckNhc2UoKTtcclxuXHRcdFxyXG5cdFx0aWYgKHRoaXMubW9kZSA9PT0gJ3N1YmZvbGRlcicpIHtcclxuXHRcdFx0Ly8gRm9yIHN1YmZvbGRlciBtb2RlLCBzdWdnZXN0IGZvbGRlciBuYW1lcyBvbmx5XHJcblx0XHRcdC8vIEFsd2F5cyBzdWdnZXN0IFwiYXR0YWNobWVudHNcIiBpZiBpdCBtYXRjaGVzXHJcblx0XHRcdGlmICgnYXR0YWNobWVudHMnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobG93ZXJJbnB1dCkpIHtcclxuXHRcdFx0XHRzdWdnZXN0aW9ucy5wdXNoKCdhdHRhY2htZW50cycpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBHZXQgZm9sZGVyIG5hbWVzIGZyb20gdmF1bHRcclxuXHRcdFx0Y29uc3QgYWxsRmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRBbGxMb2FkZWRGaWxlcygpO1xyXG5cdFx0XHRjb25zdCBmb2xkZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5cdFx0XHRcclxuXHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGFsbEZpbGVzKSB7XHJcblx0XHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XHJcblx0XHRcdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gZmlsZS5uYW1lO1xyXG5cdFx0XHRcdFx0aWYgKGZvbGRlck5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhsb3dlcklucHV0KSAmJiBmb2xkZXJOYW1lICE9PSAnYXR0YWNobWVudHMnKSB7XHJcblx0XHRcdFx0XHRcdGZvbGRlck5hbWVzLmFkZChmb2xkZXJOYW1lKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHN1Z2dlc3Rpb25zLnB1c2goLi4uQXJyYXkuZnJvbShmb2xkZXJOYW1lcykuc2xpY2UoMCwgMTApKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEZvciBzcGVjaWZpZWQtZm9sZGVyIG1vZGUsIHN1Z2dlc3QgZnVsbCBwYXRoc1xyXG5cdFx0XHRjb25zdCBhbGxGaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldEFsbExvYWRlZEZpbGVzKCk7XHJcblx0XHRcdGNvbnN0IHBhdGhzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgYWxsRmlsZXMpIHtcclxuXHRcdFx0XHRpZiAoZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSBmaWxlLnBhdGg7XHJcblx0XHRcdFx0XHRpZiAocGF0aC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGxvd2VySW5wdXQpKSB7XHJcblx0XHRcdFx0XHRcdHBhdGhzLmFkZChwYXRoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHN1Z2dlc3Rpb25zLnB1c2goLi4uQXJyYXkuZnJvbShwYXRocykuc2xpY2UoMCwgMTApKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHN1Z2dlc3Rpb25zO1xyXG5cdH1cclxuXHJcblx0cmVuZGVyU3VnZ2VzdGlvbihzdWdnZXN0aW9uOiBzdHJpbmcsIGVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xyXG5cdFx0ZWwuc2V0VGV4dChzdWdnZXN0aW9uKTtcclxuXHR9XHJcblxyXG5cdHNlbGVjdFN1Z2dlc3Rpb24oc3VnZ2VzdGlvbjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLmlucHV0RWwudmFsdWUgPSBzdWdnZXN0aW9uO1xyXG5cdFx0dGhpcy5pbnB1dEVsLnRyaWdnZXIoJ2lucHV0Jyk7XHJcblx0XHR0aGlzLmNsb3NlKCk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGVTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xyXG5cdHByaXZhdGUgY29udGVudFR5cGVEZXRlY3RvcjogQ29udGVudFR5cGVEZXRlY3RvcjtcclxuXHRwcml2YXRlIGFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3I6IEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3I7XHJcblx0cHJpdmF0ZSBkZXRlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzdGF0ZTogV2l6YXJkU3RhdGUsIG9uTmV4dDogKCkgPT4gdm9pZCwgb25CYWNrOiAoKSA9PiB2b2lkLCBvbkNhbmNlbDogKCkgPT4gdm9pZCkge1xyXG5cdFx0c3VwZXIoYXBwLCBjb250YWluZXJFbCwgc3RhdGUsIG9uTmV4dCwgb25CYWNrLCBvbkNhbmNlbCk7XHJcblx0XHR0aGlzLmNvbnRlbnRUeXBlRGV0ZWN0b3IgPSBuZXcgQ29udGVudFR5cGVEZXRlY3RvcihhcHApO1xyXG5cdFx0dGhpcy5hc3Ryb0NvbXBvc2VyQ29uZmlndXJhdG9yID0gbmV3IEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IoYXBwKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEltcG9ydCBjb250ZW50IHR5cGVzIGZyb20gQXN0cm8gQ29tcG9zZXIgZGF0YS5qc29uIGlmIGl0IGV4aXN0c1xyXG5cdCAqIEZpcnN0IHRyaWVzIHBsdWdpbiBBUEksIHRoZW4gZmFsbHMgYmFjayB0byBmaWxlIHJlYWRpbmdcclxuXHQgKi9cclxuXHRwcml2YXRlIGFzeW5jIGltcG9ydEZyb21Bc3Ryb0NvbXBvc2VyKCk6IFByb21pc2U8Q29udGVudFR5cGVDb25maWdbXT4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gRmlyc3QgdHJ5IHRvIHVzZSBwbHVnaW4gQVBJIChsaWtlIGhvdyB3ZSBzYXZlKVxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHsgc2V0dGluZ3M/OiB7IGNvbnRlbnRUeXBlcz86IHVua25vd25bXSB9IH0+IH0gfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBDaGVja2luZyBwbHVnaW5zIEFQSTonLCAhIXBsdWdpbnMpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHBsdWdpbnMpIHtcclxuXHRcdFx0XHRjb25zdCBhc3Ryb0NvbXBvc2VyUGx1Z2luID0gcGx1Z2lucy5wbHVnaW5zPy5bJ2FzdHJvLWNvbXBvc2VyJ107XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBBc3RybyBDb21wb3NlciBwbHVnaW4gZm91bmQ6JywgISFhc3Ryb0NvbXBvc2VyUGx1Z2luKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoYXN0cm9Db21wb3NlclBsdWdpbikge1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBQbHVnaW4gc2V0dGluZ3MgYXZhaWxhYmxlOicsICEhYXN0cm9Db21wb3NlclBsdWdpbi5zZXR0aW5ncyk7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IFBsdWdpbiBzZXR0aW5ncyBrZXlzOicsIGFzdHJvQ29tcG9zZXJQbHVnaW4uc2V0dGluZ3MgPyBPYmplY3Qua2V5cyhhc3Ryb0NvbXBvc2VyUGx1Z2luLnNldHRpbmdzKSA6ICdub25lJyk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdGlmIChhc3Ryb0NvbXBvc2VyUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGNvbnRlbnRUeXBlcyA9IGFzdHJvQ29tcG9zZXJQbHVnaW4uc2V0dGluZ3MuY29udGVudFR5cGVzO1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IGNvbnRlbnRUeXBlcyBmcm9tIHBsdWdpbjonLCBjb250ZW50VHlwZXMgPyBgQXJyYXkgd2l0aCAke2NvbnRlbnRUeXBlcy5sZW5ndGh9IGl0ZW1zYCA6ICdub3QgZm91bmQnKTtcclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlcykgJiYgY29udGVudFR5cGVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IEltcG9ydGluZycsIGNvbnRlbnRUeXBlcy5sZW5ndGgsICdjb250ZW50IHR5cGVzIGZyb20gQXN0cm8gQ29tcG9zZXIgKHZpYSBwbHVnaW4gQVBJKScpO1xyXG5cdFx0XHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0XHRcdC8vIENvbnZlcnQgQXN0cm8gQ29tcG9zZXIgY29udGVudCB0eXBlcyB0byBvdXIgZm9ybWF0XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW1wb3J0ZWRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IGNvbnRlbnRUeXBlcy5tYXAoKGN0OiB7IGlkPzogc3RyaW5nOyBuYW1lPzogc3RyaW5nOyBmb2xkZXI6IHN0cmluZzsgY3JlYXRpb25Nb2RlPzogc3RyaW5nOyBpbmRleEZpbGVOYW1lPzogc3RyaW5nOyBsaW5rQmFzZVBhdGg/OiBzdHJpbmc7IGVuYWJsZWQ/OiBib29sZWFuIH0pID0+ICh7XHJcblx0XHRcdFx0XHRcdFx0XHRpZDogY3QuaWQgfHwgYGNvbnRlbnQtdHlwZS0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDExKX1gLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogY3QubmFtZSB8fCB0aGlzLmNhcGl0YWxpemVGaXJzdChjdC5mb2xkZXIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9sZGVyOiBjdC5mb2xkZXIsXHJcblx0XHRcdFx0XHRcdFx0XHRmaWxlT3JnYW5pemF0aW9uOiBjdC5jcmVhdGlvbk1vZGUgPT09ICdmb2xkZXInID8gJ2ZvbGRlcicgOiAnZmlsZScsXHJcblx0XHRcdFx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBjdC5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCcsXHJcblx0XHRcdFx0XHRcdFx0XHRsaW5rQmFzZVBhdGg6IGN0LmxpbmtCYXNlUGF0aCxcclxuXHRcdFx0XHRcdFx0XHRcdGVuYWJsZWQ6IGN0LmVuYWJsZWQgIT09IGZhbHNlIC8vIERlZmF1bHQgdG8gZW5hYmxlZCBpZiBub3Qgc3BlY2lmaWVkXHJcblx0XHRcdFx0XHRcdFx0fSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaW1wb3J0ZWRUeXBlcztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSByZWFkaW5nXHJcblx0XHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0RpcjtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvYXN0cm8tY29tcG9zZXIvZGF0YS5qc29uYDtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBUcnlpbmcgdG8gcmVhZCBmaWxlOicsIHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IEZpbGUgZm91bmQ6JywgISFkYXRhRmlsZSwgZGF0YUZpbGUgPyBgVHlwZTogJHtkYXRhRmlsZS5jb25zdHJ1Y3Rvci5uYW1lfWAgOiAnbm90IGZvdW5kJyk7XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoIWRhdGFGaWxlIHx8ICEoZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcclxuXHRcdFx0XHQvLyBUcnkgYWx0ZXJuYXRpdmUgcGF0aHNcclxuXHRcdFx0XHRjb25zdCBhbHRQYXRocyA9IFtcclxuXHRcdFx0XHRcdGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy9hc3Ryby1jb21wb3Nlci9kYXRhLmpzb25gLFxyXG5cdFx0XHRcdFx0YG9ic2lkaWFuL3BsdWdpbnMvYXN0cm8tY29tcG9zZXIvZGF0YS5qc29uYFxyXG5cdFx0XHRcdF07XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Zm9yIChjb25zdCBhbHRQYXRoIG9mIGFsdFBhdGhzKSB7XHJcblx0XHRcdFx0XHRjb25zdCBhbHRGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGFsdFBhdGgpO1xyXG5cdFx0XHRcdFx0aWYgKGFsdEZpbGUgJiYgYWx0RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogRm91bmQgZmlsZSBhdCBhbHRlcm5hdGl2ZSBwYXRoOicsIGFsdFBhdGgpO1xyXG5cdFx0XHRcdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChhbHRGaWxlKTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZGF0YSA9IEpTT04ucGFyc2UoY29udGVudCkgYXMgeyBjb250ZW50VHlwZXM/OiB1bmtub3duW10gfTtcclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdGlmIChkYXRhLmNvbnRlbnRUeXBlcyAmJiBBcnJheS5pc0FycmF5KGRhdGEuY29udGVudFR5cGVzKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogSW1wb3J0aW5nJywgZGF0YS5jb250ZW50VHlwZXMubGVuZ3RoLCAnY29udGVudCB0eXBlcyBmcm9tIEFzdHJvIENvbXBvc2VyICh2aWEgZmlsZSBhdCcsIGFsdFBhdGgsICcpJyk7XHJcblx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW1wb3J0ZWRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IGRhdGEuY29udGVudFR5cGVzLm1hcCgoY3Q6IHsgaWQ/OiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IGZvbGRlcjogc3RyaW5nOyBjcmVhdGlvbk1vZGU/OiBzdHJpbmc7IGluZGV4RmlsZU5hbWU/OiBzdHJpbmc7IGxpbmtCYXNlUGF0aD86IHN0cmluZzsgZW5hYmxlZD86IGJvb2xlYW4gfSkgPT4gKHtcclxuXHRcdFx0XHRcdFx0XHRcdGlkOiBjdC5pZCB8fCBgY29udGVudC10eXBlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTEpfWAsXHJcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBjdC5uYW1lIHx8IHRoaXMuY2FwaXRhbGl6ZUZpcnN0KGN0LmZvbGRlciksXHJcblx0XHRcdFx0XHRcdFx0XHRmb2xkZXI6IGN0LmZvbGRlcixcclxuXHRcdFx0XHRcdFx0XHRcdGZpbGVPcmdhbml6YXRpb246IGN0LmNyZWF0aW9uTW9kZSA9PT0gJ2ZvbGRlcicgPyAnZm9sZGVyJyA6ICdmaWxlJyxcclxuXHRcdFx0XHRcdFx0XHRcdGluZGV4RmlsZU5hbWU6IGN0LmluZGV4RmlsZU5hbWUgfHwgJ2luZGV4JyxcclxuXHRcdFx0XHRcdFx0XHRcdGxpbmtCYXNlUGF0aDogY3QubGlua0Jhc2VQYXRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZW5hYmxlZDogY3QuZW5hYmxlZCAhPT0gZmFsc2VcclxuXHRcdFx0XHRcdFx0XHR9KSk7XHJcblx0XHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGltcG9ydGVkVHlwZXM7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQ29udGVudFR5cGVTdGVwOiBObyBBc3RybyBDb21wb3NlciBkYXRhLmpzb24gZm91bmQsIHdpbGwgc2NhbiBmb2xkZXJzJyk7XHJcblx0XHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSk7XHJcblx0XHRcdGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIHsgY29udGVudFR5cGVzPzogdW5rbm93bltdIH07XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoIWRhdGEuY29udGVudFR5cGVzIHx8ICFBcnJheS5pc0FycmF5KGRhdGEuY29udGVudFR5cGVzKSkge1xyXG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0NvbnRlbnRUeXBlU3RlcDogQXN0cm8gQ29tcG9zZXIgZGF0YS5qc29uIGhhcyBubyBjb250ZW50VHlwZXMgYXJyYXkuIERhdGEga2V5czonLCBPYmplY3Qua2V5cyhkYXRhKSk7XHJcblx0XHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdDb250ZW50VHlwZVN0ZXA6IEltcG9ydGluZycsIGRhdGEuY29udGVudFR5cGVzLmxlbmd0aCwgJ2NvbnRlbnQgdHlwZXMgZnJvbSBBc3RybyBDb21wb3NlciAodmlhIGZpbGUpJyk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDb252ZXJ0IEFzdHJvIENvbXBvc2VyIGNvbnRlbnQgdHlwZXMgdG8gb3VyIGZvcm1hdFxyXG5cdFx0XHRjb25zdCBpbXBvcnRlZFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdID0gZGF0YS5jb250ZW50VHlwZXMubWFwKChjdDogeyBpZD86IHN0cmluZzsgbmFtZT86IHN0cmluZzsgZm9sZGVyOiBzdHJpbmc7IGNyZWF0aW9uTW9kZT86IHN0cmluZzsgaW5kZXhGaWxlTmFtZT86IHN0cmluZzsgbGlua0Jhc2VQYXRoPzogc3RyaW5nOyBlbmFibGVkPzogYm9vbGVhbiB9KSA9PiAoe1xyXG5cdFx0XHRcdGlkOiBjdC5pZCB8fCBgY29udGVudC10eXBlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTEpfWAsXHJcblx0XHRcdFx0bmFtZTogY3QubmFtZSB8fCB0aGlzLmNhcGl0YWxpemVGaXJzdChjdC5mb2xkZXIpLFxyXG5cdFx0XHRcdGZvbGRlcjogY3QuZm9sZGVyLFxyXG5cdFx0XHRcdGZpbGVPcmdhbml6YXRpb246IGN0LmNyZWF0aW9uTW9kZSA9PT0gJ2ZvbGRlcicgPyAnZm9sZGVyJyA6ICdmaWxlJyxcclxuXHRcdFx0XHRpbmRleEZpbGVOYW1lOiBjdC5pbmRleEZpbGVOYW1lIHx8ICdpbmRleCcsXHJcblx0XHRcdFx0bGlua0Jhc2VQYXRoOiBjdC5saW5rQmFzZVBhdGgsXHJcblx0XHRcdFx0ZW5hYmxlZDogY3QuZW5hYmxlZCAhPT0gZmFsc2UgLy8gRGVmYXVsdCB0byBlbmFibGVkIGlmIG5vdCBzcGVjaWZpZWRcclxuXHRcdFx0fSkpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGltcG9ydGVkVHlwZXM7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb250ZW50VHlwZVN0ZXA6IEZhaWxlZCB0byBpbXBvcnQgZnJvbSBBc3RybyBDb21wb3NlcjonLCBlcnJvcik7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGFzeW5jIGRpc3BsYXkoKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cdFx0XHJcblx0XHQvLyBGaW5kIG9yIGNyZWF0ZSBjb250ZW50IHdyYXBwZXIgKHByZXNlcnZlIGZvb3RlciBpZiBpdCBleGlzdHMpXHJcblx0XHRsZXQgc3RlcENvbnRlbnRXcmFwcGVyID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcignLmNvbnRlbnQtdHlwZS1zdGVwLWNvbnRlbnQnKSBhcyBIVE1MRWxlbWVudDtcclxuXHRcdFxyXG5cdFx0aWYgKCFzdGVwQ29udGVudFdyYXBwZXIpIHtcclxuXHRcdFx0Ly8gRmlyc3QgdGltZSAtIGNsZWFyIGV2ZXJ5dGhpbmcgYW5kIGNyZWF0ZSB3cmFwcGVyXHJcblx0XHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblx0XHRcdHN0ZXBDb250ZW50V3JhcHBlciA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ2NvbnRlbnQtdHlwZS1zdGVwLWNvbnRlbnQnIH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gUmUtcmVuZGVyaW5nIC0ganVzdCBjbGVhciB0aGUgd3JhcHBlciBjb250ZW50LCBwcmVzZXJ2ZSBmb290ZXJcclxuXHRcdFx0c3RlcENvbnRlbnRXcmFwcGVyLmVtcHR5KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0NvbnRlbnQgdHlwZXMnIH0pO1xyXG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0dGV4dDogJ0RldGVjdGluZyBjb250ZW50IHR5cGVzIGluIHlvdXIgdmF1bHQuLi4nIFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLmRldGVjdGVkKSB7XHJcblx0XHRcdC8vIEdldCBzYXZlZCBjb250ZW50IHR5cGVzIGZyb20gc3RhdGUgKHByZXNlcnZlcyBlbmFibGVkIHN0YXRlIGZyb20gcHJldmlvdXMgd2l6YXJkIHJ1bnMpXHJcblx0XHRcdGNvbnN0IHNhdmVkQ29udGVudFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMgfHwgW107XHJcblx0XHRcdGNvbnN0IHNhdmVkQ29udGVudFR5cGVzTWFwID0gbmV3IE1hcChzYXZlZENvbnRlbnRUeXBlcy5tYXAoY3QgPT4gW2N0LmZvbGRlciwgY3RdKSk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGaXJzdCwgdHJ5IHRvIGltcG9ydCBmcm9tIEFzdHJvIENvbXBvc2VyIGlmIGl0IGV4aXN0c1xyXG5cdFx0XHRjb25zdCBpbXBvcnRlZFR5cGVzID0gYXdhaXQgdGhpcy5pbXBvcnRGcm9tQXN0cm9Db21wb3NlcigpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVGhlbiBzY2FuIGZvciBuZXcgZm9sZGVycyB0aGF0IGFyZW4ndCBhbHJlYWR5IG1hcHBlZFxyXG5cdFx0XHQvLyBQYXNzIHByb2plY3QgZGV0ZWN0aW9uIGluZm8gc28gaXQgY2FuIGZpbmQgc3JjL2NvbnRlbnQgZGlyZWN0b3J5IGNvcnJlY3RseVxyXG5cdFx0XHRjb25zdCBzY2FubmVkVHlwZXMgPSB0aGlzLmNvbnRlbnRUeXBlRGV0ZWN0b3IuZGV0ZWN0Q29udGVudFR5cGVzKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbik7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDb21iaW5lIGltcG9ydGVkIGFuZCBzY2FubmVkIHR5cGVzXHJcblx0XHRcdC8vIFJlY29uY2lsZTogaWYgd2UgaGF2ZSBib3RoIGEgc2hvcnQgcGF0aCBhbmQgYSBsb25nIHBhdGggdGhhdCBlbmRzIHdpdGggaXQsIHByZWZlciB0aGUgbG9uZyBwYXRoXHJcblx0XHRcdGNvbnN0IGFsbERldGVjdGVkVHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10gPSBbXTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIDEuIFN0YXJ0IHdpdGggYWxsIGltcG9ydGVkIHR5cGVzXHJcblx0XHRcdGNvbnN0IGltcG9ydGVkID0gWy4uLmltcG9ydGVkVHlwZXNdO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gMi4gQ2hlY2sgZWFjaCBzY2FubmVkIHR5cGVcclxuXHRcdFx0Zm9yIChjb25zdCBzY2FubmVkIG9mIHNjYW5uZWRUeXBlcykge1xyXG5cdFx0XHRcdGNvbnN0IG1hdGNoaW5nSW1wb3J0ZWRJbmRleCA9IGltcG9ydGVkLmZpbmRJbmRleChpdCA9PiBcclxuXHRcdFx0XHRcdHNjYW5uZWQuZm9sZGVyID09PSBpdC5mb2xkZXIgfHwgXHJcblx0XHRcdFx0XHRzY2FubmVkLmZvbGRlci5lbmRzV2l0aChgLyR7aXQuZm9sZGVyfWApIHx8XHJcblx0XHRcdFx0XHRpdC5mb2xkZXIuZW5kc1dpdGgoYC8ke3NjYW5uZWQuZm9sZGVyfWApXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAobWF0Y2hpbmdJbXBvcnRlZEluZGV4ID49IDApIHtcclxuXHRcdFx0XHRcdC8vIFJlY29uY2lsZTogdXBkYXRlIHRoZSBpbXBvcnRlZCBvbmUgd2l0aCB0aGUgbG9uZ2VyIGZvbGRlciBwYXRoIGlmIGl0J3MgYSBtYXRjaFxyXG5cdFx0XHRcdFx0Y29uc3QgaW1wb3J0ZWRUeXBlID0gaW1wb3J0ZWRbbWF0Y2hpbmdJbXBvcnRlZEluZGV4XTtcclxuXHRcdFx0XHRcdGlmIChzY2FubmVkLmZvbGRlci5sZW5ndGggPiBpbXBvcnRlZFR5cGUuZm9sZGVyLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBDb250ZW50VHlwZVN0ZXA6IFVwZGF0aW5nIGltcG9ydGVkIHR5cGUgXCIke2ltcG9ydGVkVHlwZS5uYW1lfVwiIGZvbGRlciBmcm9tIFwiJHtpbXBvcnRlZFR5cGUuZm9sZGVyfVwiIHRvIFwiJHtzY2FubmVkLmZvbGRlcn1cImApO1xyXG5cdFx0XHRcdFx0XHRpbXBvcnRlZFttYXRjaGluZ0ltcG9ydGVkSW5kZXhdID0ge1xyXG5cdFx0XHRcdFx0XHRcdC4uLmltcG9ydGVkVHlwZSxcclxuXHRcdFx0XHRcdFx0XHRmb2xkZXI6IHNjYW5uZWQuZm9sZGVyXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIE5vdCBmb3VuZCBpbiBpbXBvcnRlZCwgYWRkIGFzIG5ldyBkZXRlY3RlZCB0eXBlXHJcblx0XHRcdFx0XHRhbGxEZXRlY3RlZFR5cGVzLnB1c2goc2Nhbm5lZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDb21iaW5lIHJlY29uY2lsZWQgaW1wb3J0ZWQgdHlwZXMgd2l0aCBuZXcgZGV0ZWN0ZWQgdHlwZXNcclxuXHRcdFx0YWxsRGV0ZWN0ZWRUeXBlcy5wdXNoKC4uLmltcG9ydGVkKTtcclxuXHRcdFx0XHJcblx0XHRcdGNvbnN0IGRldGVjdGVkVHlwZXNNYXAgPSBuZXcgTWFwKGFsbERldGVjdGVkVHlwZXMubWFwKGN0ID0+IFtjdC5mb2xkZXIsIGN0XSkpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTWVyZ2Ugd2l0aCBzYXZlZCBjb250ZW50IHR5cGVzLCBwcmVzZXJ2aW5nIGVuYWJsZWQgc3RhdGUgZnJvbSBzYXZlZCBzZXR0aW5nc1xyXG5cdFx0XHRjb25zdCBtZXJnZWRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSA9IFtdO1xyXG5cdFx0XHRjb25zdCBwcm9jZXNzZWRGb2xkZXJzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBQcm9jZXNzIGFsbCBmb2xkZXJzIChib3RoIHNhdmVkIGFuZCBkZXRlY3RlZClcclxuXHRcdFx0Y29uc3QgYWxsRm9sZGVycyA9IG5ldyBTZXQoW1xyXG5cdFx0XHRcdC4uLnNhdmVkQ29udGVudFR5cGVzLm1hcChjdCA9PiBjdC5mb2xkZXIpLFxyXG5cdFx0XHRcdC4uLmFsbERldGVjdGVkVHlwZXMubWFwKGN0ID0+IGN0LmZvbGRlcilcclxuXHRcdFx0XSk7XHJcblx0XHRcdFxyXG5cdFx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBhbGxGb2xkZXJzKSB7XHJcblx0XHRcdFx0aWYgKHByb2Nlc3NlZEZvbGRlcnMuaGFzKGZvbGRlcikpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGxldCBzYXZlZFR5cGUgPSBzYXZlZENvbnRlbnRUeXBlc01hcC5nZXQoZm9sZGVyKTtcclxuXHRcdFx0XHRjb25zdCBkZXRlY3RlZFR5cGUgPSBkZXRlY3RlZFR5cGVzTWFwLmdldChmb2xkZXIpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFJFQ09OQ0lMSUFUSU9OOiBJZiB3ZSBoYXZlIGEgc2F2ZWQgdHlwZSB0aGF0IHdhc24ndCBkZXRlY3RlZCwgY2hlY2sgaWYgaXQncyBiZWNhdXNlXHJcblx0XHRcdFx0Ly8gaXQgd2FzIHNhdmVkIHdpdGggYSBzaG9ydCBwYXRoIChlLmcuIFwicG9zdHNcIikgYnV0IG5vdyBkZXRlY3RlZCB3aXRoIGEgZnVsbCBwYXRoIChlLmcuIFwic3JjL2NvbnRlbnQvcG9zdHNcIilcclxuXHRcdFx0XHRpZiAoc2F2ZWRUeXBlICYmICFkZXRlY3RlZFR5cGUpIHtcclxuXHRcdFx0XHRcdC8vIFRyeSB0byBmaW5kIGlmIHRoaXMgc2F2ZWQgdHlwZSdzIGZvbGRlciBuYW1lIG1hdGNoZXMgdGhlIGVuZCBvZiBhbnkgZGV0ZWN0ZWQgZm9sZGVyXHJcblx0XHRcdFx0XHRjb25zdCBtYXRjaGluZ0RldGVjdGVkID0gYWxsRGV0ZWN0ZWRUeXBlcy5maW5kKGR0ID0+IFxyXG5cdFx0XHRcdFx0XHRkdC5mb2xkZXIuZW5kc1dpdGgoYC8ke2ZvbGRlcn1gKSB8fCBkdC5mb2xkZXIgPT09IGZvbGRlclxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0aWYgKG1hdGNoaW5nRGV0ZWN0ZWQgJiYgIXByb2Nlc3NlZEZvbGRlcnMuaGFzKG1hdGNoaW5nRGV0ZWN0ZWQuZm9sZGVyKSkge1xyXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBDb250ZW50VHlwZVN0ZXA6IFJlY29uY2lsaW5nIHNhdmVkIGZvbGRlciBcIiR7Zm9sZGVyfVwiIHdpdGggZGV0ZWN0ZWQgZm9sZGVyIFwiJHttYXRjaGluZ0RldGVjdGVkLmZvbGRlcn1cImApO1xyXG5cdFx0XHRcdFx0XHQvLyBNaWdyYXRlIHNhdmVkIHNldHRpbmdzIHRvIHRoZSBjb3JyZWN0IGRldGVjdGVkIGZvbGRlciBwYXRoXHJcblx0XHRcdFx0XHRcdG1lcmdlZFR5cGVzLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRcdC4uLnNhdmVkVHlwZSxcclxuXHRcdFx0XHRcdFx0XHRmb2xkZXI6IG1hdGNoaW5nRGV0ZWN0ZWQuZm9sZGVyXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRwcm9jZXNzZWRGb2xkZXJzLmFkZChmb2xkZXIpO1xyXG5cdFx0XHRcdFx0XHRwcm9jZXNzZWRGb2xkZXJzLmFkZChtYXRjaGluZ0RldGVjdGVkLmZvbGRlcik7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRpZiAoc2F2ZWRUeXBlKSB7XHJcblx0XHRcdFx0XHQvLyBVc2Ugc2F2ZWQgdHlwZSB0byBwcmVzZXJ2ZSBlbmFibGVkIHN0YXRlLCBjdXN0b20gbmFtZSwgYW5kIGFsbCBvdGhlciBzZXR0aW5nc1xyXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhbHNvIGEgZGV0ZWN0ZWQgdHlwZSwgbWVyZ2UgaW4gYW55IG5ldyBpbmZvIHdoaWxlIHByZXNlcnZpbmcgc2F2ZWQgc2V0dGluZ3NcclxuXHRcdFx0XHRcdGlmIChkZXRlY3RlZFR5cGUpIHtcclxuXHRcdFx0XHRcdFx0bWVyZ2VkVHlwZXMucHVzaCh7XHJcblx0XHRcdFx0XHRcdFx0Li4uc2F2ZWRUeXBlLCAvLyBQcmVzZXJ2ZSBhbGwgc2F2ZWQgc2V0dGluZ3MgKGVuYWJsZWQsIGN1c3RvbSBuYW1lLCBsaW5rQmFzZVBhdGgsIGV0Yy4pXHJcblx0XHRcdFx0XHRcdFx0Ly8gQWx3YXlzIHByZXNlcnZlIHNhdmVkIGZvbGRlciBhbmQgbmFtZSAodXNlciBtYXkgaGF2ZSBjdXN0b21pemVkIHRoZSBuYW1lKVxyXG5cdFx0XHRcdFx0XHRcdGZvbGRlcjogc2F2ZWRUeXBlLmZvbGRlcixcclxuXHRcdFx0XHRcdFx0XHRuYW1lOiBzYXZlZFR5cGUubmFtZSAvLyBBbHdheXMgdXNlIHNhdmVkIG5hbWUgKG1heSBiZSBjdXN0b21pemVkKVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIFNhdmVkIHR5cGUgbm90IGRldGVjdGVkIC0ga2VlcCBpdCBhcyBpcyAodXNlciBtaWdodCBoYXZlIGRlbGV0ZWQgdGhlIGZvbGRlcilcclxuXHRcdFx0XHRcdFx0bWVyZ2VkVHlwZXMucHVzaChzYXZlZFR5cGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoZGV0ZWN0ZWRUeXBlKSB7XHJcblx0XHRcdFx0XHQvLyBOZXcgdHlwZSBub3QgaW4gc2F2ZWQgc2V0dGluZ3MgLSBhZGQgaXQgKGRlZmF1bHQgdG8gZW5hYmxlZCBmb3IgbmV3IHR5cGVzKVxyXG5cdFx0XHRcdFx0Ly8gVXNlIGF1dG8tZGV0ZWN0ZWQgbmFtZSBhcyBzdGFydGluZyBwb2ludCAodXNlciBjYW4gY3VzdG9taXplIGl0KVxyXG5cdFx0XHRcdFx0bWVyZ2VkVHlwZXMucHVzaChkZXRlY3RlZFR5cGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRwcm9jZXNzZWRGb2xkZXJzLmFkZChmb2xkZXIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBTb3J0IGFscGhhYmV0aWNhbGx5IGJ5IG5hbWVcclxuXHRcdFx0bWVyZ2VkVHlwZXMuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcyA9IG1lcmdlZFR5cGVzO1xyXG5cdFx0XHR0aGlzLmRldGVjdGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRzdGVwQ29udGVudFdyYXBwZXIuZW1wdHkoKTtcclxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdDb250ZW50IHR5cGVzJyB9KTtcclxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdHRleHQ6ICdTZWxlY3QgYW5kIGNvbmZpZ3VyZSB5b3VyIGNvbnRlbnQgdHlwZXM6JyBcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEdsb2JhbCBhdHRhY2htZW50IGhhbmRsaW5nIGF0IHRoZSB0b3BcclxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdBdHRhY2htZW50IGhhbmRsaW5nJywgY2xzOiAndmF1bHQtY21zLXNlY3Rpb24taGVhZGVyJyB9KTtcclxuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdHRleHQ6ICdIb3cgc2hvdWxkIGF0dGFjaG1lbnRzIGJlIHN0b3JlZCBnbG9iYWxseT8nLFxyXG5cdFx0XHRjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1kZXNjJ1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bmV3IFNldHRpbmcoc3RlcENvbnRlbnRXcmFwcGVyKVxyXG5cdFx0XHQuc2V0TmFtZSgnSG93IGFyZSBhdHRhY2htZW50cyBoYW5kbGVkPycpXHJcblx0XHRcdC5zZXREZXNjKCdDaG9vc2UgaG93IGF0dGFjaG1lbnRzIGFyZSBzdG9yZWQgZm9yIGFsbCBjb250ZW50IHR5cGVzJylcclxuXHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXHJcblx0XHRcdFx0LmFkZE9wdGlvbignc2FtZS1mb2xkZXInLCAnU2FtZSBmb2xkZXIgYXMgY3VycmVudCBmaWxlJylcclxuXHRcdFx0XHQuYWRkT3B0aW9uKCdzcGVjaWZpZWQtZm9sZGVyJywgJ0luIHRoZSBzcGVjaWZpZWQgZm9sZGVyJylcclxuXHRcdFx0XHQuYWRkT3B0aW9uKCdzdWJmb2xkZXInLCAnSW4gc3ViZm9sZGVyIHVuZGVyIGN1cnJlbnQgZm9sZGVyJylcclxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlIHx8ICdzdWJmb2xkZXInKVxyXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPSB2YWx1ZSBhcyAnc3BlY2lmaWVkLWZvbGRlcicgfCAnc2FtZS1mb2xkZXInIHwgJ3N1YmZvbGRlcic7XHJcblx0XHRcdFx0XHQvLyBDbGVhciBmb2xkZXIgbmFtZSBpZiBzd2l0Y2hpbmcgdG8gc2FtZS1mb2xkZXJcclxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gJ3NhbWUtZm9sZGVyJykge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gUmUtcmVuZGVyIHRvIHNob3cvaGlkZSBmb2xkZXIgbmFtZSBpbnB1dFxyXG5cdFx0XHRcdFx0dm9pZCB0aGlzLmRpc3BsYXkoKTtcclxuXHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0Ly8gU2hvdyBmb2xkZXIgbmFtZSBpbnB1dCBmb3Igc3BlY2lmaWVkLWZvbGRlciBvciBzdWJmb2xkZXIgbW9kZXNcclxuXHRcdGlmICh0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzcGVjaWZpZWQtZm9sZGVyJyB8fCB0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzdWJmb2xkZXInKSB7XHJcblx0XHRcdGNvbnN0IGRlc2NUZXh0ID0gdGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc3BlY2lmaWVkLWZvbGRlcicgXHJcblx0XHRcdFx0PyAnRW50ZXIgdGhlIGV4YWN0IHBhdGggdG8gdGhlIGZvbGRlciBmb3IgYXR0YWNobWVudHMgKGUuZy4sIFwiYXR0YWNobWVudHNcIiBvciBcImltYWdlcy9hdHRhY2htZW50c1wiKS4gTGVhdmUgYmxhbmsgdG8gdXNlIFwiYXR0YWNobWVudHNcIiBhcyBkZWZhdWx0LidcclxuXHRcdFx0XHQ6ICdFbnRlciB0aGUgbmFtZSBvZiB0aGUgc3ViZm9sZGVyIGZvciBhdHRhY2htZW50cyAoZS5nLiwgXCJhdHRhY2htZW50c1wiKS4gTGVhdmUgYmxhbmsgdG8gdXNlIFwiYXR0YWNobWVudHNcIiBhcyBkZWZhdWx0Lic7XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zdCBmb2xkZXJOYW1lU2V0dGluZyA9IG5ldyBTZXR0aW5nKHN0ZXBDb250ZW50V3JhcHBlcilcclxuXHRcdFx0XHQuc2V0TmFtZSgnQXR0YWNobWVudCBmb2xkZXInKVxyXG5cdFx0XHRcdC5zZXREZXNjKGRlc2NUZXh0KTtcclxuXHJcblx0XHRcdGZvbGRlck5hbWVTZXR0aW5nLmFkZFRleHQodGV4dCA9PiB7XHJcblx0XHRcdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiYXR0YWNobWVudHNcIiBpcyBhIHBsYWNlaG9sZGVyIHZhbHVlLCBub3QgVUkgdGV4dFxyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2VcclxuXHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKCdhdHRhY2htZW50cycpXHJcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSB8fCAnJylcclxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgPSB2YWx1ZSB8fCB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBBZGQgYXV0b2NvbXBsZXRlIHN1Z2dlc3RlciB3aXRoIG1vZGUgKG9ubHkgaWYgbm90IHNhbWUtZm9sZGVyKVxyXG5cdFx0XHRcdGlmICh0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgIT09ICdzYW1lLWZvbGRlcicpIHtcclxuXHRcdFx0XHRcdG5ldyBGb2xkZXJOYW1lU3VnZ2VzdCh0aGlzLmFwcCwgdGV4dC5pbnB1dEVsLCB0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdocicsIHsgY2xzOiAndmF1bHQtY21zLWRpdmlkZXInIH0pO1xyXG5cclxuXHRcdC8vIENvbnRlbnQgdHlwZXMgc2VjdGlvblxyXG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0NvbnRlbnQgdHlwZXMnLCBjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1oZWFkZXInIH0pO1xyXG5cclxuXHRcdGZvciAoY29uc3QgY29udGVudFR5cGUgb2YgdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMpIHtcclxuXHRcdFx0Y29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKHN0ZXBDb250ZW50V3JhcHBlcik7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDcmVhdGUgY2xpY2stdG8tZWRpdCBuYW1lIGVsZW1lbnQgd2l0aCBpY29uXHJcblx0XHRcdGNvbnN0IG5hbWVDb250YWluZXIgPSBzZXR0aW5nLm5hbWVFbC5jcmVhdGVEaXYoeyBjbHM6ICd2YXVsdC1jbXMtZWRpdGFibGUtbmFtZScgfSk7XHJcblx0XHRcdHNldENzc1Byb3BzKG5hbWVDb250YWluZXIsIHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgZ2FwOiAnMC41cmVtJyB9KTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZGlzcGxheSBlbGVtZW50IHdpdGggY2xpY2sgaGFuZGxlclxyXG5cdFx0XHRjb25zdCBjcmVhdGVOYW1lRGlzcGxheSA9IChuYW1lOiBzdHJpbmcpID0+IHtcclxuXHRcdFx0XHQvLyBDbGVhciBjb250YWluZXIgZmlyc3RcclxuXHRcdFx0XHRuYW1lQ29udGFpbmVyLmVtcHR5KCk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Y29uc3QgZGlzcGxheSA9IG5hbWVDb250YWluZXIuY3JlYXRlU3Bhbih7IFxyXG5cdFx0XHRcdFx0dGV4dDogbmFtZSxcclxuXHRcdFx0XHRcdGNsczogJ3ZhdWx0LWNtcy1uYW1lLWRpc3BsYXknXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQWRkIHBlbmNpbCBpY29uXHJcblx0XHRcdFx0Y29uc3QgaWNvbkNvbnRhaW5lciA9IG5hbWVDb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAndmF1bHQtY21zLWVkaXQtaWNvbicgfSk7XHJcblx0XHRcdFx0c2V0Q3NzUHJvcHMoaWNvbkNvbnRhaW5lciwgeyBvcGFjaXR5OiAnMC42JyB9KTtcclxuXHRcdFx0XHRzZXRJY29uKGljb25Db250YWluZXIsICdsdWNpZGUtcGVuY2lsLWxpbmUnKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBNYWtlIG5hbWUgYW5kIGljb24gZWRpdGFibGUgb24gY2xpY2tcclxuXHRcdFx0XHRjb25zdCBzdGFydEVkaXQgPSAoKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50TmFtZSA9IGNvbnRlbnRUeXBlLm5hbWU7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vIENsZWFyIGNvbnRhaW5lclxyXG5cdFx0XHRcdFx0bmFtZUNvbnRhaW5lci5lbXB0eSgpO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvLyBDcmVhdGUgaW5wdXQgdXNpbmcgbmF0aXZlIE9ic2lkaWFuIHN0eWxpbmdcclxuXHRcdFx0XHRcdGNvbnN0IG5hbWVJbnB1dCA9IG5hbWVDb250YWluZXIuY3JlYXRlRWwoJ2lucHV0Jywge1xyXG5cdFx0XHRcdFx0XHR0eXBlOiAndGV4dCcsXHJcblx0XHRcdFx0XHRcdHZhbHVlOiBjdXJyZW50TmFtZVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHQvLyBVc2UgbmF0aXZlIE9ic2lkaWFuIGlucHV0IHN0eWxpbmcgY2xhc3MgKHNhbWUgYXMgU2V0dGluZy5hZGRUZXh0IHVzZXMpXHJcblx0XHRcdFx0XHRuYW1lSW5wdXQuYWRkQ2xhc3MoJ21vZC10ZXh0LWlucHV0Jyk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vIEZvY3VzIGFuZCBzZWxlY3QgdGV4dFxyXG5cdFx0XHRcdFx0bmFtZUlucHV0LmZvY3VzKCk7XHJcblx0XHRcdFx0XHRuYW1lSW5wdXQuc2VsZWN0KCk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdC8vIFNhdmUgb24gYmx1clxyXG5cdFx0XHRcdFx0Y29uc3Qgc2F2ZU5hbWUgPSAoKSA9PiB7XHJcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBibHVyIGxpc3RlbmVyIHRvIHByZXZlbnQgZG91YmxlIGV4ZWN1dGlvblxyXG5cdFx0XHRcdFx0XHRuYW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHNhdmVOYW1lKTtcclxuXHRcdFx0XHRcdFx0XHJcblx0XHRcdFx0XHRcdGxldCBuZXdOYW1lID0gbmFtZUlucHV0LnZhbHVlLnRyaW0oKTtcclxuXHRcdFx0XHRcdFx0Ly8gVmFsaWRhdGU6IGVuc3VyZSBuYW1lIGlzIG5vdCBlbXB0eVxyXG5cdFx0XHRcdFx0XHRpZiAoIW5ld05hbWUpIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdOYW1lID0gY3VycmVudE5hbWU7IC8vIFJldmVydCB0byBvcmlnaW5hbCBpZiBlbXB0eVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIFZhbGlkYXRlOiByZW1vdmUgYW55IHByb2JsZW1hdGljIGNoYXJhY3RlcnMgdGhhdCBtaWdodCBicmVhayBBc3RybyBDb21wb3NlclxyXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgY2hhcmFjdGVycyB0aGF0IGNvdWxkIGNhdXNlIGlzc3VlcyBpbiBjb25maWcgZmlsZXMgb3IgVUlcclxuXHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcclxuXHRcdFx0XHRcdFx0bmV3TmFtZSA9IG5ld05hbWUucmVwbGFjZSgvWzw+OlwiL1xcXFx8PypcXHgwMC1cXHgxRl0vZywgJycpO1xyXG5cdFx0XHRcdFx0XHQvLyBFbnN1cmUgaXQncyBzdGlsbCBub3QgZW1wdHkgYWZ0ZXIgY2xlYW5pbmdcclxuXHRcdFx0XHRcdFx0aWYgKCFuZXdOYW1lLnRyaW0oKSkge1xyXG5cdFx0XHRcdFx0XHRcdG5ld05hbWUgPSBjdXJyZW50TmFtZTsgLy8gUmV2ZXJ0IHRvIG9yaWdpbmFsIGlmIGVtcHR5IGFmdGVyIGNsZWFuaW5nXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0bmV3TmFtZSA9IG5ld05hbWUudHJpbSgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlLm5hbWUgPSBuZXdOYW1lO1xyXG5cdFx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdFx0Ly8gUmUtcmVuZGVyIHRvIHVwZGF0ZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgbmFtZVxyXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjYWxsIGNyZWF0ZU5hbWVEaXNwbGF5IGhlcmUgYXMgZGlzcGxheSgpIHdpbGwgcmVjcmVhdGUgZXZlcnl0aGluZ1xyXG5cdFx0XHRcdFx0XHR2b2lkIHRoaXMuZGlzcGxheSgpO1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0Ly8gU2F2ZSBvbiBFbnRlclxyXG5cdFx0XHRcdFx0bmFtZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcclxuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdFx0c2F2ZU5hbWUoKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHtcclxuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gQ2FuY2VsOiByZXZlcnQgdG8gb3JpZ2luYWxcclxuXHRcdFx0XHRcdFx0XHRjcmVhdGVOYW1lRGlzcGxheShjdXJyZW50TmFtZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvLyBTYXZlIG9uIGJsdXJcclxuXHRcdFx0XHRcdG5hbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgc2F2ZU5hbWUpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQWRkIGNsaWNrIGhhbmRsZXJzIHRvIGJvdGggbmFtZSBhbmQgaWNvblxyXG5cdFx0XHRcdGRpc3BsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdGFydEVkaXQpO1xyXG5cdFx0XHRcdGljb25Db250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdGFydEVkaXQpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEFkZCBob3ZlciBlZmZlY3QgdG8gaWNvblxyXG5cdFx0XHRcdGljb25Db250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsICgpID0+IHtcclxuXHRcdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgb3BhY2l0eTogJzEnIH0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGljb25Db250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsICgpID0+IHtcclxuXHRcdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgb3BhY2l0eTogJzAuNicgfSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0cmV0dXJuIGRpc3BsYXk7XHJcblx0XHRcdH07XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDcmVhdGUgaW5pdGlhbCBkaXNwbGF5XHJcblx0XHRcdGNyZWF0ZU5hbWVEaXNwbGF5KGNvbnRlbnRUeXBlLm5hbWUpO1xyXG5cdFx0XHRcclxuXHRcdFx0c2V0dGluZy5zZXREZXNjKGBGb2xkZXI6ICR7Y29udGVudFR5cGUuZm9sZGVyfWApXHJcblx0XHRcdFx0LmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXHJcblx0XHRcdFx0XHQuc2V0VmFsdWUoY29udGVudFR5cGUuZW5hYmxlZClcclxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlLmVuYWJsZWQgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdH0pKTtcclxuXHJcblx0XHRcdC8vIEZpbGUgb3JnYW5pemF0aW9uIGRyb3Bkb3duXHJcblx0XHRcdG5ldyBTZXR0aW5nKHN0ZXBDb250ZW50V3JhcHBlcilcclxuXHRcdFx0XHQuc2V0TmFtZShgJHtjb250ZW50VHlwZS5uYW1lfSAtIEZpbGUgb3JnYW5pemF0aW9uYClcclxuXHRcdFx0XHQuc2V0RGVzYygnQ2hvb3NlIGhvdyBjb250ZW50IGlzIG9yZ2FuaXplZCBmb3IgdGhpcyBjb250ZW50IHR5cGUnKVxyXG5cdFx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxyXG5cdFx0XHRcdFx0LmFkZE9wdGlvbignZmlsZScsICdGaWxlLWJhc2VkJylcclxuXHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZvbGRlcicsICdGb2xkZXItYmFzZWQnKVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKGNvbnRlbnRUeXBlLmZpbGVPcmdhbml6YXRpb24gfHwgJ2ZpbGUnKVxyXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuXHRcdFx0XHRcdFx0Y29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbiA9IHZhbHVlIGFzICdmaWxlJyB8ICdmb2xkZXInO1xyXG5cdFx0XHRcdFx0XHQvLyBSZS1yZW5kZXIgdG8gc2hvdy9oaWRlIGluZGV4IGZpbGUgbmFtZSBzZXR0aW5nXHJcblx0XHRcdFx0XHRcdHZvaWQgdGhpcy5kaXNwbGF5KCk7XHJcblx0XHRcdFx0XHR9KSk7XHJcblxyXG5cdFx0XHQvLyBTaG93IGluZGV4IGZpbGUgbmFtZSBmb3IgZm9sZGVyLWJhc2VkIG9yZ2FuaXphdGlvblxyXG5cdFx0XHRpZiAoY29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbiA9PT0gJ2ZvbGRlcicpIHtcclxuXHRcdFx0XHRuZXcgU2V0dGluZyhzdGVwQ29udGVudFdyYXBwZXIpXHJcblx0XHRcdFx0XHQuc2V0TmFtZShgJHtjb250ZW50VHlwZS5uYW1lfSAtIEluZGV4IGZpbGUgbmFtZWApXHJcblx0XHRcdFx0XHQuc2V0RGVzYygnTmFtZSBvZiB0aGUgaW5kZXggZmlsZSBpbiBmb2xkZXItYmFzZWQgb3JnYW5pemF0aW9uJylcclxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxyXG5cdFx0XHRcdFx0XHQuc2V0VmFsdWUoY29udGVudFR5cGUuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnKVxyXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlLmluZGV4RmlsZU5hbWUgPSB2YWx1ZSB8fCAnaW5kZXgnO1xyXG5cdFx0XHRcdFx0XHR9KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExpbmsgYmFzZSBwYXRoIGZvciBBc3RybyBDb21wb3NlclxyXG5cdFx0XHQvLyBFeHRyYWN0IGZvbGRlciBuYW1lIGZyb20gcGF0aCAoZS5nLiwgXCJzcmMvY29udGVudC9wb3N0c1wiIC0+IFwicG9zdHNcIilcclxuXHRcdFx0Y29uc3QgcGF0aFBhcnRzID0gY29udGVudFR5cGUuZm9sZGVyLnNwbGl0KCcvJykuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcclxuXHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV0gfHwgY29udGVudFR5cGUuZm9sZGVyO1xyXG5cdFx0XHRjb25zdCBkZWZhdWx0TGlua0Jhc2VQYXRoID0gYC8ke2ZvbGRlck5hbWV9L2A7XHJcblx0XHRcdG5ldyBTZXR0aW5nKHN0ZXBDb250ZW50V3JhcHBlcilcclxuXHRcdFx0XHQuc2V0TmFtZShgJHtjb250ZW50VHlwZS5uYW1lfSAtIExpbmsgYmFzZSBwYXRoYClcclxuXHRcdFx0XHQuc2V0RGVzYyhgVVJMIHBhdGggZm9yIHRoaXMgY29udGVudCB0eXBlIChlLmcuLCBcIi9wb3N0cy9cIiBvciBcIi9cIiBmb3Igcm9vdCkuIExlYXZlIGJsYW5rIHRvIHVzZSBkZWZhdWx0OiAke2RlZmF1bHRMaW5rQmFzZVBhdGh9YClcclxuXHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHRcdC5zZXRQbGFjZWhvbGRlcihkZWZhdWx0TGlua0Jhc2VQYXRoKVxyXG5cdFx0XHRcdFx0LnNldFZhbHVlKGNvbnRlbnRUeXBlLmxpbmtCYXNlUGF0aCB8fCAnJylcclxuXHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlLmxpbmtCYXNlUGF0aCA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdH0pKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBZGQgQWRkaXRpb25hbCBDb250ZW50IFR5cGUgYnV0dG9uXHJcblx0XHRjb25zdCBhZGRCdXR0b24gPSBzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHsgXHJcblx0XHRcdHRleHQ6ICdBZGQgYWRkaXRpb25hbCBjb250ZW50IHR5cGUnLFxyXG5cdFx0XHRjbHM6ICdtb2QtY3RhJ1xyXG5cdFx0fSk7XHJcblx0XHRzZXRDc3NQcm9wcyhhZGRCdXR0b24sIHsgbWFyZ2luVG9wOiAnMjBweCcsIG1hcmdpbkJvdHRvbTogJzMwcHgnIH0pO1xyXG5cdFx0YWRkQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cdFx0XHR2b2lkIChhc3luYyAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWRGb2xkZXIgPSB0aGlzLnNlbGVjdENvbnRlbnRUeXBlRm9sZGVyKCk7XHJcblx0XHRcdFx0aWYgKHNlbGVjdGVkRm9sZGVyKSB7XHJcblx0XHRcdFx0XHQvLyBDYWxjdWxhdGUgcmVsYXRpdmUgcGF0aCBmcm9tIHZhdWx0IHJvb3RcclxuXHRcdFx0XHRcdGNvbnN0IHZhdWx0UGF0aCA9IHRoaXMuZ2V0VmF1bHRQYXRoKCk7XHJcblx0XHRcdFx0XHRsZXQgZm9sZGVyUGF0aCA9IHNlbGVjdGVkRm9sZGVyO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQvLyBJZiBzZWxlY3RlZCBmb2xkZXIgaXMgaW5zaWRlIHRoZSB2YXVsdCwgbWFrZSBpdCByZWxhdGl2ZVxyXG5cdFx0XHRcdFx0aWYgKHNlbGVjdGVkRm9sZGVyLnN0YXJ0c1dpdGgodmF1bHRQYXRoKSkge1xyXG5cdFx0XHRcdFx0XHRmb2xkZXJQYXRoID0gc2VsZWN0ZWRGb2xkZXIuc3Vic3RyaW5nKHZhdWx0UGF0aC5sZW5ndGgpLnJlcGxhY2UoL15bL1xcXFxdKy8sICcnKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBFeHRyYWN0IGZvbGRlciBuYW1lIGZyb20gcGF0aCAobGFzdCBzZWdtZW50KSBmb3IgdGhlIGRpc3BsYXkgbmFtZVxyXG5cdFx0XHRcdFx0Y29uc3QgcGF0aFBhcnRzID0gZm9sZGVyUGF0aC5zcGxpdCgvWy9cXFxcXS8pLmZpbHRlcihwID0+IHAubGVuZ3RoID4gMCk7XHJcblx0XHRcdFx0XHRjb25zdCBsZWFmRm9sZGVyTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV0gfHwgZm9sZGVyUGF0aDtcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0Y29uc3QgbmV3VHlwZTogQ29udGVudFR5cGVDb25maWcgPSB7XHJcblx0XHRcdFx0XHRcdGlkOiBgY29udGVudC10eXBlLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTEpfWAsXHJcblx0XHRcdFx0XHRcdG5hbWU6IHRoaXMuY2FwaXRhbGl6ZUZpcnN0KGxlYWZGb2xkZXJOYW1lKSxcclxuXHRcdFx0XHRcdFx0Zm9sZGVyOiBmb2xkZXJQYXRoLFxyXG5cdFx0XHRcdFx0XHRmaWxlT3JnYW5pemF0aW9uOiAnZmlsZScsXHJcblx0XHRcdFx0XHRcdGVuYWJsZWQ6IHRydWUsIC8vIEVuYWJsZSBieSBkZWZhdWx0IHNvIGl0IHNob3dzIHVwIGluIFN0ZXAgNVxyXG5cdFx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiAnaW5kZXgnXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5jb250ZW50VHlwZXMucHVzaChuZXdUeXBlKTtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuZGlzcGxheSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSkoKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2VsZWN0IGZvbGRlciBmb3IgYWRkaXRpb25hbCBjb250ZW50IHR5cGVcclxuXHQgKi9cclxuXHRwcml2YXRlIHNlbGVjdENvbnRlbnRUeXBlRm9sZGVyKCk6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IG11bHRpcGxlIHdheXMgdG8gYWNjZXNzIEVsZWN0cm9uIGRpYWxvZyBBUElcclxuXHRcdFx0bGV0IGRpYWxvZzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IHwgbnVsbCA9IG51bGw7XHJcblxyXG5cdFx0XHQvLyBNZXRob2QgMTogVHJ5IEBlbGVjdHJvbi9yZW1vdGUgKG5ld2VyIEVsZWN0cm9uIHZlcnNpb25zKVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZlxyXG5cdFx0XHRcdGNvbnN0IGVsZWN0cm9uUmVtb3RlID0gcmVxdWlyZSgnQGVsZWN0cm9uL3JlbW90ZScpIGFzIHsgZGlhbG9nPzogeyBzaG93T3BlbkRpYWxvZ1N5bmM/OiAob3B0aW9uczogeyB0aXRsZTogc3RyaW5nOyBkZWZhdWx0UGF0aDogc3RyaW5nOyBwcm9wZXJ0aWVzOiBzdHJpbmdbXSB9KSA9PiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB9IH07XHJcblx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb25SZW1vdGU/LmRpYWxvZyB8fCBudWxsO1xyXG5cdFx0XHR9IGNhdGNoIHtcclxuXHRcdFx0XHQvLyBOb3QgYXZhaWxhYmxlLCB0cnkgbmV4dCBtZXRob2RcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTWV0aG9kIDI6IFRyeSBlbGVjdHJvbi5yZW1vdGUuZGlhbG9nIChvbGRlciBFbGVjdHJvbiB2ZXJzaW9ucylcclxuXHRcdFx0aWYgKCFkaWFsb2cpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIG5vLXVuZGVmXHJcblx0XHRcdFx0XHRjb25zdCBlbGVjdHJvbiA9ICgod2luZG93IGFzIHsgcmVxdWlyZT86IChtb2R1bGU6IHN0cmluZykgPT4gdW5rbm93biB9KS5yZXF1aXJlPy4oJ2VsZWN0cm9uJykgfHwgcmVxdWlyZSgnZWxlY3Ryb24nKSkgYXMgeyByZW1vdGU/OiB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9IH07XHJcblx0XHRcdFx0XHRkaWFsb2cgPSBlbGVjdHJvbj8ucmVtb3RlPy5kaWFsb2cgfHwgbnVsbDtcclxuXHRcdFx0XHR9IGNhdGNoIHtcclxuXHRcdFx0XHRcdC8vIE5vdCBhdmFpbGFibGUsIHRyeSBuZXh0IG1ldGhvZFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTWV0aG9kIDM6IFRyeSBlbGVjdHJvbi5kaWFsb2cgZGlyZWN0bHkgKG1haW4gcHJvY2VzcywgbWF5IG5vdCB3b3JrKVxyXG5cdFx0XHRpZiAoIWRpYWxvZykge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgbm8tdW5kZWZcclxuXHRcdFx0XHRcdGNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKSBhcyB7IGRpYWxvZz86IHsgc2hvd09wZW5EaWFsb2dTeW5jPzogKG9wdGlvbnM6IHsgdGl0bGU6IHN0cmluZzsgZGVmYXVsdFBhdGg6IHN0cmluZzsgcHJvcGVydGllczogc3RyaW5nW10gfSkgPT4gc3RyaW5nW10gfCB1bmRlZmluZWQgfSB9O1xyXG5cdFx0XHRcdFx0ZGlhbG9nID0gZWxlY3Ryb24/LmRpYWxvZyB8fCBudWxsO1xyXG5cdFx0XHRcdH0gY2F0Y2gge1xyXG5cdFx0XHRcdFx0Ly8gTm90IGF2YWlsYWJsZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFkaWFsb2cgfHwgdHlwZW9mIGRpYWxvZy5zaG93T3BlbkRpYWxvZ1N5bmMgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIGRpYWxvZyBBUEkgbm90IGF2YWlsYWJsZScpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCB2YXVsdFBhdGggPSB0aGlzLmdldFZhdWx0UGF0aCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZGlhbG9nLnNob3dPcGVuRGlhbG9nU3luYyh7XHJcblx0XHRcdFx0dGl0bGU6ICdTZWxlY3QgQ29udGVudCBUeXBlIEZvbGRlcicsXHJcblx0XHRcdFx0ZGVmYXVsdFBhdGg6IHZhdWx0UGF0aCxcclxuXHRcdFx0XHRwcm9wZXJ0aWVzOiBbJ29wZW5EaXJlY3RvcnknXVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHQvLyBOb3JtYWxpemUgcGF0aCAocmVwbGFjZSBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmQgc2xhc2hlcywgcmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMpXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdFswXS5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvJC8sICcnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3Igb3BlbmluZyBmb2xkZXIgcGlja2VyOicsIGVycm9yKTtcclxuXHRcdFx0bmV3IE5vdGljZSgnVW5hYmxlIHRvIG9wZW4gZm9sZGVyIHBpY2tlci4gUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIE9ic2lkaWFuIG9uIGRlc2t0b3AuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHZhdWx0IHBhdGhcclxuXHQgKi9cclxuXHRwcml2YXRlIGdldFZhdWx0UGF0aCgpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgeyBiYXNlUGF0aD86IHN0cmluZzsgcGF0aD86IHN0cmluZyB9O1xyXG5cdFx0Y29uc3QgdmF1bHRQYXRoID0gYWRhcHRlci5iYXNlUGF0aCB8fCBhZGFwdGVyLnBhdGg7XHJcblx0XHQvLyBSZXNvbHZlIHBhdGggKGNvbnZlcnQgcmVsYXRpdmUgdG8gYWJzb2x1dGUsIG5vcm1hbGl6ZSBzZXBhcmF0b3JzKVxyXG5cdFx0aWYgKHZhdWx0UGF0aCkge1xyXG5cdFx0XHQvLyBJZiBhbHJlYWR5IGFic29sdXRlLCByZXR1cm4gYXMtaXMgKG5vcm1hbGl6ZWQpXHJcblx0XHRcdGlmICh2YXVsdFBhdGguc3RhcnRzV2l0aCgnLycpIHx8IC9eW0EtWl06Ly50ZXN0KHZhdWx0UGF0aCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gdmF1bHRQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBGb3IgcmVsYXRpdmUgcGF0aHMsIHdlJ2QgbmVlZCB0byByZXNvbHZlLCBidXQgaW4gT2JzaWRpYW4gY29udGV4dCwgYmFzZVBhdGggc2hvdWxkIGJlIGFic29sdXRlXHJcblx0XHRcdHJldHVybiB2YXVsdFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gRmFsbGJhY2sgLSBpbiBPYnNpZGlhbiBjb250ZXh0IHRoaXMgc2hvdWxkbid0IGhhcHBlblxyXG5cdFx0cmV0dXJuICcvJztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyXHJcblx0ICovXHJcblx0cHJpdmF0ZSBjYXBpdGFsaXplRmlyc3Qoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxuXHR9XHJcblxyXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUuY29udGVudFR5cGVzLnNvbWUoY3QgPT4gY3QuZW5hYmxlZCk7XHJcblx0fVxyXG5cclxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdDb250ZW50IHR5cGVzJztcclxuXHR9XHJcblxyXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gJ0NvbmZpZ3VyZSBjb250ZW50IHR5cGVzJztcclxuXHR9XHJcbn1cclxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBBc3Ryb0NvbXBvc2VyQ29uZmlnLCBDb250ZW50VHlwZUNvbmZpZywgRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLCBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgUGF0aFJlc29sdmVyIH0gZnJvbSAnLi9QYXRoUmVzb2x2ZXInO1xuXG50eXBlIFBsdWdpbldpdGhTZXR0aW5ncyA9IHtcblx0c2V0dGluZ3M/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbn07XG5cbnR5cGUgUGx1Z2luc0FQSSA9IHtcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIFBsdWdpbldpdGhTZXR0aW5ncz47XG59O1xuXG5leHBvcnQgY2xhc3MgQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvciB7XG5cdHByaXZhdGUgYXBwOiBBcHA7XG5cdHByaXZhdGUgZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzPzogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIH07XG5cdHByaXZhdGUgY29udGVudFR5cGVzPzogQ29udGVudFR5cGVDb25maWdbXTtcblx0cHJpdmF0ZSBwYXRoUmVzb2x2ZXI6IFBhdGhSZXNvbHZlcjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMucGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcihhcHApO1xuXHR9XG5cblx0Y29uZmlndXJlQXN0cm9Db21wb3Nlcihcblx0XHRjb250ZW50VHlwZXM6IENvbnRlbnRUeXBlQ29uZmlnW10sXG5cdFx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiB7IFtjb250ZW50VHlwZUlkOiBzdHJpbmddOiBGcm9udG1hdHRlclByb3BlcnRpZXMgfSxcblx0XHRwcm9qZWN0Um9vdDogc3RyaW5nLFxuXHRcdGNvbmZpZ0ZpbGVQYXRoOiBzdHJpbmcsXG5cdFx0ZGVmYXVsdENvbnRlbnRUeXBlSWQ/OiBzdHJpbmcsXG5cdFx0cHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQsXG5cdFx0ZW5hYmxlTWR4U3VwcG9ydD86IGJvb2xlYW5cblx0KTogUHJvbWlzZTxBc3Ryb0NvbXBvc2VyQ29uZmlnPiB7XG5cdFx0Ly8gU3RvcmUgZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIGFuZCBjb250ZW50VHlwZXMgZm9yIHVzZSBpbiBzYXZlQ29uZmlnXG5cdFx0dGhpcy5mcm9udG1hdHRlclByb3BlcnRpZXMgPSBmcm9udG1hdHRlclByb3BlcnRpZXM7XG5cdFx0dGhpcy5jb250ZW50VHlwZXMgPSBjb250ZW50VHlwZXM7XG5cdFx0XG5cdFx0Y29uc3QgY29uZmlnOiBBc3Ryb0NvbXBvc2VyQ29uZmlnID0ge1xuXHRcdFx0Y3VzdG9tQ29udGVudFR5cGVzOiBbXSxcblx0XHRcdGRlZmF1bHRUZW1wbGF0ZTogJycsXG5cdFx0XHRjb25maWdGaWxlUGF0aDogdGhpcy5yZWxhdGl2ZVBhdGgoY29uZmlnRmlsZVBhdGgpLFxuXHRcdFx0dGVybWluYWxQcm9qZWN0Um9vdFBhdGg6IHRoaXMucmVsYXRpdmVQYXRoKHByb2plY3RSb290KSxcblx0XHRcdHNob3dNZHhGaWxlc0luRXhwbG9yZXI6IGVuYWJsZU1keFN1cHBvcnQgPz8gZmFsc2Vcblx0XHR9O1xuXG5cdFx0Ly8gQWRkIGFsbCBlbmFibGVkIGNvbnRlbnQgdHlwZXMgdG8gY3VzdG9tQ29udGVudFR5cGVzIChuZXcgdW5pZmllZCBzdHJ1Y3R1cmUpXG5cdFx0Ly8gU2VwYXJhdGUgZGVmYXVsdCBjb250ZW50IHR5cGUgZnJvbSBvdGhlcnMgdG8gcHV0IGl0IGZpcnN0XG5cdFx0Y29uc3QgZGVmYXVsdENvbnRlbnRUeXBlID0gZGVmYXVsdENvbnRlbnRUeXBlSWQgPyBjb250ZW50VHlwZXMuZmluZChjdCA9PiBjdC5pZCA9PT0gZGVmYXVsdENvbnRlbnRUeXBlSWQgJiYgY3QuZW5hYmxlZCkgOiBudWxsO1xuXHRcdGNvbnN0IG90aGVyQ29udGVudFR5cGVzID0gY29udGVudFR5cGVzLmZpbHRlcihjdCA9PiBjdC5lbmFibGVkICYmICghZGVmYXVsdENvbnRlbnRUeXBlSWQgfHwgY3QuaWQgIT09IGRlZmF1bHRDb250ZW50VHlwZUlkKSk7XG5cblx0XHQvLyBBZGQgZGVmYXVsdCBjb250ZW50IHR5cGUgZmlyc3QgaWYgaXQgZXhpc3RzXG5cdFx0aWYgKGRlZmF1bHRDb250ZW50VHlwZSkge1xuXHRcdFx0Y29uc3QgcHJvcHMgPSBmcm9udG1hdHRlclByb3BlcnRpZXNbZGVmYXVsdENvbnRlbnRUeXBlLmlkXTtcblx0XHRcdGxldCBsaW5rQmFzZVBhdGggPSBkZWZhdWx0Q29udGVudFR5cGUubGlua0Jhc2VQYXRoO1xuXHRcdFx0aWYgKGxpbmtCYXNlUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGxpbmtCYXNlUGF0aCA9PT0gJycpIHtcblx0XHRcdFx0Ly8gVXNlIG9ubHkgdGhlIGZvbGRlciBuYW1lIGZvciB0aGUgZGVmYXVsdCBsaW5rIGJhc2UgcGF0aCAoZS5nLiBcInNyYy9jb250ZW50L3Bvc3RzXCIgLT4gXCIvcG9zdHMvXCIpXG5cdFx0XHRcdGNvbnN0IHBhdGhQYXJ0cyA9IGRlZmF1bHRDb250ZW50VHlwZS5mb2xkZXIuc3BsaXQoJy8nKS5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuXHRcdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXSB8fCBkZWZhdWx0Q29udGVudFR5cGUuZm9sZGVyO1xuXHRcdFx0XHRsaW5rQmFzZVBhdGggPSBgLyR7Zm9sZGVyTmFtZX0vYDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IHRoaXMucGF0aFJlc29sdmVyLmdldEFzdHJvQ29tcG9zZXJGb2xkZXJQYXRoKGRlZmF1bHRDb250ZW50VHlwZS5mb2xkZXIsIHByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0Y29uZmlnLmN1c3RvbUNvbnRlbnRUeXBlcy5wdXNoKHtcblx0XHRcdFx0aWQ6IGRlZmF1bHRDb250ZW50VHlwZS5pZCxcblx0XHRcdFx0bmFtZTogZGVmYXVsdENvbnRlbnRUeXBlLm5hbWUsXG5cdFx0XHRcdGZvbGRlcjogZm9sZGVyUGF0aCxcblx0XHRcdFx0dGVtcGxhdGU6IHByb3BzPy50ZW1wbGF0ZSB8fCB0aGlzLmdlbmVyYXRlVGVtcGxhdGUocHJvcHMpLFxuXHRcdFx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdFx0XHRsaW5rQmFzZVBhdGg6IGxpbmtCYXNlUGF0aCxcblx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBkZWZhdWx0Q29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbixcblx0XHRcdFx0aW5kZXhGaWxlTmFtZTogZGVmYXVsdENvbnRlbnRUeXBlLmluZGV4RmlsZU5hbWUgfHwgJ2luZGV4J1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFNldCBsZWdhY3kgZmllbGRzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB1c2luZyB0aGUgZGVmYXVsdCBjb250ZW50IHR5cGVcblx0XHRcdGNvbmZpZy5wb3N0c0ZvbGRlciA9IGZvbGRlclBhdGg7XG5cdFx0XHRjb25maWcucG9zdHNDcmVhdGlvbk1vZGUgPSBkZWZhdWx0Q29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbjtcblx0XHRcdGNvbmZpZy5wb3N0c0luZGV4RmlsZU5hbWUgPSBkZWZhdWx0Q29udGVudFR5cGUuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnO1xuXHRcdFx0Y29uZmlnLmRlZmF1bHRUZW1wbGF0ZSA9IHByb3BzPy50ZW1wbGF0ZSB8fCB0aGlzLmdlbmVyYXRlVGVtcGxhdGUocHJvcHMpO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBvdGhlciBjb250ZW50IHR5cGVzXG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBvdGhlckNvbnRlbnRUeXBlcykge1xuXHRcdFx0Y29uc3QgcHJvcHMgPSBmcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdO1xuXHRcdFx0Ly8gRGV0ZXJtaW5lIGxpbmtCYXNlUGF0aDogdXNlIHNwZWNpZmllZCwgb3IgZGVmYXVsdCB0byAvZm9sZGVyTmFtZS9cblx0XHRcdC8vIElmIGJsYW5rLCBkZWZhdWx0IHRvIC9mb2xkZXJOYW1lLy4gSWYgXCIvXCIsIHVzZSBcIi9cIiBmb3Igcm9vdC5cblx0XHRcdGxldCBsaW5rQmFzZVBhdGggPSBjb250ZW50VHlwZS5saW5rQmFzZVBhdGg7XG5cdFx0XHRpZiAobGlua0Jhc2VQYXRoID09PSB1bmRlZmluZWQgfHwgbGlua0Jhc2VQYXRoID09PSAnJykge1xuXHRcdFx0XHQvLyBVc2Ugb25seSB0aGUgZm9sZGVyIG5hbWUgZm9yIHRoZSBkZWZhdWx0IGxpbmsgYmFzZSBwYXRoIChlLmcuIFwic3JjL2NvbnRlbnQvcG9zdHNcIiAtPiBcIi9wb3N0cy9cIilcblx0XHRcdFx0Y29uc3QgcGF0aFBhcnRzID0gY29udGVudFR5cGUuZm9sZGVyLnNwbGl0KCcvJykuZmlsdGVyKHAgPT4gcC5sZW5ndGggPiAwKTtcblx0XHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV0gfHwgY29udGVudFR5cGUuZm9sZGVyO1xuXHRcdFx0XHRsaW5rQmFzZVBhdGggPSBgLyR7Zm9sZGVyTmFtZX0vYDtcblx0XHRcdH1cblx0XHRcdC8vIElmIHVzZXIgc3BlY2lmaWVkIFwiL1wiLCBrZWVwIGl0IGFzIFwiL1wiIGZvciByb290XG5cdFx0XHRcblx0XHRcdGNvbnN0IGZvbGRlclBhdGggPSB0aGlzLnBhdGhSZXNvbHZlci5nZXRBc3Ryb0NvbXBvc2VyRm9sZGVyUGF0aChjb250ZW50VHlwZS5mb2xkZXIsIHByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0Y29uZmlnLmN1c3RvbUNvbnRlbnRUeXBlcy5wdXNoKHtcblx0XHRcdFx0aWQ6IGNvbnRlbnRUeXBlLmlkLFxuXHRcdFx0XHRuYW1lOiBjb250ZW50VHlwZS5uYW1lLFxuXHRcdFx0XHRmb2xkZXI6IGZvbGRlclBhdGgsXG5cdFx0XHRcdC8vIFVzZSB0ZW1wbGF0ZSBmcm9tIHByb3BzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGdlbmVyYXRlXG5cdFx0XHRcdHRlbXBsYXRlOiBwcm9wcz8udGVtcGxhdGUgfHwgdGhpcy5nZW5lcmF0ZVRlbXBsYXRlKHByb3BzKSxcblx0XHRcdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0bGlua0Jhc2VQYXRoOiBsaW5rQmFzZVBhdGgsXG5cdFx0XHRcdGNyZWF0aW9uTW9kZTogY29udGVudFR5cGUuZmlsZU9yZ2FuaXphdGlvbixcblx0XHRcdFx0aW5kZXhGaWxlTmFtZTogY29udGVudFR5cGUuaW5kZXhGaWxlTmFtZSB8fCAnaW5kZXgnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlVGVtcGxhdGUocHJvcHM6IEZyb250bWF0dGVyUHJvcGVydGllcyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG5cdFx0Ly8gVXNlIHRlbXBsYXRlIGZyb20gcHJvcHMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZ2VuZXJhdGUgZGVmYXVsdFxuXHRcdGlmIChwcm9wcz8udGVtcGxhdGUpIHtcblx0XHRcdHJldHVybiBwcm9wcy50ZW1wbGF0ZTtcblx0XHR9XG5cblx0XHRpZiAoIXByb3BzKSB7XG5cdFx0XHRyZXR1cm4gJy0tLVxcbnRpdGxlOiBcInt7dGl0bGV9fVwiXFxuLS0tXFxuJztcblx0XHR9XG5cblx0XHRsZXQgdGVtcGxhdGUgPSAnLS0tXFxuJztcblx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy50aXRsZVByb3BlcnR5IHx8ICd0aXRsZSd9OiBcInt7dGl0bGV9fVwiXFxuYDtcblx0XHRcblx0XHRpZiAocHJvcHMuZGF0ZVByb3BlcnR5KSB7XG5cdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy5kYXRlUHJvcGVydHl9OiB7e2RhdGV9fVxcbmA7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5fTogXCJcIlxcbmA7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChwcm9wcy50YWdzUHJvcGVydHkpIHtcblx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLnRhZ3NQcm9wZXJ0eX06IFtdXFxuYDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdGNvbnN0IGRyYWZ0VmFsdWUgPSBwcm9wcy5kcmFmdExvZ2ljID09PSAnZmFsc2UtZHJhZnQnID8gJ2ZhbHNlJyA6ICd0cnVlJztcblx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRyYWZ0UHJvcGVydHl9OiAke2RyYWZ0VmFsdWV9XFxuYDtcblx0XHR9XG5cdFx0XG5cdFx0dGVtcGxhdGUgKz0gJy0tLVxcbic7XG5cblx0XHRyZXR1cm4gdGVtcGxhdGU7XG5cdH1cblxuXHRwcml2YXRlIGdldENyZWF0aW9uTW9kZUZyb21BdHRhY2htZW50SGFuZGxpbmcobW9kZTogJ3NwZWNpZmllZC1mb2xkZXInIHwgJ3NhbWUtZm9sZGVyJyB8ICdzdWJmb2xkZXInKTogJ2ZpbGUnIHwgJ2ZvbGRlcicge1xuXHRcdC8vIHNhbWUtZm9sZGVyIG1lYW5zIGF0dGFjaG1lbnRzIGFyZSBpbiB0aGUgc2FtZSBmb2xkZXIgYXMgdGhlIGZpbGUgKGZvbGRlci1iYXNlZCBhcHByb2FjaClcblx0XHQvLyBzcGVjaWZpZWQtZm9sZGVyIGFuZCBzdWJmb2xkZXIgbWVhbiBhdHRhY2htZW50cyBhcmUgaW4gc2VwYXJhdGUgZm9sZGVycyAoZmlsZS1iYXNlZCBhcHByb2FjaClcblx0XHRyZXR1cm4gbW9kZSA9PT0gJ3NhbWUtZm9sZGVyJyA/ICdmb2xkZXInIDogJ2ZpbGUnO1xuXHR9XG5cblx0cHJpdmF0ZSByZWxhdGl2ZVBhdGgoaW5wdXRQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdC8vIElmIHBhdGggaXMgYWxyZWFkeSByZWxhdGl2ZSwgcmV0dXJuIGFzLWlzIChubyBsZWFkaW5nIC8gb3IgZHJpdmUgbGV0dGVyKVxuXHRcdGlmICghaW5wdXRQYXRoLnN0YXJ0c1dpdGgoJy8nKSAmJiAhL15bQS1aXTovLnRlc3QoaW5wdXRQYXRoKSkge1xuXHRcdFx0cmV0dXJuIGlucHV0UGF0aDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gQ29udmVydCBhYnNvbHV0ZSBwYXRoIHRvIHJlbGF0aXZlIGZyb20gdmF1bHQgcm9vdFxuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyIGFzIHsgYmFzZVBhdGg/OiBzdHJpbmc7IHBhdGg/OiBzdHJpbmcgfTtcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcblx0XHRpZiAoIXZhdWx0UGF0aCkge1xuXHRcdFx0cmV0dXJuIGlucHV0UGF0aDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gTm9ybWFsaXplIHBhdGhzIChyZXBsYWNlIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZCBzbGFzaGVzLCByZW1vdmUgdHJhaWxpbmcgc2xhc2hlcylcblx0XHRjb25zdCB2YXVsdE5vcm1hbGl6ZWQgPSB2YXVsdFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cdFx0Y29uc3QgYWJzb2x1dGVOb3JtYWxpemVkID0gaW5wdXRQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuXHRcdFxuXHRcdGlmIChhYnNvbHV0ZU5vcm1hbGl6ZWQuc3RhcnRzV2l0aCh2YXVsdE5vcm1hbGl6ZWQpKSB7XG5cdFx0XHRjb25zdCByZWxhdGl2ZSA9IGFic29sdXRlTm9ybWFsaXplZC5zbGljZSh2YXVsdE5vcm1hbGl6ZWQubGVuZ3RoKTtcblx0XHRcdC8vIFJlbW92ZSBsZWFkaW5nIHBhdGggc2VwYXJhdG9yXG5cdFx0XHRyZXR1cm4gcmVsYXRpdmUuc3RhcnRzV2l0aCgnLycpID8gcmVsYXRpdmUuc2xpY2UoMSkgOiByZWxhdGl2ZTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gUGF0aCBpcyBvdXRzaWRlIHZhdWx0LCByZXR1cm4gYXMtaXNcblx0XHRyZXR1cm4gaW5wdXRQYXRoO1xuXHR9XG5cblx0YXN5bmMgc2F2ZUNvbmZpZyhjb25maWc6IEFzdHJvQ29tcG9zZXJDb25maWcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gVXNlIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2QgbGlrZSBhc3Ryby1tb2R1bGFyLXNldHRpbmdzIGRvZXNcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xuXHRcdFx0Y29uc3QgYXN0cm9Db21wb3NlclBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LlsnYXN0cm8tY29tcG9zZXInXTtcblx0XHRcdFxuXHRcdFx0aWYgKCFhc3Ryb0NvbXBvc2VyUGx1Z2luKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignQXN0cm9Db21wb3NlckNvbmZpZzogQXN0cm8gQ29tcG9zZXIgcGx1Z2luIG5vdCBmb3VuZCwgdXNpbmcgZmFsbGJhY2sgZmlsZSBtZXRob2QnKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIWFzdHJvQ29tcG9zZXJQbHVnaW4uc2V0dGluZ3MpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdBc3Ryb0NvbXBvc2VyQ29uZmlnOiBBc3RybyBDb21wb3NlciBwbHVnaW4gc2V0dGluZ3Mgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2sgZmlsZSBtZXRob2QnKTtcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRjb25zdCBwbHVnaW5TZXR0aW5ncyA9IGFzdHJvQ29tcG9zZXJQbHVnaW4uc2V0dGluZ3M7XG5cdFx0XHRcblx0XHRcdC8vIFVwZGF0ZSB0ZW1wbGF0ZXMgZnJvbSBjb25maWdcblx0XHRcdGlmIChjb25maWcuZGVmYXVsdFRlbXBsYXRlKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLmRlZmF1bHRUZW1wbGF0ZSA9IGNvbmZpZy5kZWZhdWx0VGVtcGxhdGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnBhZ2VUZW1wbGF0ZSkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5wYWdlVGVtcGxhdGUgPSBjb25maWcucGFnZVRlbXBsYXRlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBVcGRhdGUgcG9zdHMvcGFnZXMgZm9sZGVyIHNldHRpbmdzXG5cdFx0XHRpZiAoY29uZmlnLnBvc3RzRm9sZGVyKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLnBvc3RzRm9sZGVyID0gY29uZmlnLnBvc3RzRm9sZGVyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5wb3N0c0NyZWF0aW9uTW9kZSkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5jcmVhdGlvbk1vZGUgPSBjb25maWcucG9zdHNDcmVhdGlvbk1vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnBvc3RzSW5kZXhGaWxlTmFtZSkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5pbmRleEZpbGVOYW1lID0gY29uZmlnLnBvc3RzSW5kZXhGaWxlTmFtZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcuZW5hYmxlUGFnZXMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVQYWdlcyA9IGNvbmZpZy5lbmFibGVQYWdlcztcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcucGFnZXNGb2xkZXIpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MucGFnZXNGb2xkZXIgPSBjb25maWcucGFnZXNGb2xkZXI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnLnBhZ2VzQ3JlYXRpb25Nb2RlKSB7XG5cdFx0XHRcdHBsdWdpblNldHRpbmdzLnBhZ2VzQ3JlYXRpb25Nb2RlID0gY29uZmlnLnBhZ2VzQ3JlYXRpb25Nb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbmZpZy5wYWdlc0luZGV4RmlsZU5hbWUpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MucGFnZXNJbmRleEZpbGVOYW1lID0gY29uZmlnLnBhZ2VzSW5kZXhGaWxlTmFtZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gVXBkYXRlIGNvbmZpZyBwYXRoc1xuXHRcdFx0aWYgKGNvbmZpZy5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5jb25maWdGaWxlUGF0aCA9IGNvbmZpZy5jb25maWdGaWxlUGF0aDtcblx0XHRcdH1cblx0XHRcdGlmIChjb25maWcudGVybWluYWxQcm9qZWN0Um9vdFBhdGgpIHtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MudGVybWluYWxQcm9qZWN0Um9vdFBhdGggPSBjb25maWcudGVybWluYWxQcm9qZWN0Um9vdFBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVuc3VyZSBjb21tYW5kcyBhcmUgZW5hYmxlZCBvbmx5IGlmIHBhdGhzIGFyZSBwcmVzZW50XG5cdFx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoICYmIGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVPcGVuVGVybWluYWxDb21tYW5kID0gdHJ1ZTtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZW5hYmxlT3BlbkNvbmZpZ0ZpbGVDb21tYW5kID0gdHJ1ZTtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZW5hYmxlVGVybWluYWxSaWJib25JY29uID0gdHJ1ZTtcblx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZW5hYmxlQ29uZmlnUmliYm9uSWNvbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFVwZGF0ZSBNRFggc3VwcG9ydCBmbGFnXG5cdFx0XHRpZiAoY29uZmlnLnNob3dNZHhGaWxlc0luRXhwbG9yZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5zaG93TWR4RmlsZXNJbkV4cGxvcmVyID0gY29uZmlnLnNob3dNZHhGaWxlc0luRXhwbG9yZXI7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0FzdHJvQ29tcG9zZXJDb25maWc6IFNldCBzaG93TWR4RmlsZXNJbkV4cGxvcmVyIHRvJywgY29uZmlnLnNob3dNZHhGaWxlc0luRXhwbG9yZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQXN0cm9Db21wb3NlckNvbmZpZzogc2hvd01keEZpbGVzSW5FeHBsb3JlciBpcyB1bmRlZmluZWQsIG5vdCB1cGRhdGluZycpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBVcGRhdGUgY29udGVudFR5cGVzIGFycmF5IChuZXcgdW5pZmllZCBzdHJ1Y3R1cmUpXG5cdFx0XHQvLyBJbml0aWFsaXplIGNvbnRlbnRUeXBlcyBhcnJheSBpZiBpdCBkb2Vzbid0IGV4aXN0XG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkocGx1Z2luU2V0dGluZ3MuY29udGVudFR5cGVzKSkge1xuXHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5jb250ZW50VHlwZXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gTWVyZ2UvdXBkYXRlIGNvbnRlbnRUeXBlcyBhcnJheSAtIG1hdGNoIGJ5IG5hbWUgQU5EIGZvbGRlciB0byBmaW5kIGV4aXN0aW5nIGVudHJpZXNcblx0XHRcdGZvciAoY29uc3QgbmV3VHlwZSBvZiBjb25maWcuY3VzdG9tQ29udGVudFR5cGVzKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgZnJvbnRtYXR0ZXIgcHJvcGVydGllcyB0byBjaGVjayBkcmFmdCBzdGF0dXNcblx0XHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSB0aGlzLmNvbnRlbnRUeXBlcz8uZmluZChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRcdGNvbnN0IHByb3BzID0gY29udGVudFR5cGUgJiYgdGhpcy5mcm9udG1hdHRlclByb3BlcnRpZXMgPyB0aGlzLmZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF0gOiB1bmRlZmluZWQ7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgaWYgdW5kZXJzY29yZSBwcmVmaXggc2hvdWxkIGJlIGVuYWJsZWRcblx0XHRcdFx0Ly8gRW5hYmxlIGlmIGhhc0RyYWZ0U3RhdHVzIGlzIHRydWUgYnV0IGRyYWZ0UHJvcGVydHkgaXMgYmxhbmsvdW5kZWZpbmVkXG5cdFx0XHRcdGNvbnN0IHNob3VsZEVuYWJsZVVuZGVyc2NvcmVQcmVmaXggPSBwcm9wcz8uaGFzRHJhZnRTdGF0dXMgPT09IHRydWUgJiYgIXByb3BzPy5kcmFmdFByb3BlcnR5O1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRmluZCBleGlzdGluZyBlbnRyeSBieSBuYW1lIEFORCBmb2xkZXIgKG5vdCBqdXN0IGlkLCBzaW5jZSBpZHMgbWlnaHQgZGlmZmVyKVxuXHRcdFx0XHRjb25zdCBjb250ZW50VHlwZXMgPSAocGx1Z2luU2V0dGluZ3MuY29udGVudFR5cGVzIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW107XG5cdFx0XHRcdGNvbnN0IGV4aXN0aW5nSW5kZXggPSBjb250ZW50VHlwZXMuZmluZEluZGV4KChjdDogeyBuYW1lPzogc3RyaW5nOyBmb2xkZXI/OiBzdHJpbmcgfSkgPT4gXG5cdFx0XHRcdFx0Y3QubmFtZSA9PT0gbmV3VHlwZS5uYW1lICYmIGN0LmZvbGRlciA9PT0gbmV3VHlwZS5mb2xkZXJcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZyBlbnRyeSAtIHByZXNlcnZlIG90aGVyIHByb3BlcnRpZXMgbGlrZSBpZ25vcmVTdWJmb2xkZXJzLCBlbmFibGVVbmRlcnNjb3JlUHJlZml4LCBhbmQgZXhpc3RpbmcgaWRcblx0XHRcdFx0XHRjb25zdCBleGlzdGluZ0VudHJ5ID0gY29udGVudFR5cGVzW2V4aXN0aW5nSW5kZXhdO1xuXHRcdFx0XHRcdGNvbnRlbnRUeXBlc1tleGlzdGluZ0luZGV4XSA9IHtcblx0XHRcdFx0XHRcdC4uLmV4aXN0aW5nRW50cnksXG5cdFx0XHRcdFx0XHRuYW1lOiBuZXdUeXBlLm5hbWUsXG5cdFx0XHRcdFx0XHRmb2xkZXI6IG5ld1R5cGUuZm9sZGVyLFxuXHRcdFx0XHRcdFx0bGlua0Jhc2VQYXRoOiBuZXdUeXBlLmxpbmtCYXNlUGF0aCxcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiBuZXdUeXBlLnRlbXBsYXRlLFxuXHRcdFx0XHRcdFx0ZW5hYmxlZDogbmV3VHlwZS5lbmFibGVkLFxuXHRcdFx0XHRcdFx0Y3JlYXRpb25Nb2RlOiBuZXdUeXBlLmNyZWF0aW9uTW9kZSxcblx0XHRcdFx0XHRcdGluZGV4RmlsZU5hbWU6IG5ld1R5cGUuaW5kZXhGaWxlTmFtZSxcblx0XHRcdFx0XHRcdGVuYWJsZVVuZGVyc2NvcmVQcmVmaXg6IHNob3VsZEVuYWJsZVVuZGVyc2NvcmVQcmVmaXhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEFkZCBuZXcgZW50cnkgd2l0aCBhbGwgcmVxdWlyZWQgcHJvcGVydGllc1xuXHRcdFx0XHRcdGNvbnRlbnRUeXBlcy5wdXNoKHtcblx0XHRcdFx0XHRcdGlkOiBuZXdUeXBlLmlkLFxuXHRcdFx0XHRcdFx0bmFtZTogbmV3VHlwZS5uYW1lLFxuXHRcdFx0XHRcdFx0Zm9sZGVyOiBuZXdUeXBlLmZvbGRlcixcblx0XHRcdFx0XHRcdGxpbmtCYXNlUGF0aDogbmV3VHlwZS5saW5rQmFzZVBhdGgsXG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogbmV3VHlwZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdGVuYWJsZWQ6IG5ld1R5cGUuZW5hYmxlZCxcblx0XHRcdFx0XHRcdGNyZWF0aW9uTW9kZTogbmV3VHlwZS5jcmVhdGlvbk1vZGUsXG5cdFx0XHRcdFx0XHRpbmRleEZpbGVOYW1lOiBuZXdUeXBlLmluZGV4RmlsZU5hbWUsXG5cdFx0XHRcdFx0XHRpZ25vcmVTdWJmb2xkZXJzOiBmYWxzZSxcblx0XHRcdFx0XHRcdGVuYWJsZVVuZGVyc2NvcmVQcmVmaXg6IHNob3VsZEVuYWJsZVVuZGVyc2NvcmVQcmVmaXhcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBBbHNvIHVwZGF0ZSBsZWdhY3kgY3VzdG9tQ29udGVudFR5cGVzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0cGx1Z2luU2V0dGluZ3MuY3VzdG9tQ29udGVudFR5cGVzID0gdGhpcy5tZXJnZUN1c3RvbUNvbnRlbnRUeXBlcyhcblx0XHRcdFx0KHBsdWdpblNldHRpbmdzLmN1c3RvbUNvbnRlbnRUeXBlcyBhcyBBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4pIHx8IFtdLFxuXHRcdFx0XHQoY29uZmlnLmN1c3RvbUNvbnRlbnRUeXBlcyBhcyB1bmtub3duIGFzIEFycmF5PFJlY29yZDxzdHJpbmcsIHVua25vd24+PikgfHwgW11cblx0XHRcdCk7XG5cdFx0XHRcblx0XHRcdC8vIFNhdmUgdGhlIHNldHRpbmdzIHVzaW5nIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2Rcblx0XHRcdGlmICh0eXBlb2YgYXN0cm9Db21wb3NlclBsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0YXdhaXQgYXN0cm9Db21wb3NlclBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnQXN0cm9Db21wb3NlckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignQXN0cm9Db21wb3NlckNvbmZpZzogUGx1Z2luIHNhdmVTZXR0aW5ncyBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjaycpO1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBBc3RybyBDb21wb3NlciBjb25maWcgdmlhIHBsdWdpbiBtZXRob2Q6JywgZXJyb3IpO1xuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2Rcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnOiBBc3Ryb0NvbXBvc2VyQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnYXN0cm8tY29tcG9zZXInO1xuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcjtcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xuXHRcdFxuXHRcdGxldCBleGlzdGluZ0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG5cdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xuXHRcdFxuXHRcdC8vIFJlYWQgZXhpc3RpbmcgZGF0YSBpZiBmaWxlIGV4aXN0c1xuXHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIEFzdHJvIENvbXBvc2VyIGRhdGEuanNvbiwgc3RhcnRpbmcgZnJlc2g6JywgZXJyb3IpO1xuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gTWVyZ2UgY29uZmlnIGludG8gZXhpc3RpbmcgZGF0YVxuXHRcdGlmIChjb25maWcuZGVmYXVsdFRlbXBsYXRlKSBleGlzdGluZ0RhdGEuZGVmYXVsdFRlbXBsYXRlID0gY29uZmlnLmRlZmF1bHRUZW1wbGF0ZTtcblx0XHRpZiAoY29uZmlnLnBhZ2VUZW1wbGF0ZSkgZXhpc3RpbmdEYXRhLnBhZ2VUZW1wbGF0ZSA9IGNvbmZpZy5wYWdlVGVtcGxhdGU7XG5cdFx0aWYgKGNvbmZpZy5wb3N0c0ZvbGRlcikgZXhpc3RpbmdEYXRhLnBvc3RzRm9sZGVyID0gY29uZmlnLnBvc3RzRm9sZGVyO1xuXHRcdGlmIChjb25maWcucG9zdHNDcmVhdGlvbk1vZGUpIGV4aXN0aW5nRGF0YS5jcmVhdGlvbk1vZGUgPSBjb25maWcucG9zdHNDcmVhdGlvbk1vZGU7XG5cdFx0aWYgKGNvbmZpZy5wb3N0c0luZGV4RmlsZU5hbWUpIGV4aXN0aW5nRGF0YS5pbmRleEZpbGVOYW1lID0gY29uZmlnLnBvc3RzSW5kZXhGaWxlTmFtZTtcblx0XHRpZiAoY29uZmlnLmVuYWJsZVBhZ2VzICE9PSB1bmRlZmluZWQpIGV4aXN0aW5nRGF0YS5lbmFibGVQYWdlcyA9IGNvbmZpZy5lbmFibGVQYWdlcztcblx0XHRpZiAoY29uZmlnLnBhZ2VzRm9sZGVyKSBleGlzdGluZ0RhdGEucGFnZXNGb2xkZXIgPSBjb25maWcucGFnZXNGb2xkZXI7XG5cdFx0aWYgKGNvbmZpZy5wYWdlc0NyZWF0aW9uTW9kZSkgZXhpc3RpbmdEYXRhLnBhZ2VzQ3JlYXRpb25Nb2RlID0gY29uZmlnLnBhZ2VzQ3JlYXRpb25Nb2RlO1xuXHRcdGlmIChjb25maWcucGFnZXNJbmRleEZpbGVOYW1lKSBleGlzdGluZ0RhdGEucGFnZXNJbmRleEZpbGVOYW1lID0gY29uZmlnLnBhZ2VzSW5kZXhGaWxlTmFtZTtcblx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoKSBleGlzdGluZ0RhdGEuY29uZmlnRmlsZVBhdGggPSBjb25maWcuY29uZmlnRmlsZVBhdGg7XG5cdFx0aWYgKGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkgZXhpc3RpbmdEYXRhLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoID0gY29uZmlnLnRlcm1pbmFsUHJvamVjdFJvb3RQYXRoO1xuXHRcdGlmIChjb25maWcuc2hvd01keEZpbGVzSW5FeHBsb3JlciAhPT0gdW5kZWZpbmVkKSBleGlzdGluZ0RhdGEuc2hvd01keEZpbGVzSW5FeHBsb3JlciA9IGNvbmZpZy5zaG93TWR4RmlsZXNJbkV4cGxvcmVyO1xuXG5cdFx0Ly8gRW5zdXJlIGNvbW1hbmRzIGFyZSBlbmFibGVkIG9ubHkgaWYgcGF0aHMgYXJlIHByZXNlbnRcblx0XHRpZiAoY29uZmlnLmNvbmZpZ0ZpbGVQYXRoICYmIGNvbmZpZy50ZXJtaW5hbFByb2plY3RSb290UGF0aCkge1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmVuYWJsZU9wZW5UZXJtaW5hbENvbW1hbmQgPSB0cnVlO1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmVuYWJsZU9wZW5Db25maWdGaWxlQ29tbWFuZCA9IHRydWU7XG5cdFx0XHRleGlzdGluZ0RhdGEuZW5hYmxlVGVybWluYWxSaWJib25JY29uID0gdHJ1ZTtcblx0XHRcdGV4aXN0aW5nRGF0YS5lbmFibGVDb25maWdSaWJib25JY29uID0gdHJ1ZTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gVXBkYXRlIGNvbnRlbnRUeXBlcyBhcnJheSAobmV3IHVuaWZpZWQgc3RydWN0dXJlKVxuXHRcdGlmICghQXJyYXkuaXNBcnJheShleGlzdGluZ0RhdGEuY29udGVudFR5cGVzKSkge1xuXHRcdFx0ZXhpc3RpbmdEYXRhLmNvbnRlbnRUeXBlcyA9IFtdO1xuXHRcdH1cblx0XHRcblx0XHQvLyBNZXJnZS91cGRhdGUgY29udGVudFR5cGVzIGFycmF5IC0gbWF0Y2ggYnkgbmFtZSBBTkQgZm9sZGVyIHRvIGZpbmQgZXhpc3RpbmcgZW50cmllc1xuXHRcdGZvciAoY29uc3QgbmV3VHlwZSBvZiBjb25maWcuY3VzdG9tQ29udGVudFR5cGVzKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGZyb250bWF0dGVyIHByb3BlcnRpZXMgdG8gY2hlY2sgZHJhZnQgc3RhdHVzXG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IHRoaXMuY29udGVudFR5cGVzPy5maW5kKGN0ID0+IGN0LmlkID09PSBuZXdUeXBlLmlkKTtcblx0XHRcdGNvbnN0IHByb3BzID0gY29udGVudFR5cGUgJiYgdGhpcy5mcm9udG1hdHRlclByb3BlcnRpZXMgPyB0aGlzLmZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF0gOiB1bmRlZmluZWQ7XG5cdFx0XHRcblx0XHRcdC8vIERldGVybWluZSBpZiB1bmRlcnNjb3JlIHByZWZpeCBzaG91bGQgYmUgZW5hYmxlZFxuXHRcdFx0Ly8gRW5hYmxlIGlmIGhhc0RyYWZ0U3RhdHVzIGlzIHRydWUgYnV0IGRyYWZ0UHJvcGVydHkgaXMgYmxhbmsvdW5kZWZpbmVkXG5cdFx0XHRjb25zdCBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4ID0gcHJvcHM/Lmhhc0RyYWZ0U3RhdHVzID09PSB0cnVlICYmICFwcm9wcz8uZHJhZnRQcm9wZXJ0eTtcblx0XHRcdFxuXHRcdFx0Ly8gRmluZCBleGlzdGluZyBlbnRyeSBieSBuYW1lIEFORCBmb2xkZXIgKG5vdCBqdXN0IGlkLCBzaW5jZSBpZHMgbWlnaHQgZGlmZmVyKVxuXHRcdFx0Y29uc3QgY29udGVudFR5cGVzID0gKGV4aXN0aW5nRGF0YS5jb250ZW50VHlwZXMgYXMgQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KSB8fCBbXTtcblx0XHRcdGNvbnN0IGV4aXN0aW5nSW5kZXggPSBjb250ZW50VHlwZXMuZmluZEluZGV4KChjdDogeyBuYW1lPzogc3RyaW5nOyBmb2xkZXI/OiBzdHJpbmcgfSkgPT4gXG5cdFx0XHRcdGN0Lm5hbWUgPT09IG5ld1R5cGUubmFtZSAmJiBjdC5mb2xkZXIgPT09IG5ld1R5cGUuZm9sZGVyXG5cdFx0XHQpO1xuXHRcdFx0aWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuXHRcdFx0XHQvLyBVcGRhdGUgZXhpc3RpbmcgZW50cnkgLSBwcmVzZXJ2ZSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBleGlzdGluZyBpZFxuXHRcdFx0XHRjb25zdCBleGlzdGluZ0VudHJ5ID0gY29udGVudFR5cGVzW2V4aXN0aW5nSW5kZXhdO1xuXHRcdFx0XHRjb250ZW50VHlwZXNbZXhpc3RpbmdJbmRleF0gPSB7XG5cdFx0XHRcdFx0Li4uZXhpc3RpbmdFbnRyeSxcblx0XHRcdFx0XHRuYW1lOiBuZXdUeXBlLm5hbWUsXG5cdFx0XHRcdFx0Zm9sZGVyOiBuZXdUeXBlLmZvbGRlcixcblx0XHRcdFx0XHRsaW5rQmFzZVBhdGg6IG5ld1R5cGUubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRcdHRlbXBsYXRlOiBuZXdUeXBlLnRlbXBsYXRlLFxuXHRcdFx0XHRcdGVuYWJsZWQ6IG5ld1R5cGUuZW5hYmxlZCxcblx0XHRcdFx0XHRjcmVhdGlvbk1vZGU6IG5ld1R5cGUuY3JlYXRpb25Nb2RlLFxuXHRcdFx0XHRcdGluZGV4RmlsZU5hbWU6IG5ld1R5cGUuaW5kZXhGaWxlTmFtZSxcblx0XHRcdFx0XHRlbmFibGVVbmRlcnNjb3JlUHJlZml4OiBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBBZGQgbmV3IGVudHJ5XG5cdFx0XHRcdGNvbnRlbnRUeXBlcy5wdXNoKHtcblx0XHRcdFx0XHRpZDogbmV3VHlwZS5pZCxcblx0XHRcdFx0XHRuYW1lOiBuZXdUeXBlLm5hbWUsXG5cdFx0XHRcdFx0Zm9sZGVyOiBuZXdUeXBlLmZvbGRlcixcblx0XHRcdFx0XHRsaW5rQmFzZVBhdGg6IG5ld1R5cGUubGlua0Jhc2VQYXRoLFxuXHRcdFx0XHRcdHRlbXBsYXRlOiBuZXdUeXBlLnRlbXBsYXRlLFxuXHRcdFx0XHRcdGVuYWJsZWQ6IG5ld1R5cGUuZW5hYmxlZCxcblx0XHRcdFx0XHRjcmVhdGlvbk1vZGU6IG5ld1R5cGUuY3JlYXRpb25Nb2RlLFxuXHRcdFx0XHRcdGluZGV4RmlsZU5hbWU6IG5ld1R5cGUuaW5kZXhGaWxlTmFtZSxcblx0XHRcdFx0XHRpZ25vcmVTdWJmb2xkZXJzOiBmYWxzZSxcblx0XHRcdFx0XHRlbmFibGVVbmRlcnNjb3JlUHJlZml4OiBzaG91bGRFbmFibGVVbmRlcnNjb3JlUHJlZml4XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBBbHNvIHVwZGF0ZSBsZWdhY3kgY3VzdG9tQ29udGVudFR5cGVzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdGV4aXN0aW5nRGF0YS5jdXN0b21Db250ZW50VHlwZXMgPSB0aGlzLm1lcmdlQ3VzdG9tQ29udGVudFR5cGVzKFxuXHRcdFx0KGV4aXN0aW5nRGF0YS5jdXN0b21Db250ZW50VHlwZXMgYXMgQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KSB8fCBbXSxcblx0XHRcdChjb25maWcuY3VzdG9tQ29udGVudFR5cGVzIGFzIHVua25vd24gYXMgQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KSB8fCBbXVxuXHRcdCk7XG5cdFx0XG5cdFx0Ly8gVHJ5IHRvIG1vZGlmeSBmaXJzdCwgaWYgZmlsZSBkb2Vzbid0IGV4aXN0IGl0IHdpbGwgdGhyb3csIHRoZW4gY3JlYXRlXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEVuc3VyZSBwbHVnaW4gZGlyZWN0b3J5IGV4aXN0c1xuXHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcblx0XHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcblx0XHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmlsZVxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEsIG51bGwsIDIpKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG1lcmdlQ3VzdG9tQ29udGVudFR5cGVzKGV4aXN0aW5nOiBBcnJheTx7IGlkPzogc3RyaW5nOyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0+LCBuZXdUeXBlczogQXJyYXk8eyBpZD86IHN0cmluZzsgW2tleTogc3RyaW5nXTogdW5rbm93biB9Pik6IEFycmF5PHsgaWQ/OiBzdHJpbmc7IFtrZXk6IHN0cmluZ106IHVua25vd24gfT4ge1xuXHRcdGNvbnN0IG1lcmdlZCA9IFsuLi5leGlzdGluZ107XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBuZXdUeXBlIG9mIG5ld1R5cGVzKSB7XG5cdFx0XHRjb25zdCBleGlzdGluZ0luZGV4ID0gbWVyZ2VkLmZpbmRJbmRleChjdCA9PiBjdC5pZCA9PT0gbmV3VHlwZS5pZCk7XG5cdFx0XHRpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSBleGlzdGluZ1xuXHRcdFx0XHRtZXJnZWRbZXhpc3RpbmdJbmRleF0gPSB7IC4uLm1lcmdlZFtleGlzdGluZ0luZGV4XSwgLi4ubmV3VHlwZSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQWRkIG5ld1xuXHRcdFx0XHRtZXJnZWQucHVzaChuZXdUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG1lcmdlZDtcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzXHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCB7IFByb2plY3REZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG4vKipcclxuICogVXRpbGl0eSBjbGFzcyB0byByZXNvbHZlIGNvbnRlbnQgdHlwZSBmb2xkZXIgcGF0aHMgcmVsYXRpdmUgdG8gdmF1bHQgcm9vdFxyXG4gKiBhbmQgcHJvamVjdCByb290LCBhY2NvdW50aW5nIGZvciBkaWZmZXJlbnQgdmF1bHQgbG9jYXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFBhdGhSZXNvbHZlciB7XHJcblx0cHJpdmF0ZSBhcHA6IEFwcDtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBwOiBBcHApIHtcclxuXHRcdHRoaXMuYXBwID0gYXBwO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBmb2xkZXIgcGF0aCBmcm9tIHZhdWx0IHJvb3QgdG8gdGhlIGNvbnRlbnQgdHlwZSBmb2xkZXIuXHJcblx0ICogVGhpcyBpcyB1c2VkIGJ5IEJhc2VzIENNUyBmaWx0ZXJzIGFuZCBBc3RybyBDb21wb3NlciBmb2xkZXIgc2V0dGluZ3MuXHJcblx0ICogXHJcblx0ICogRXhhbXBsZXM6XHJcblx0ICogLSBWYXVsdCBhdCBzcmMgbGV2ZWwsIGNvbnRlbnQgdHlwZSBcImRvY3NcIjogcmV0dXJucyBcImNvbnRlbnQvZG9jc1wiXHJcblx0ICogLSBWYXVsdCBhdCBzcmMvY29udGVudCBsZXZlbCwgY29udGVudCB0eXBlIFwiZG9jc1wiOiByZXR1cm5zIFwiZG9jc1wiXHJcblx0ICogLSBWYXVsdCBhdCBzcmMvY29udGVudC9wb3N0IGxldmVsLCBjb250ZW50IHR5cGUgXCJkb2NzXCI6IHJldHVybnMgXCIuLi9kb2NzXCIgKGlmIGFjY2Vzc2libGUpIG9yIFwiZG9jc1wiIChpZiB2YXVsdCBpcyB0aGUgY29udGVudCB0eXBlIGZvbGRlcilcclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZm9sZGVyTmFtZSBUaGUgY29udGVudCB0eXBlIGZvbGRlciBuYW1lIChlLmcuLCBcImRvY3NcIiwgXCJwb3N0c1wiKVxyXG5cdCAqIEBwYXJhbSBwcm9qZWN0RGV0ZWN0aW9uIFByb2plY3QgZGV0ZWN0aW9uIHJlc3VsdCB3aXRoIHByb2plY3Qgcm9vdCBhbmQgdmF1bHQgbG9jYXRpb25cclxuXHQgKiBAcmV0dXJucyBQYXRoIGZyb20gdmF1bHQgcm9vdCB0byBjb250ZW50IHR5cGUgZm9sZGVyLCBvciBudWxsIGlmIGNhbm5vdCBiZSBkZXRlcm1pbmVkXHJcblx0ICovXHJcblx0Z2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoZm9sZGVyTmFtZTogc3RyaW5nLCBwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyB7IGJhc2VQYXRoPzogc3RyaW5nOyBwYXRoPzogc3RyaW5nIH07XHJcblx0XHRjb25zdCB2YXVsdFBhdGggPSBhZGFwdGVyLmJhc2VQYXRoIHx8IGFkYXB0ZXIucGF0aDtcclxuXHJcblx0XHQvLyAxLiBDaGVjayBpZiBmb2xkZXJOYW1lIGlzIGFscmVhZHkgYSB2YWxpZCBwYXRoIGluIHRoZSB2YXVsdC5cclxuXHRcdC8vIFRoaXMgaGFuZGxlcyBjYXNlcyB3aGVyZSBmb2xkZXJOYW1lIGlzIGFscmVhZHkgYSB2YXVsdC1yZWxhdGl2ZSBwYXRoIChlLmcuLCBcInNyYy9jb250ZW50L3Bvc3RzXCJcclxuXHRcdC8vIG9yIGEgbWFudWFsbHkgc2VsZWN0ZWQgZm9sZGVyIGxpa2UgXCJibG9nLXBvc3RzXCIpIGFuZCBwcm9qZWN0IGRldGVjdGlvbiBtaWdodCBub3QgYmUgbmVlZGVkLlxyXG5cdFx0Ly8gV2UgcHJpb3JpdGl6ZSB0aGlzIGZvciBtYW51YWxseSBhZGRlZCBmb2xkZXJzIHRoYXQgYXJlIGFscmVhZHkgY29ycmVjdGx5IHJlc29sdmVkLlxyXG5cdFx0Y29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmb2xkZXJOYW1lKTtcclxuXHRcdGlmIChmaWxlKSB7XHJcblx0XHRcdHJldHVybiBmb2xkZXJOYW1lO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIDIuIElmIHByb2plY3QgZGV0ZWN0aW9uIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIGNhbGN1bGF0ZSB0aGUgZXhhY3QgaW50ZW5kZWQgcGF0aFxyXG5cdFx0Ly8gVGhpcyBpcyBwcmVmZXJyZWQgZm9yIGF1dG8tZGV0ZWN0ZWQgZm9sZGVycyBiZWNhdXNlIGl0IGhhbmRsZXMgdGhlIFwidmF1bHQgYXQgcHJvamVjdCByb290XCIgY2FzZSBjb3JyZWN0bHlcclxuXHRcdC8vIGV2ZW4gaWYgdGhlcmUgYXJlIGZvbGRlcnMgd2l0aCBtYXRjaGluZyBuYW1lcyBlbHNld2hlcmUgaW4gdGhlIHZhdWx0LlxyXG5cdFx0aWYgKHByb2plY3REZXRlY3Rpb24gJiYgcHJvamVjdERldGVjdGlvbi5wcm9qZWN0Um9vdCAmJiB2YXVsdFBhdGgpIHtcclxuXHRcdFx0Ly8gUmVzb2x2ZSBwcm9qZWN0IHJvb3QgdG8gYWJzb2x1dGUgcGF0aFxyXG5cdFx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHBhdGguaXNBYnNvbHV0ZShwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KSBcclxuXHRcdFx0XHQ/IHByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QgXHJcblx0XHRcdFx0OiBwYXRoLnJlc29sdmUodmF1bHRQYXRoLCBwcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KTtcclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgcGF0aCB0byB0aGUgaW50ZW5kZWQgY29udGVudCB0eXBlIGZvbGRlclxyXG5cdFx0XHQvLyBJZiBmb2xkZXJOYW1lIGFscmVhZHkgbG9va3MgbGlrZSBhIHBhdGggZnJvbSBwcm9qZWN0IHJvb3QgKGUuZy4gc3RhcnRzIHdpdGggc3JjL2NvbnRlbnQpLCB1c2UgaXQgYXMtaXNcclxuXHRcdFx0bGV0IGNvbnRlbnRUeXBlQWJzb2x1dGVQYXRoOiBzdHJpbmc7XHJcblx0XHRcdGlmIChmb2xkZXJOYW1lLnN0YXJ0c1dpdGgoJ3NyYy9jb250ZW50LycpIHx8IGZvbGRlck5hbWUuaW5jbHVkZXMoJy9zcmMvY29udGVudC8nKSkge1xyXG5cdFx0XHRcdGNvbnRlbnRUeXBlQWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKHByb2plY3RSb290LCBmb2xkZXJOYW1lKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb250ZW50VHlwZUFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZShwcm9qZWN0Um9vdCwgJ3NyYycsICdjb250ZW50JywgZm9sZGVyTmFtZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIENhbGN1bGF0ZSByZWxhdGl2ZSBwYXRoIGZyb20gdmF1bHQgdG8gY29udGVudCB0eXBlIGZvbGRlclxyXG5cdFx0XHRjb25zdCB2YXVsdEFic29sdXRlUGF0aCA9IHBhdGgucmVzb2x2ZSh2YXVsdFBhdGgpO1xyXG5cdFx0XHRjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHZhdWx0QWJzb2x1dGVQYXRoLCBjb250ZW50VHlwZUFic29sdXRlUGF0aCk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJZiByZWxhdGl2ZVBhdGggaXMgd2l0aGluIHRoZSB2YXVsdCAoZG9lc24ndCBzdGFydCB3aXRoICcuLicpLCB1c2UgaXRcclxuXHRcdFx0aWYgKCFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSAmJiAhcGF0aC5pc0Fic29sdXRlKHJlbGF0aXZlUGF0aCkpIHtcclxuXHRcdFx0XHQvLyBOb3JtYWxpemUgdG8gdXNlIGZvcndhcmQgc2xhc2hlcyAod29ya3Mgb24gV2luZG93cyB0b28pXHJcblx0XHRcdFx0cmV0dXJuIHJlbGF0aXZlUGF0aC5zcGxpdChwYXRoLnNlcCkuam9pbignLycpIHx8ICcuJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIDMuIExhc3QgcmVzb3J0IGZhbGxiYWNrOiByZXR1cm4gZm9sZGVyIG5hbWUgYXMtaXNcclxuXHRcdHJldHVybiBmb2xkZXJOYW1lO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBmb2xkZXIgcGF0aCBmcm9tIHByb2plY3Qgcm9vdCB0byB0aGUgY29udGVudCB0eXBlIGZvbGRlci5cclxuXHQgKiBUaGlzIGlzIGFsd2F5cyBcInNyYy9jb250ZW50L3tmb2xkZXJOYW1lfVwiIHJlbGF0aXZlIHRvIHByb2plY3Qgcm9vdC5cclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZm9sZGVyTmFtZSBUaGUgY29udGVudCB0eXBlIGZvbGRlciBuYW1lIChlLmcuLCBcImRvY3NcIiwgXCJwb3N0c1wiKVxyXG5cdCAqIEByZXR1cm5zIFBhdGggZnJvbSBwcm9qZWN0IHJvb3QgKGUuZy4sIFwic3JjL2NvbnRlbnQvZG9jc1wiKVxyXG5cdCAqL1xyXG5cdGdldEZvbGRlclBhdGhGcm9tUHJvamVjdFJvb3QoZm9sZGVyTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgc3JjL2NvbnRlbnQvJHtmb2xkZXJOYW1lfWA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGZvbGRlciBwYXRoIGZvciBBc3RybyBDb21wb3Nlciwgd2hpY2ggbmVlZHMgdGhlIHBhdGggcmVsYXRpdmUgdG8gdmF1bHQgcm9vdFxyXG5cdCAqIGJ1dCBzaG91bGQgd29yayBjb3JyZWN0bHkgcmVnYXJkbGVzcyBvZiB2YXVsdCBsb2NhdGlvbi5cclxuXHQgKiBcclxuXHQgKiBAcGFyYW0gZm9sZGVyTmFtZSBUaGUgY29udGVudCB0eXBlIGZvbGRlciBuYW1lXHJcblx0ICogQHBhcmFtIHByb2plY3REZXRlY3Rpb24gUHJvamVjdCBkZXRlY3Rpb24gcmVzdWx0XHJcblx0ICogQHJldHVybnMgUGF0aCBmcm9tIHZhdWx0IHJvb3QgdG8gY29udGVudCB0eXBlIGZvbGRlclxyXG5cdCAqL1xyXG5cdGdldEFzdHJvQ29tcG9zZXJGb2xkZXJQYXRoKGZvbGRlck5hbWU6IHN0cmluZywgcHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoZm9sZGVyTmFtZSwgcHJvamVjdERldGVjdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGZvbGRlciBwYXRoIGZvciBCYXNlcyBDTVMgZmlsdGVyLCB3aGljaCBuZWVkcyB0byBtYXRjaCBmaWxlc1xyXG5cdCAqIGluIHRoZSBjb250ZW50IHR5cGUgZm9sZGVyIHJlZ2FyZGxlc3Mgb2YgdmF1bHQgbG9jYXRpb24uXHJcblx0ICogXHJcblx0ICogQHBhcmFtIGZvbGRlck5hbWUgVGhlIGNvbnRlbnQgdHlwZSBmb2xkZXIgbmFtZVxyXG5cdCAqIEBwYXJhbSBwcm9qZWN0RGV0ZWN0aW9uIFByb2plY3QgZGV0ZWN0aW9uIHJlc3VsdFxyXG5cdCAqIEByZXR1cm5zIFBhdGggZnJvbSB2YXVsdCByb290IHRvIGNvbnRlbnQgdHlwZSBmb2xkZXIgKGZvciB1c2UgaW4gZmlsZS5mb2xkZXIuc3RhcnRzV2l0aCBmaWx0ZXIpXHJcblx0ICovXHJcblx0Z2V0QmFzZXNDTVNGb2xkZXJQYXRoKGZvbGRlck5hbWU6IHN0cmluZywgcHJvamVjdERldGVjdGlvbj86IFByb2plY3REZXRlY3Rpb25SZXN1bHQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoZm9sZGVyTmFtZSwgcHJvamVjdERldGVjdGlvbik7XHJcblx0fVxyXG59XHJcblxyXG4iLCAiaW1wb3J0IHsgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcclxuXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q29udGVudFR5cGVTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xyXG5cdGRpc3BsYXkoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdEZWZhdWx0IGNvbnRlbnQgdHlwZScgfSk7XHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdHRleHQ6ICdTZWxlY3Qgd2hpY2ggY29udGVudCB0eXBlIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkZWZhdWx0LiBUaGlzIHdpbGw6JyBcclxuXHRcdH0pO1xyXG5cdFx0Y29uc3QgdWwgPSBjb250YWluZXJFbC5jcmVhdGVFbCgndWwnKTtcclxuXHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIkJhc2VzIENNU1wiIGlzIGEgcHJvcGVyIG5vdW4gKHByb2R1Y3QgbmFtZSkgYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxyXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0dWwuY3JlYXRlRWwoJ2xpJywgeyB0ZXh0OiAnU2V0IGFzIHRoZSBkZWZhdWx0IEJhc2VzIENNUyB2aWV3JyB9KTtcclxuXHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIk9ic2lkaWFuXCIgaXMgYSBwcm9wZXIgbm91biAocHJvZHVjdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHR1bC5jcmVhdGVFbCgnbGknLCB7IHRleHQ6ICdDb25maWd1cmUgT2JzaWRpYW5cXCdzIFwiRGVmYXVsdCBsb2NhdGlvbiBmb3IgbmV3IG5vdGVzXCIgdG8gdGhhdCBmb2xkZXIuJyB9KTtcclxuXHJcblx0XHRjb25zdCBlbmFibGVkVHlwZXMgPSB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZCk7XHJcblx0XHRcclxuXHRcdGlmIChlbmFibGVkVHlwZXMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0XHR0ZXh0OiAnTm8gZW5hYmxlZCBjb250ZW50IHR5cGVzIGZvdW5kLiBQbGVhc2UgZ28gYmFjayBhbmQgZW5hYmxlIGF0IGxlYXN0IG9uZSBjb250ZW50IHR5cGUuJyBcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBbHdheXMgZW5zdXJlIGRlZmF1bHRDb250ZW50VHlwZUlkIGlzIHNldCB0byBmaXJzdCBlbmFibGVkIHR5cGVcclxuXHRcdGlmICghdGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCB8fCBlbmFibGVkVHlwZXMuZmluZEluZGV4KGN0ID0+IGN0LmlkID09PSB0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkKSA9PT0gLTEpIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCA9IGVuYWJsZWRUeXBlc1swXS5pZDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzZWxlY3RlZFZhbHVlID0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZDtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoJ0RlZmF1bHQgY29udGVudCB0eXBlJylcclxuXHRcdFx0LnNldERlc2MoJ0Nob29zZSB0aGUgZGVmYXVsdCBjb250ZW50IHR5cGUgZm9yIG5ldyBub3RlcycpXHJcblx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiB7XHJcblx0XHRcdFx0ZW5hYmxlZFR5cGVzLmZvckVhY2goY3QgPT4ge1xyXG5cdFx0XHRcdFx0ZHJvcGRvd24uYWRkT3B0aW9uKGN0LmlkLCBjdC5uYW1lKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHQvLyBTZXQgdGhlIHZhbHVlIGV4cGxpY2l0bHkgdG8gZW5zdXJlIGl0J3MgcHJlLXBvcHVsYXRlZFxyXG5cdFx0XHRcdGRyb3Bkb3duLnNldFZhbHVlKHNlbGVjdGVkVmFsdWUpO1xyXG5cdFx0XHRcdGRyb3Bkb3duLm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQgPSB2YWx1ZTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG5cclxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAhIXRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQ7XHJcblx0fVxyXG5cclxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdEZWZhdWx0IGNvbnRlbnQgdHlwZSc7XHJcblx0fVxyXG5cclxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdTZWxlY3QgZGVmYXVsdCBjb250ZW50IHR5cGUnO1xyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IEFwcCwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBzZXRDc3NQcm9wcyAobWF5IG5vdCBiZSBpbiB0eXBlcyB5ZXQpXG5mdW5jdGlvbiBzZXRDc3NQcm9wcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHJvcHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkIHtcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG5cdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXkucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuXHR9XG59XG5pbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUsIEV4YW1wbGVGcm9udG1hdHRlciB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IEZyb250bWF0dGVyQW5hbHl6ZXIgfSBmcm9tICcuLi8uLi91dGlscy9Gcm9udG1hdHRlckFuYWx5emVyJztcbmltcG9ydCB7IFBhdGhSZXNvbHZlciB9IGZyb20gJy4uLy4uL3V0aWxzL1BhdGhSZXNvbHZlcic7XG5cbmV4cG9ydCBjbGFzcyBGcm9udG1hdHRlclByb3BlcnRpZXNTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRwcml2YXRlIGZyb250bWF0dGVyQW5hbHl6ZXI6IEZyb250bWF0dGVyQW5hbHl6ZXI7XG5cdHByaXZhdGUgZXhhbXBsZXM6IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEV4YW1wbGVGcm9udG1hdHRlciB8IHVuZGVmaW5lZCB9ID0ge307XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHAsIGNvbnRhaW5lckVsLCBzdGF0ZSwgb25OZXh0LCBvbkJhY2ssIG9uQ2FuY2VsKTtcblx0XHR0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIgPSBuZXcgRnJvbnRtYXR0ZXJBbmFseXplcihhcHApO1xuXHR9XG5cblx0YXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdFxuXHRcdC8vIENsZWFyIG9ubHkgdGhlIHN0ZXAgY29udGVudCwgcHJlc2VydmUgbmF2aWdhdGlvbiBmb290ZXJcblx0XHRjb25zdCBleGlzdGluZ1dyYXBwZXIgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKCcuZnJvbnRtYXR0ZXItc3RlcC1jb250ZW50Jyk7XG5cdFx0aWYgKGV4aXN0aW5nV3JhcHBlcikge1xuXHRcdFx0ZXhpc3RpbmdXcmFwcGVyLnJlbW92ZSgpO1xuXHRcdH1cblx0XHRcblx0XHRjb25zdCBzdGVwQ29udGVudFdyYXBwZXIgPSBjb250YWluZXJFbC5jcmVhdGVEaXYoeyBjbHM6ICdmcm9udG1hdHRlci1zdGVwLWNvbnRlbnQnIH0pO1xuXG5cdFx0c3RlcENvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ0Zyb250bWF0dGVyIHByb3BlcnRpZXMnIH0pO1xuXHRcdHN0ZXBDb250ZW50V3JhcHBlci5jcmVhdGVFbCgncCcsIHsgXG5cdFx0XHR0ZXh0OiAnTWFwIGZyb250bWF0dGVyIHByb3BlcnRpZXMgZm9yIGVhY2ggY29udGVudCB0eXBlLiBXZVxcJ2xsIGZpbmQgZXhhbXBsZSBmaWxlcyB0byBoZWxwIHlvdS4nIFxuXHRcdH0pO1xuXG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcykge1xuXHRcdFx0aWYgKCFjb250ZW50VHlwZS5lbmFibGVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgYSB3cmFwcGVyIGZvciB0aGlzIGNvbnRlbnQgdHlwZSdzIHNldHRpbmdzXG5cdFx0XHRjb25zdCBjb250ZW50VHlwZVdyYXBwZXIgPSBzdGVwQ29udGVudFdyYXBwZXIuY3JlYXRlRGl2KHsgY2xzOiAnY29udGVudC10eXBlLXNldHRpbmdzJyB9KTtcblxuXHRcdFx0Ly8gRmluZCBleGFtcGxlIGZpbGVcblx0XHRcdGlmICghdGhpcy5leGFtcGxlc1tjb250ZW50VHlwZS5pZF0pIHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBjb3JyZWN0IGZvbGRlciBwYXRoIGZyb20gdmF1bHQgcm9vdCB1c2luZyBQYXRoUmVzb2x2ZXJcblx0XHRcdFx0Y29uc3QgcGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcih0aGlzLmFwcCk7XG5cdFx0XHRcdGNvbnN0IGZvbGRlclBhdGggPSBwYXRoUmVzb2x2ZXIuZ2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoY29udGVudFR5cGUuZm9sZGVyLCB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0XHRjb25zdCBleGFtcGxlID0gYXdhaXQgdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmZpbmRFeGFtcGxlRmlsZShmb2xkZXJQYXRoKTtcblx0XHRcdFx0aWYgKGV4YW1wbGUpIHtcblx0XHRcdFx0XHR0aGlzLmV4YW1wbGVzW2NvbnRlbnRUeXBlLmlkXSA9IGV4YW1wbGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZXhhbXBsZSA9IHRoaXMuZXhhbXBsZXNbY29udGVudFR5cGUuaWRdO1xuXHRcdFx0XG5cdFx0XHRjb250ZW50VHlwZVdyYXBwZXIuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiBjb250ZW50VHlwZS5uYW1lIH0pO1xuXG5cdFx0XHRpZiAoZXhhbXBsZSkge1xuXHRcdFx0XHRjb250ZW50VHlwZVdyYXBwZXIuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBFeGFtcGxlIGZpbGU6ICR7ZXhhbXBsZS5maWxlfWAgfSk7XG5cdFx0XHRcdGNvbnN0IHByZUVsID0gY29udGVudFR5cGVXcmFwcGVyLmNyZWF0ZUVsKCdwcmUnLCB7IFxuXHRcdFx0XHRcdHRleHQ6IGV4YW1wbGUucmF3WWFtbCxcblx0XHRcdFx0XHRjbHM6ICdmcm9udG1hdHRlci1leGFtcGxlJ1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Ly8gU3R5bGUgdGhlIHByZSBlbGVtZW50IGZvciBiZXR0ZXIgZGlzcGxheVxuXHRcdFx0XHRzZXRDc3NQcm9wcyhwcmVFbCwge1xuXHRcdFx0XHRcdGZvbnRGYW1pbHk6ICd2YXIoLS1mb250LW1vbm9zcGFjZSknLFxuXHRcdFx0XHRcdGZvbnRTaXplOiAnMC44NWVtJyxcblx0XHRcdFx0XHR3aGl0ZVNwYWNlOiAncHJlLXdyYXAnLFxuXHRcdFx0XHRcdG92ZXJmbG93V3JhcDogJ2JyZWFrLXdvcmQnLFxuXHRcdFx0XHRcdG1heFdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0cGFkZGluZzogJzEwcHgnLFxuXHRcdFx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3ZhcigtLWJhY2tncm91bmQtc2Vjb25kYXJ5KScsXG5cdFx0XHRcdFx0Ym9yZGVyUmFkaXVzOiAnNHB4Jyxcblx0XHRcdFx0XHRib3JkZXI6ICcxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBwcm9wZXJ0aWVzIGlmIG5vdCBleGlzdHNcblx0XHRcdGlmICghdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdKSB7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGVkRHJhZnQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REcmFmdFByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWRUYWdzID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWRJbWFnZSA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdEltYWdlUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRjb25zdCBkZXRlY3RlZERlc2MgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3REZXNjcmlwdGlvblByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWRUaXRsZSA9IGV4YW1wbGUgPyAoZXhhbXBsZS5mcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eSgndGl0bGUnKSA/ICd0aXRsZScgOiBudWxsKSA6IG51bGw7XG5cdFx0XHRcdGNvbnN0IGRldGVjdGVkRGF0ZSA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERhdGVQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBDaGVjayBmb3IgdW5kZXJzY29yZS1wcmVmaXhlZCBmaWxlc1xuXHRcdFx0XHRjb25zdCBwYXRoUmVzb2x2ZXIgPSBuZXcgUGF0aFJlc29sdmVyKHRoaXMuYXBwKTtcblx0XHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IHBhdGhSZXNvbHZlci5nZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChjb250ZW50VHlwZS5mb2xkZXIsIHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbik7XG5cdFx0XHRcdGNvbnN0IGhhc1VuZGVyc2NvcmVGaWxlcyA9IGF3YWl0IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5oYXNVbmRlcnNjb3JlRmlsZXMoZm9sZGVyUGF0aCk7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllc1tjb250ZW50VHlwZS5pZF0gPSB7XG5cdFx0XHRcdFx0dGl0bGVQcm9wZXJ0eTogZGV0ZWN0ZWRUaXRsZSB8fCB1bmRlZmluZWQsIC8vIE9ubHkgc2V0IGlmIGRldGVjdGVkLCBvdGhlcndpc2UgYmxhbmtcblx0XHRcdFx0XHRkYXRlUHJvcGVydHk6IGRldGVjdGVkRGF0ZSB8fCB1bmRlZmluZWQsIC8vIE9ubHkgc2V0IGlmIGRldGVjdGVkLCBvdGhlcndpc2UgYmxhbmtcblx0XHRcdFx0XHRkZXNjcmlwdGlvblByb3BlcnR5OiBkZXRlY3RlZERlc2MgfHwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHRhZ3NQcm9wZXJ0eTogZGV0ZWN0ZWRUYWdzIHx8IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRkcmFmdFByb3BlcnR5OiBkZXRlY3RlZERyYWZ0Py5wcm9wZXJ0eSxcblx0XHRcdFx0XHRkcmFmdExvZ2ljOiBkZXRlY3RlZERyYWZ0Py5wcm9wZXJ0eSA9PT0gJ3B1Ymxpc2hlZCcgPyAnZmFsc2UtZHJhZnQnIDogKGRldGVjdGVkRHJhZnQgPyAndHJ1ZS1kcmFmdCcgOiB1bmRlZmluZWQpLFxuXHRcdFx0XHRcdGhhc0RyYWZ0U3RhdHVzOiAhIWRldGVjdGVkRHJhZnQ/LnByb3BlcnR5IHx8IGhhc1VuZGVyc2NvcmVGaWxlcywgLy8gVHJhY2sgaWYgZHJhZnQgc3RhdHVzIGlzIGVuYWJsZWRcblx0XHRcdFx0XHRpbWFnZVByb3BlcnR5OiBkZXRlY3RlZEltYWdlIHx8IHVuZGVmaW5lZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwcm9wcyA9IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnVGl0bGUgcHJvcGVydHknKVxuXHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIHRpdGxlIChlLmcuLCB0aXRsZSwgbmFtZSwgaGVhZGluZykuIExlYXZlIGJsYW5rIHRvIHVzZSBmdWxsIGZpbGUgbmFtZSBpbnN0ZWFkLicpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gJ3RpdGxlJztcblx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkKVxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLnRpdGxlUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy50aXRsZVByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0bmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnRGF0ZSBwcm9wZXJ0eScpXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2Vcblx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBkYXRlIChlLmcuLCBkYXRlLCBwdWJEYXRlLCBwdWJsaXNoZWREYXRlLCBwdWJsaXNoRGF0ZSkuIExlYXZlIGJsYW5rIHRvIHVzZSBmaWxlIGNyZWF0ZWQgZGF0ZSBpbnN0ZWFkLicpXG5cdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RGF0ZVByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkIHx8ICdkYXRlJylcblx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kYXRlUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy5kYXRlUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBkZXNjU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0hhcyBkZXNjcmlwdGlvbi9zdW1tYXJ5PycpXG5cdFx0XHRcdC5zZXREZXNjKCdEb2VzIHRoaXMgY29udGVudCB0eXBlIGhhdmUgYSBkZXNjcmlwdGlvbiBvciBzdW1tYXJ5IGZpZWxkPycpO1xuXHRcdFx0XG5cdFx0XHRsZXQgZGVzY1RleHRTZXR0aW5nOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGRlc2NTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSghIXByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmICFwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5ID0gZXhhbXBsZSA/IFxuXHRcdFx0XHRcdFx0XHR0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERlc2NyaXB0aW9uUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgfHwgJ2Rlc2NyaXB0aW9uJyA6IFxuXHRcdFx0XHRcdFx0XHQnZGVzY3JpcHRpb24nO1xuXHRcdFx0XHRcdFx0Ly8gU2hvdyB0ZXh0IGZpZWxkXG5cdFx0XHRcdFx0XHRpZiAoIWRlc2NUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkZXNjVGV4dFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0Rlc2NyaXB0aW9uIHByb3BlcnR5Jylcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIChlLmcuLCBkZXNjcmlwdGlvbiwgc3VtbWFyeSwgZXhjZXJwdCwgaW50cm8sIHNuaXBwZXQsIGJsdXJiKScpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdGRlc2NUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGRlc2NTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZGVzY1RleHRTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUpIHtcblx0XHRcdFx0XHRcdHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHQvLyBIaWRlIHRleHQgZmllbGRcblx0XHRcdFx0XHRcdGlmIChkZXNjVGV4dFNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0aWYgKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHtcblx0XHRcdFx0ZGVzY1RleHRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdC5zZXROYW1lKCdEZXNjcmlwdGlvbiBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiAoZS5nLiwgZGVzY3JpcHRpb24sIHN1bW1hcnksIGV4Y2VycHQsIGludHJvLCBzbmlwcGV0LCBibHVyYiknKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSB0b2dnbGUgc2V0dGluZ1xuXHRcdFx0XHRkZXNjVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRkZXNjU2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRlc2NUZXh0U2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYXMgVGFncz9cblx0XHRcdGNvbnN0IHRhZ3NTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHQuc2V0TmFtZSgnSGFzIHRhZ3M/Jylcblx0XHRcdFx0LnNldERlc2MoJ0RvZXMgdGhpcyBjb250ZW50IHR5cGUgaGF2ZSB0YWdzPycpO1xuXHRcdFx0XG5cdFx0XHRsZXQgdGFnc1RleHRTZXR0aW5nOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdHRhZ3NTZXR0aW5nLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG5cdFx0XHRcdC5zZXRWYWx1ZSghIXByb3BzLnRhZ3NQcm9wZXJ0eSlcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgIXByb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RUYWdzUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0cHJvcHMudGFnc1Byb3BlcnR5ID0gZGV0ZWN0ZWQgfHwgJ3RhZ3MnO1xuXHRcdFx0XHRcdFx0Ly8gU2hvdyB0ZXh0IGZpZWxkXG5cdFx0XHRcdFx0XHRpZiAoIXRhZ3NUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHR0YWdzVGV4dFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ1RhZ3MgcHJvcGVydHknKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0YWdzIChlLmcuLCB0YWdzLCB0YWcsIGNhdGVnb3JpZXMsIGNhdGVnb3J5KS4gTGVhdmUgYmxhbmsgaWYgbm90IGFwcGxpY2FibGUuJylcblx0XHRcdFx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdHRleHQuc2V0UGxhY2Vob2xkZXIoZGV0ZWN0ZWQgfHwgJ3RhZ3MnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMudGFnc1Byb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLnRhZ3NQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdHRhZ3NUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdHRhZ3NTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgdGFnc1RleHRTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUpIHtcblx0XHRcdFx0XHRcdHByb3BzLnRhZ3NQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdC8vIEhpZGUgdGV4dCBmaWVsZFxuXHRcdFx0XHRcdFx0aWYgKHRhZ3NUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHR0YWdzVGV4dFNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHR0YWdzVGV4dFNldHRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkpO1xuXG5cdFx0XHRpZiAocHJvcHMudGFnc1Byb3BlcnR5KSB7XG5cdFx0XHRcdHRhZ3NUZXh0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHQuc2V0TmFtZSgnVGFncyBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHRhZ3MgKGUuZy4sIHRhZ3MsIHRhZywgY2F0ZWdvcmllcywgY2F0ZWdvcnkpLiBMZWF2ZSBibGFuayBpZiBub3QgYXBwbGljYWJsZS4nKVxuXHRcdFx0XHRcdC5hZGRUZXh0KHRleHQgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RUYWdzUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihkZXRlY3RlZCB8fCAndGFncycpXG5cdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy50YWdzUHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcHMudGFnc1Byb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgdG9nZ2xlIHNldHRpbmdcblx0XHRcdFx0dGFnc1RleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0dGFnc1NldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCB0YWdzVGV4dFNldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFzIERyYWZ0IFN0YXR1cz9cblx0XHRcdGNvbnN0IGRyYWZ0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0LnNldE5hbWUoJ0hhcyBkcmFmdCBzdGF0dXM/Jylcblx0XHRcdFx0LnNldERlc2MoJ0RvZXMgdGhpcyBjb250ZW50IHR5cGUgaGF2ZSBkcmFmdCBzdGF0dXM/Jyk7XG5cdFx0XHRcblx0XHRcdGxldCBkcmFmdFByb3BlcnR5U2V0dGluZzogU2V0dGluZyB8IG51bGwgPSBudWxsO1xuXHRcdFx0bGV0IGRyYWZ0TG9naWNTZXR0aW5nOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdC8vIEluaXRpYWxpemUgaGFzRHJhZnRTdGF0dXMgaWYgbm90IHNldCAoZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuXHRcdFx0aWYgKHByb3BzLmhhc0RyYWZ0U3RhdHVzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHJvcHMuaGFzRHJhZnRTdGF0dXMgPSAhIXByb3BzLmRyYWZ0UHJvcGVydHk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGRyYWZ0U2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuXHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuaGFzRHJhZnRTdGF0dXMgPz8gISFwcm9wcy5kcmFmdFByb3BlcnR5KVxuXHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdHByb3BzLmhhc0RyYWZ0U3RhdHVzID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmICFwcm9wcy5kcmFmdFByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZERyYWZ0ID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RHJhZnRQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHRwcm9wcy5kcmFmdFByb3BlcnR5ID0gZGV0ZWN0ZWREcmFmdD8ucHJvcGVydHkgfHwgJ2RyYWZ0Jztcblx0XHRcdFx0XHRcdC8vIEZpeCBsb2dpYzogaWYgcHJvcGVydHkgaXMgXCJkcmFmdFwiLCB1c2UgXCJ0cnVlLWRyYWZ0XCIsIGlmIFwicHVibGlzaGVkXCIgdXNlIFwiZmFsc2UtZHJhZnRcIlxuXHRcdFx0XHRcdFx0aWYgKGRldGVjdGVkRHJhZnQ/LnByb3BlcnR5ID09PSAncHVibGlzaGVkJykge1xuXHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gJ2ZhbHNlLWRyYWZ0Jztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSAndHJ1ZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBTaG93IGZpZWxkc1xuXHRcdFx0XHRcdFx0aWYgKCFkcmFmdFByb3BlcnR5U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHRcdFx0XHQuc2V0TmFtZSgnRHJhZnQgcHJvcGVydHknKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyBkcmFmdCBzdGF0dXMuIExlYXZlIGJsYW5rIHRvIHVzZSBhbiB1bmRlcnNjb3JlIHByZWZpeCBpbnN0ZWFkLicpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZCA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdERyYWZ0UHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihkZXRlY3RlZD8ucHJvcGVydHkgfHwgJ2RyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRyYWZ0UHJvcGVydHkgfHwgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRQcm9wZXJ0eSA9IHZhbHVlLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVXBkYXRlIGxvZ2ljIGJhc2VkIG9uIHByb3BlcnR5IG5hbWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPT09ICdwdWJsaXNoZWQnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gJ2ZhbHNlLWRyYWZ0Jztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gJ3RydWUtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTaG93L2hpZGUgbG9naWMgZHJvcGRvd25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgIWRyYWZ0TG9naWNTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0RyYWZ0IGxvZ2ljJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldERlc2MoJ0hvdyBkcmFmdCBzdGF0dXMgaXMgcmVwcmVzZW50ZWQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJ0cnVlID0gZHJhZnRcIiBhbmQgXCJmYWxzZSA9IGRyYWZ0XCIgYXJlIHRlY2huaWNhbCBub3RhdGlvbiwgbm90IFVJIHRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZE9wdGlvbigndHJ1ZS1kcmFmdCcsICd0cnVlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcImZhbHNlID0gZHJhZnRcIiBpcyB0ZWNobmljYWwgbm90YXRpb24sIG5vdCBVSSB0ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ2ZhbHNlLWRyYWZ0JywgJ2ZhbHNlID0gZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kcmFmdExvZ2ljIHx8ICd0cnVlLWRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UoZHJvcGRvd25WYWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdExvZ2ljID0gZHJvcGRvd25WYWx1ZSBhcyAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghdmFsdWUgJiYgZHJhZnRMb2dpY1NldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIHRvZ2dsZSBzZXR0aW5nXG5cdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0ZHJhZnRTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIFNob3cgbG9naWMgZHJvcGRvd24gaWYgcHJvcGVydHkgaXMgc2V0XG5cdFx0XHRcdFx0XHRpZiAocHJvcHMuZHJhZnRQcm9wZXJ0eSAmJiAhZHJhZnRMb2dpY1NldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHRcdFx0LnNldE5hbWUoJ0RyYWZ0IGxvZ2ljJylcblx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnSG93IGRyYWZ0IHN0YXR1cyBpcyByZXByZXNlbnRlZCcpXG5cdFx0XHRcdFx0XHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJ0cnVlID0gZHJhZnRcIiBhbmQgXCJmYWxzZSA9IGRyYWZ0XCIgYXJlIHRlY2huaWNhbCBub3RhdGlvbiwgbm90IFVJIHRleHRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2Vcblx0XHRcdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ3RydWUtZHJhZnQnLCAndHJ1ZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcImZhbHNlID0gZHJhZnRcIiBpcyB0ZWNobmljYWwgbm90YXRpb24sIG5vdCBVSSB0ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXG5cdFx0XHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCdmYWxzZS1kcmFmdCcsICdmYWxzZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5kcmFmdExvZ2ljIHx8ICd0cnVlLWRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSB2YWx1ZSBhcyAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHBvc2l0aW9uIGFuZCBpbnNlcnQgcmlnaHQgYWZ0ZXIgdGhlIGRyYWZ0IHByb3BlcnR5IHNldHRpbmdcblx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZHJhZnRQcm9wZXJ0eVNldHRpbmcgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGRyYWZ0TG9naWNTZXR0aW5nLnNldHRpbmdFbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCF2YWx1ZSkge1xuXHRcdFx0XHRcdFx0cHJvcHMuZHJhZnRQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRwcm9wcy5oYXNEcmFmdFN0YXR1cyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Ly8gSGlkZSBmaWVsZHNcblx0XHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChkcmFmdExvZ2ljU2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKTtcblxuXHRcdFx0aWYgKHByb3BzLmhhc0RyYWZ0U3RhdHVzKSB7XG5cdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdC5zZXROYW1lKCdEcmFmdCBwcm9wZXJ0eScpXG5cdFx0XHRcdFx0LnNldERlc2MoJ1RoZSBmcm9udG1hdHRlciBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIGRyYWZ0IHN0YXR1cy4gTGVhdmUgYmxhbmsgdG8gdXNlIGFuIHVuZGVyc2NvcmUgcHJlZml4IGluc3RlYWQuJylcblx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0RHJhZnRQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkPy5wcm9wZXJ0eSB8fCAnZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuZHJhZnRQcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRwcm9wcy5kcmFmdFByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHQvLyBVcGRhdGUgbG9naWMgYmFzZWQgb24gcHJvcGVydHkgbmFtZVxuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gJ3B1Ymxpc2hlZCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSAndHJ1ZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFNob3cvaGlkZSBsb2dpYyBkcm9wZG93blxuXHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiAhZHJhZnRMb2dpY1NldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0TG9naWNTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGVudFR5cGVXcmFwcGVyKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0TmFtZSgnRHJhZnQgbG9naWMnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuc2V0RGVzYygnSG93IGRyYWZ0IHN0YXR1cyBpcyByZXByZXNlbnRlZCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcInRydWUgPSBkcmFmdFwiIGFuZCBcImZhbHNlID0gZHJhZnRcIiBhcmUgdGVjaG5pY2FsIG5vdGF0aW9uLCBub3QgVUkgdGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCd0cnVlLWRyYWZ0JywgJ3RydWUgPSBkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiZmFsc2UgPSBkcmFmdFwiIGlzIHRlY2huaWNhbCBub3RhdGlvbiwgbm90IFVJIHRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmFkZE9wdGlvbignZmFsc2UtZHJhZnQnLCAnZmFsc2UgPSBkcmFmdCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRyYWZ0TG9naWMgfHwgJ3RydWUtZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5vbkNoYW5nZShkcm9wZG93blZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSBkcm9wZG93blZhbHVlIGFzICd0cnVlLWRyYWZ0JyB8ICdmYWxzZS1kcmFmdCc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGRyYWZ0UHJvcGVydHlTZXR0aW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRyYWZ0UHJvcGVydHlTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCF2YWx1ZSAmJiBkcmFmdExvZ2ljU2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgdG9nZ2xlIHNldHRpbmdcblx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRkcmFmdFNldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBkcmFmdFByb3BlcnR5U2V0dGluZy5zZXR0aW5nRWwpO1xuXG5cdFx0XHRcdGlmIChwcm9wcy5kcmFmdFByb3BlcnR5KSB7XG5cdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0XHQuc2V0TmFtZSgnRHJhZnQgbG9naWMnKVxuXHRcdFx0XHRcdFx0LnNldERlc2MoJ0hvdyBkcmFmdCBzdGF0dXMgaXMgcmVwcmVzZW50ZWQnKVxuXHRcdFx0XHRcdFx0LmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcInRydWUgPSBkcmFmdFwiIGFuZCBcImZhbHNlID0gZHJhZnRcIiBhcmUgdGVjaG5pY2FsIG5vdGF0aW9uLCBub3QgVUkgdGV4dFxuXHRcdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXG5cdFx0XHRcdFx0XHRcdC5hZGRPcHRpb24oJ3RydWUtZHJhZnQnLCAndHJ1ZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiZmFsc2UgPSBkcmFmdFwiIGlzIHRlY2huaWNhbCBub3RhdGlvbiwgbm90IFVJIHRleHRcblx0XHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxuXHRcdFx0XHRcdFx0XHQuYWRkT3B0aW9uKCdmYWxzZS1kcmFmdCcsICdmYWxzZSA9IGRyYWZ0Jylcblx0XHRcdFx0XHRcdFx0LnNldFZhbHVlKHByb3BzLmRyYWZ0TG9naWMgfHwgJ3RydWUtZHJhZnQnKVxuXHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BzLmRyYWZ0TG9naWMgPSB2YWx1ZSBhcyAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnO1xuXHRcdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSBkcmFmdCBwcm9wZXJ0eSBzZXR0aW5nXG5cdFx0XHRcdFx0ZHJhZnRMb2dpY1NldHRpbmcuc2V0dGluZ0VsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGlmIChkcmFmdFByb3BlcnR5U2V0dGluZyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZHJhZnRQcm9wZXJ0eVNldHRpbmcuc2V0dGluZ0VsLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBkcmFmdExvZ2ljU2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYXMgSW1hZ2UgUHJvcGVydHk/XG5cdFx0XHRjb25zdCBpbWFnZVNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdC5zZXROYW1lKCdIYXMgaW1hZ2UvY292ZXIgcHJvcGVydHk/Jylcblx0XHRcdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiQmFzZXMgQ01TXCIsIFwiU2ltcGxlIEJhbm5lclwiLCBhbmQgXCJJbWFnZSBJbnNlcnRlclwiIGFyZSBwcm9wZXIgbm91bnMgKHByb2R1Y3QgbmFtZXMpIGFuZCBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxuXHRcdFx0XHQuc2V0RGVzYygnRG9lcyB0aGlzIGNvbnRlbnQgdHlwZSBoYXZlIGFuIGltYWdlIG9yIGNvdmVyIHByb3BlcnR5PyBVc2VkIGZvciBCYXNlcyBDTVMgY292ZXIgaW1hZ2VzLCBTaW1wbGUgQmFubmVyLCBhbmQgSW1hZ2UgSW5zZXJ0ZXIuJyk7XG5cdFx0XHRcblx0XHRcdGxldCBpbWFnZVRleHRTZXR0aW5nOiBTZXR0aW5nIHwgbnVsbCA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGltYWdlU2V0dGluZy5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuXHRcdFx0XHQuc2V0VmFsdWUoISFwcm9wcy5pbWFnZVByb3BlcnR5KVxuXHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiAhcHJvcHMuaW1hZ2VQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGV0ZWN0ZWQgPSBleGFtcGxlID8gdGhpcy5mcm9udG1hdHRlckFuYWx5emVyLmF1dG9EZXRlY3RJbWFnZVByb3BlcnR5KGV4YW1wbGUuZnJvbnRtYXR0ZXIpIDogbnVsbDtcblx0XHRcdFx0XHRcdHByb3BzLmltYWdlUHJvcGVydHkgPSBkZXRlY3RlZCB8fCAnaW1hZ2UnO1xuXHRcdFx0XHRcdFx0Ly8gU2hvdyB0ZXh0IGZpZWxkXG5cdFx0XHRcdFx0XHRpZiAoIWltYWdlVGV4dFNldHRpbmcpIHtcblx0XHRcdFx0XHRcdFx0aW1hZ2VUZXh0U2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRlbnRUeXBlV3JhcHBlcilcblx0XHRcdFx0XHRcdFx0XHQuc2V0TmFtZSgnSW1hZ2UgcHJvcGVydHknKVxuXHRcdFx0XHRcdFx0XHRcdC5zZXREZXNjKCdUaGUgZnJvbnRtYXR0ZXIgcHJvcGVydHkgdGhhdCBjb250YWlucyB0aGUgaW1hZ2UvY292ZXIgKGUuZy4sIGltYWdlLCBjb3ZlciwgY292ZXJJbWFnZSwgdGh1bWJuYWlsLCBmZWF0dXJlZEltYWdlKS4gTGVhdmUgYmxhbmsgaWYgbm90IGFwcGxpY2FibGUuJylcblx0XHRcdFx0XHRcdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRldGVjdGVkID0gZXhhbXBsZSA/IHRoaXMuZnJvbnRtYXR0ZXJBbmFseXplci5hdXRvRGV0ZWN0SW1hZ2VQcm9wZXJ0eShleGFtcGxlLmZyb250bWF0dGVyKSA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0LnNldFBsYWNlaG9sZGVyKGRldGVjdGVkIHx8ICdpbWFnZScpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5zZXRWYWx1ZShwcm9wcy5pbWFnZVByb3BlcnR5IHx8ICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQub25DaGFuZ2UodmFsdWUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzLmltYWdlUHJvcGVydHkgPSB2YWx1ZS50cmltKCkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGZyb20gY3VycmVudCBwb3NpdGlvbiBhbmQgaW5zZXJ0IHJpZ2h0IGFmdGVyIHRoZSB0b2dnbGUgc2V0dGluZ1xuXHRcdFx0XHRcdFx0XHRpbWFnZVRleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0aW1hZ2VTZXR0aW5nLnNldHRpbmdFbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyZW5kJywgaW1hZ2VUZXh0U2V0dGluZy5zZXR0aW5nRWwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdFx0XHRwcm9wcy5pbWFnZVByb3BlcnR5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0Ly8gSGlkZSB0ZXh0IGZpZWxkXG5cdFx0XHRcdFx0XHRpZiAoaW1hZ2VUZXh0U2V0dGluZykge1xuXHRcdFx0XHRcdFx0XHRpbWFnZVRleHRTZXR0aW5nLnNldHRpbmdFbC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0aW1hZ2VUZXh0U2V0dGluZyA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSk7XG5cblx0XHRcdGlmIChwcm9wcy5pbWFnZVByb3BlcnR5KSB7XG5cdFx0XHRcdGltYWdlVGV4dFNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250ZW50VHlwZVdyYXBwZXIpXG5cdFx0XHRcdFx0LnNldE5hbWUoJ0ltYWdlIHByb3BlcnR5Jylcblx0XHRcdFx0XHQuc2V0RGVzYygnVGhlIGZyb250bWF0dGVyIHByb3BlcnR5IHRoYXQgY29udGFpbnMgdGhlIGltYWdlL2NvdmVyIChlLmcuLCBpbWFnZSwgY292ZXIsIGNvdmVySW1hZ2UsIHRodW1ibmFpbCwgZmVhdHVyZWRJbWFnZSkuIExlYXZlIGJsYW5rIGlmIG5vdCBhcHBsaWNhYmxlLicpXG5cdFx0XHRcdFx0LmFkZFRleHQodGV4dCA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBkZXRlY3RlZCA9IGV4YW1wbGUgPyB0aGlzLmZyb250bWF0dGVyQW5hbHl6ZXIuYXV0b0RldGVjdEltYWdlUHJvcGVydHkoZXhhbXBsZS5mcm9udG1hdHRlcikgOiBudWxsO1xuXHRcdFx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihkZXRlY3RlZCB8fCAnaW1hZ2UnKVxuXHRcdFx0XHRcdFx0XHQuc2V0VmFsdWUocHJvcHMuaW1hZ2VQcm9wZXJ0eSB8fCAnJylcblx0XHRcdFx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcblx0XHRcdFx0XHRcdFx0XHRwcm9wcy5pbWFnZVByb3BlcnR5ID0gdmFsdWUudHJpbSgpIHx8IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdC8vIFJlbW92ZSBmcm9tIGN1cnJlbnQgcG9zaXRpb24gYW5kIGluc2VydCByaWdodCBhZnRlciB0aGUgdG9nZ2xlIHNldHRpbmdcblx0XHRcdFx0aW1hZ2VUZXh0U2V0dGluZy5zZXR0aW5nRWwucmVtb3ZlKCk7XG5cdFx0XHRcdGltYWdlU2V0dGluZy5zZXR0aW5nRWwuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIGltYWdlVGV4dFNldHRpbmcuc2V0dGluZ0VsKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGVtcGxhdGUgZWRpdG9yXG5cdFx0XHRjb250ZW50VHlwZVdyYXBwZXIuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiAnVGVtcGxhdGUnIH0pO1xuXHRcdFx0Y29udGVudFR5cGVXcmFwcGVyLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdFx0dGV4dDogJ0VkaXQgdGhlIHRlbXBsYXRlIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IGZpbGVzIG9mIHRoaXMgY29udGVudCB0eXBlLiBVc2Uge3t0aXRsZX19IGFuZCB7e2RhdGV9fSBhcyB2YXJpYWJsZXMuIE5vdGU6IHt7dGl0bGV9fSBzaG91bGQgYmUgaW4gcXVvdGVzIChlLmcuLCB0aXRsZTogXCJ7e3RpdGxlfX1cIiksIHdoaWxlIHt7ZGF0ZX19IHNob3VsZCBub3QgYmUgaW4gcXVvdGVzIChlLmcuLCBkYXRlOiB7e2RhdGV9fSkuJyBcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHRlbXBsYXRlIGlmIG5vdCBleGlzdHNcblx0XHRcdGlmICghcHJvcHMudGVtcGxhdGUpIHtcblx0XHRcdFx0Ly8gR2VuZXJhdGUgZGVmYXVsdCB0ZW1wbGF0ZSBiYXNlZCBvbiBwcm9wZXJ0aWVzXG5cdFx0XHRcdHByb3BzLnRlbXBsYXRlID0gdGhpcy5nZW5lcmF0ZURlZmF1bHRUZW1wbGF0ZShwcm9wcywgZXhhbXBsZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRlbXBsYXRlVGV4dEFyZWEgPSBjb250ZW50VHlwZVdyYXBwZXIuY3JlYXRlRWwoJ3RleHRhcmVhJywge1xuXHRcdFx0XHRjbHM6ICd0ZW1wbGF0ZS1lZGl0b3InLFxuXHRcdFx0XHRhdHRyOiB7XG5cdFx0XHRcdFx0cm93czogJzEwJyxcblx0XHRcdFx0XHRzdHlsZTogJ3dpZHRoOiAxMDAlOyBmb250LWZhbWlseTogbW9ub3NwYWNlOycsXG5cdFx0XHRcdFx0c3BlbGxjaGVjazogJ2ZhbHNlJ1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHRlbXBsYXRlVGV4dEFyZWEudmFsdWUgPSBwcm9wcy50ZW1wbGF0ZSB8fCAnJztcblx0XHRcdHRlbXBsYXRlVGV4dEFyZWEuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZSkgPT4ge1xuXHRcdFx0XHRjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MVGV4dEFyZWFFbGVtZW50O1xuXHRcdFx0XHRwcm9wcy50ZW1wbGF0ZSA9IHRhcmdldC52YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgZ2VuZXJhdGVEZWZhdWx0VGVtcGxhdGUocHJvcHM6IHsgdGl0bGVQcm9wZXJ0eT86IHN0cmluZzsgZGF0ZVByb3BlcnR5Pzogc3RyaW5nOyBkZXNjcmlwdGlvblByb3BlcnR5Pzogc3RyaW5nOyB0YWdzUHJvcGVydHk/OiBzdHJpbmc7IGRyYWZ0UHJvcGVydHk/OiBzdHJpbmc7IGRyYWZ0TG9naWM/OiAndHJ1ZS1kcmFmdCcgfCAnZmFsc2UtZHJhZnQnIH0sIGV4YW1wbGU6IEV4YW1wbGVGcm9udG1hdHRlciB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG5cdFx0bGV0IHRlbXBsYXRlID0gJy0tLVxcbic7XG5cdFx0XG5cdFx0Ly8gUGFyc2UgdGhlIG9yaWdpbmFsIFlBTUwgdG8gbWFpbnRhaW4gb3JkZXJcblx0XHRpZiAoZXhhbXBsZSAmJiBleGFtcGxlLnJhd1lhbWwpIHtcblx0XHRcdC8vIFBhcnNlIHRoZSByYXcgWUFNTCBsaW5lIGJ5IGxpbmUgdG8gbWFpbnRhaW4gb3JkZXJcblx0XHRcdGNvbnN0IGxpbmVzID0gZXhhbXBsZS5yYXdZYW1sLnNwbGl0KCdcXG4nKTtcblx0XHRcdGNvbnN0IHByb2Nlc3NlZFByb3BzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0XHRcblx0XHRcdC8vIEZpcnN0LCBhZGQgdGl0bGUgcHJvcGVydHkgaWYgaXQncyBkZXRlY3RlZC9lbmFibGVkIChBTFdBWVMgaW5jbHVkZSBpdClcblx0XHRcdGxldCB0aXRsZUFkZGVkID0gZmFsc2U7XG5cdFx0XHRpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdFx0XHRjb25zdCB0cmltbWVkID0gbGluZS50cmltKCk7XG5cdFx0XHRcdFx0aWYgKCF0cmltbWVkIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnIycpKSBjb250aW51ZTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCBjb2xvbkluZGV4ID0gdHJpbW1lZC5pbmRleE9mKCc6Jyk7XG5cdFx0XHRcdFx0aWYgKGNvbG9uSW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwcm9wID0gdHJpbW1lZC5zdWJzdHJpbmcoMCwgY29sb25JbmRleCkudHJpbSgpO1xuXHRcdFx0XHRcdFx0aWYgKHByb3AgPT09IHByb3BzLnRpdGxlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMudGl0bGVQcm9wZXJ0eX06IFwie3t0aXRsZX19XCJcXG5gO1xuXHRcdFx0XHRcdFx0XHR0aXRsZUFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc2VkUHJvcHMuYWRkKHByb3ApO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aXRsZUFkZGVkKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMudGl0bGVQcm9wZXJ0eX06IFwie3t0aXRsZX19XCJcXG5gO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIFRoZW4gcHJvY2VzcyBvdGhlciBsaW5lcyBpbiBvcmRlclxuXHRcdFx0Zm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG5cdFx0XHRcdGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcblx0XHRcdFx0aWYgKCF0cmltbWVkIHx8IHRyaW1tZWQuc3RhcnRzV2l0aCgnIycpKSBjb250aW51ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IGNvbG9uSW5kZXggPSB0cmltbWVkLmluZGV4T2YoJzonKTtcblx0XHRcdFx0aWYgKGNvbG9uSW5kZXggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgcHJvcCA9IHRyaW1tZWQuc3Vic3RyaW5nKDAsIGNvbG9uSW5kZXgpLnRyaW0oKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBTa2lwIGlmIGFscmVhZHkgcHJvY2Vzc2VkXG5cdFx0XHRcdFx0aWYgKHByb2Nlc3NlZFByb3BzLmhhcyhwcm9wKSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFNraXAgdGl0bGUgKGFscmVhZHkgYWRkZWQpXG5cdFx0XHRcdFx0aWYgKHByb3AgPT09IHByb3BzLnRpdGxlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBIYW5kbGUgZGF0ZSBwcm9wZXJ0eSAtIEFMV0FZUyBpbmNsdWRlIGlmIGRldGVjdGVkL2VuYWJsZWRcblx0XHRcdFx0XHRpZiAocHJvcCA9PT0gcHJvcHMuZGF0ZVByb3BlcnR5ICYmIHByb3BzLmRhdGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMuZGF0ZVByb3BlcnR5fToge3tkYXRlfX1cXG5gO1xuXHRcdFx0XHRcdFx0cHJvY2Vzc2VkUHJvcHMuYWRkKHByb3ApO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEhhbmRsZSBkZXNjcmlwdGlvbiBwcm9wZXJ0eVxuXHRcdFx0XHRcdGlmIChwcm9wID09PSBwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5fTogXCJcIlxcbmA7XG5cdFx0XHRcdFx0XHRwcm9jZXNzZWRQcm9wcy5hZGQocHJvcCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gUHJvY2VzcyBvdGhlciBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBleGFtcGxlLmZyb250bWF0dGVyW3Byb3BdO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTpcXG5gO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiBbXVxcbmA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06ICR7dmFsdWV9XFxuYDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0XHRcdC8vIE1pcnJvciB0aGUgYWN0dWFsIG51bWVyaWMgdmFsdWUgZnJvbSB0aGUgc2Nhbm5lZCBkb2N1bWVudFxuXHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06ICR7dmFsdWV9XFxuYDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdC8vIENoZWNrIGlmIGl0IGxvb2tzIGxpa2UgYSBkYXRlIChZWVlZLU1NLUREIGZvcm1hdClcblx0XHRcdFx0XHRcdGlmICgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9Ly50ZXN0KHZhbHVlKSAmJiBwcm9wLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RhdGUnKSkge1xuXHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfToge3tkYXRlfX1cXG5gO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcH06IFwiXCJcXG5gO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3B9OiBbXVxcbmA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wfTpcXG5gO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRwcm9jZXNzZWRQcm9wcy5hZGQocHJvcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRGVmYXVsdCB0ZW1wbGF0ZSBpZiBubyBleGFtcGxlIC0gb25seSBpbmNsdWRlIHByb3BlcnRpZXMgdGhhdCBhcmUgc2V0XG5cdFx0XHRpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy50aXRsZVByb3BlcnR5fTogXCJ7e3RpdGxlfX1cIlxcbmA7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvcHMuZGF0ZVByb3BlcnR5KSB7XG5cdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRhdGVQcm9wZXJ0eX06IHt7ZGF0ZX19XFxuYDtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdHRlbXBsYXRlICs9IGAke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9OiBcIlwiXFxuYDtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9wcy50YWdzUHJvcGVydHkpIHtcblx0XHRcdFx0dGVtcGxhdGUgKz0gYCR7cHJvcHMudGFnc1Byb3BlcnR5fTogW11cXG5gO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdFx0Y29uc3QgZHJhZnRWYWx1ZSA9IHByb3BzLmRyYWZ0TG9naWMgPT09ICdmYWxzZS1kcmFmdCcgPyAnZmFsc2UnIDogJ3RydWUnO1xuXHRcdFx0XHR0ZW1wbGF0ZSArPSBgJHtwcm9wcy5kcmFmdFByb3BlcnR5fTogJHtkcmFmdFZhbHVlfVxcbmA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHRlbXBsYXRlICs9ICctLS1cXG4nO1xuXHRcdHJldHVybiB0ZW1wbGF0ZTtcblx0fVxuXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xuXHRcdC8vIFZhbGlkYXRpb246IHRpdGxlUHJvcGVydHkgaXMgcmVxdWlyZWQgKGJ1dCBjYW4gYmUgZW1wdHkgc3RyaW5nLCB3aWxsIHVzZSBmaWxlLmZ1bGxuYW1lKVxuXHRcdC8vIEFjdHVhbGx5LCB0aXRsZVByb3BlcnR5IGNhbiBiZSBibGFuayAtIGlmIGJsYW5rLCBpdCB3aWxsIHVzZSBmaWxlLmZ1bGxuYW1lIGFzIGZhbGxiYWNrXG5cdFx0Ly8gU28gdmFsaWRhdGlvbiBzaG91bGQgYWx3YXlzIHBhc3MgLSB0aGUgc3RlcCBpcyBvcHRpb25hbFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ0Zyb250bWF0dGVyIHByb3BlcnRpZXMnO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ01hcCBmcm9udG1hdHRlciBwcm9wZXJ0aWVzJztcblx0fVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSwgVEZvbGRlciB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEV4YW1wbGVGcm9udG1hdHRlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIHlhbWwgZnJvbSAneWFtbCc7XG5cbmV4cG9ydCBjbGFzcyBGcm9udG1hdHRlckFuYWx5emVyIHtcblx0cHJpdmF0ZSBhcHA6IEFwcDtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHR9XG5cblx0YXN5bmMgZmluZEV4YW1wbGVGaWxlKGZvbGRlclBhdGg6IHN0cmluZyk6IFByb21pc2U8RXhhbXBsZUZyb250bWF0dGVyIHwgbnVsbD4ge1xuXHRcdGNvbnN0IGZvbGRlciA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmb2xkZXJQYXRoKTtcblx0XHRcblx0XHRpZiAoIWZvbGRlcikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChmb2xkZXIgaW5zdGFuY2VvZiBURmlsZSAmJiBmb2xkZXIuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgdGhpcy5wYXJzZUZyb250bWF0dGVyKGZvbGRlcik7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEl0J3MgYSBmb2xkZXIsIGdldCBmaWxlcyBmcm9tIGl0XG5cdFx0Ly8gRmlyc3QsIHRyeSB0byBmaW5kIGZpbGVzIGluIHRoZSBpbW1lZGlhdGUgZm9sZGVyXG5cdFx0aWYgKCEoZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRsZXQgZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCBmYWxzZSk7IC8vIGZhbHNlID0gb25seSBpbW1lZGlhdGUgY2hpbGRyZW5cblx0XHRcblx0XHQvLyBJZiBubyBmaWxlcyBmb3VuZCBpbiBpbW1lZGlhdGUgZm9sZGVyLCBzZWFyY2ggZGVlcGVyIChvbmUgbGV2ZWwgYXQgYSB0aW1lKVxuXHRcdGlmIChmaWxlcy5sZW5ndGggPT09IDAgJiYgZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikge1xuXHRcdFx0Ly8gU2VhcmNoIG9uZSBsZXZlbCBkZWVwZXJcblx0XHRcdGZpbGVzID0gdGhpcy5nZXRNYXJrZG93bkZpbGVzKGZvbGRlciwgdHJ1ZSwgMSk7IC8vIHRydWUgPSByZWN1cnNpdmUsIG1heERlcHRoID0gMVxuXHRcdFx0XG5cdFx0XHQvLyBJZiBzdGlsbCBubyBmaWxlcywgc2VhcmNoIHR3byBsZXZlbHMgZGVlcGVyXG5cdFx0XHRpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGZpbGVzID0gdGhpcy5nZXRNYXJrZG93bkZpbGVzKGZvbGRlciwgdHJ1ZSwgMik7IC8vIG1heERlcHRoID0gMlxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBJZiBzdGlsbCBubyBmaWxlcywgc2VhcmNoIGFsbCBsZXZlbHMgKHVubGltaXRlZCBkZXB0aClcblx0XHRcdGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0ZmlsZXMgPSB0aGlzLmdldE1hcmtkb3duRmlsZXMoZm9sZGVyLCB0cnVlKTsgLy8gdW5saW1pdGVkIGRlcHRoXG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuXHRcdFx0Y29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucGFyc2VGcm9udG1hdHRlcihmaWxlKTtcblx0XHRcdGlmIChleGFtcGxlKSB7XG5cdFx0XHRcdHJldHVybiBleGFtcGxlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGhhc1VuZGVyc2NvcmVGaWxlcyhmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHRjb25zdCBmb2xkZXIgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZm9sZGVyUGF0aCk7XG5cdFx0XG5cdFx0aWYgKCEoZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdH1cblx0XHRcblx0XHRjb25zdCBmaWxlcyA9IHRoaXMuZ2V0TWFya2Rvd25GaWxlcyhmb2xkZXIsIHRydWUpO1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlsZXMuc29tZShmaWxlID0+IGZpbGUubmFtZS5zdGFydHNXaXRoKCdfJykpKTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0TWFya2Rvd25GaWxlcyhmb2xkZXI6IFRGb2xkZXIsIHJlY3Vyc2l2ZTogYm9vbGVhbiA9IHRydWUsIG1heERlcHRoPzogbnVtYmVyLCBjdXJyZW50RGVwdGg6IG51bWJlciA9IDApOiBURmlsZVtdIHtcblx0XHRjb25zdCBmaWxlczogVEZpbGVbXSA9IFtdO1xuXHRcdFxuXHRcdGlmICghZm9sZGVyLmNoaWxkcmVuKSB7XG5cdFx0XHRyZXR1cm4gZmlsZXM7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIENoZWNrIGlmIHdlJ3ZlIGV4Y2VlZGVkIG1heCBkZXB0aFxuXHRcdGlmIChtYXhEZXB0aCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aCkge1xuXHRcdFx0cmV0dXJuIGZpbGVzO1xuXHRcdH1cblx0XHRcblx0XHRmb3IgKGNvbnN0IGNoaWxkIG9mIGZvbGRlci5jaGlsZHJlbikge1xuXHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVEZpbGUgJiYgY2hpbGQuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG5cdFx0XHRcdGZpbGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0fSBlbHNlIGlmIChyZWN1cnNpdmUgJiYgY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyICYmIGNoaWxkLmNoaWxkcmVuKSB7XG5cdFx0XHRcdC8vIFJlY3Vyc2l2ZWx5IHNlYXJjaCBzdWJmb2xkZXJzXG5cdFx0XHRcdGZpbGVzLnB1c2goLi4udGhpcy5nZXRNYXJrZG93bkZpbGVzKGNoaWxkLCByZWN1cnNpdmUsIG1heERlcHRoLCBjdXJyZW50RGVwdGggKyAxKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBmaWxlcztcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgcGFyc2VGcm9udG1hdHRlcihmaWxlOiBURmlsZSk6IFByb21pc2U8RXhhbXBsZUZyb250bWF0dGVyIHwgbnVsbD4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcblx0XHRcdGNvbnN0IGZyb250bWF0dGVyUmVnZXggPSAvXi0tLVxccypcXG4oW1xcc1xcU10qPylcXG4tLS1cXHMqXFxuLztcblx0XHRcdGNvbnN0IG1hdGNoID0gY29udGVudC5tYXRjaChmcm9udG1hdHRlclJlZ2V4KTtcblx0XHRcdFxuXHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgeWFtbENvbnRlbnQgPSBtYXRjaFsxXTtcblx0XHRcdGNvbnN0IGZyb250bWF0dGVyID0geWFtbC5wYXJzZSh5YW1sQ29udGVudCkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsO1xuXHRcdFx0XG5cdFx0XHRpZiAoIWZyb250bWF0dGVyIHx8IHR5cGVvZiBmcm9udG1hdHRlciAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGZpbGU6IGZpbGUucGF0aCxcblx0XHRcdFx0ZnJvbnRtYXR0ZXIsXG5cdFx0XHRcdHJhd1lhbWw6IHlhbWxDb250ZW50XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0YXV0b0RldGVjdERhdGVQcm9wZXJ0eShmcm9udG1hdHRlcjogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBzdHJpbmcgfCBudWxsIHtcblx0XHRjb25zdCBkYXRlUHJvcGVydGllcyA9IFsnZGF0ZScsICdwdWJEYXRlJywgJ3B1Ymxpc2hlZERhdGUnLCAncHVibGlzaERhdGUnXTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IHByb3Agb2YgZGF0ZVByb3BlcnRpZXMpIHtcblx0XHRcdGlmIChmcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7IC8vIFJldHVybiBudWxsIHdoZW4gbm90IGZvdW5kLCBkb24ndCBkZWZhdWx0IHRvICdkYXRlJ1xuXHR9XG5cblx0YXV0b0RldGVjdERlc2NyaXB0aW9uUHJvcGVydHkoZnJvbnRtYXR0ZXI6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHwgbnVsbCB7XG5cdFx0Y29uc3QgZGVzY3JpcHRpb25Qcm9wZXJ0aWVzID0gWydkZXNjcmlwdGlvbicsICdzdW1tYXJ5JywgJ2V4Y2VycHQnLCAnaW50cm8nLCAnc25pcHBldCcsICdibHVyYiddO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgcHJvcCBvZiBkZXNjcmlwdGlvblByb3BlcnRpZXMpIHtcblx0XHRcdGlmIChmcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRhdXRvRGV0ZWN0VGFnc1Byb3BlcnR5KGZyb250bWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB8IG51bGwge1xuXHRcdC8vIE9ubHkgbWF0Y2ggXCJ0YWdzXCIgLSBzdHJpY3QgbWF0Y2hpbmcsIG5vIGZ1enp5IG1hdGNoaW5nXG5cdFx0aWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KCd0YWdzJykpIHtcblx0XHRcdHJldHVybiAndGFncyc7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0YXV0b0RldGVjdERyYWZ0UHJvcGVydHkoZnJvbnRtYXR0ZXI6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogeyBwcm9wZXJ0eTogc3RyaW5nOyBsb2dpYzogJ3RydWUtZHJhZnQnIHwgJ2ZhbHNlLWRyYWZ0JyB9IHwgbnVsbCB7XG5cdFx0aWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KCdkcmFmdCcpKSB7XG5cdFx0XHQvLyBJZiBwcm9wZXJ0eSBpcyBcImRyYWZ0XCIsIGxvZ2ljIHNob3VsZCBiZSBcInRydWUtZHJhZnRcIlxuXHRcdFx0cmV0dXJuIHsgcHJvcGVydHk6ICdkcmFmdCcsIGxvZ2ljOiAndHJ1ZS1kcmFmdCcgfTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KCdwdWJsaXNoZWQnKSkge1xuXHRcdFx0Ly8gSWYgcHJvcGVydHkgaXMgXCJwdWJsaXNoZWRcIiwgbG9naWMgc2hvdWxkIGJlIFwiZmFsc2UtZHJhZnRcIlxuXHRcdFx0cmV0dXJuIHsgcHJvcGVydHk6ICdwdWJsaXNoZWQnLCBsb2dpYzogJ2ZhbHNlLWRyYWZ0JyB9O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGF1dG9EZXRlY3RJbWFnZVByb3BlcnR5KGZyb250bWF0dGVyOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHN0cmluZyB8IG51bGwge1xuXHRcdGNvbnN0IGltYWdlUHJvcGVydGllcyA9IFsnaW1hZ2UnLCAnY292ZXInLCAnY292ZXJJbWFnZScsICd0aHVtYm5haWwnLCAnZmVhdHVyZWRJbWFnZSddO1xuXHRcdFxuXHRcdGZvciAoY29uc3QgcHJvcCBvZiBpbWFnZVByb3BlcnRpZXMpIHtcblx0XHRcdGlmIChmcm9udG1hdHRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuIiwgImNvbnN0IEFMSUFTID0gU3ltYm9sLmZvcigneWFtbC5hbGlhcycpO1xuY29uc3QgRE9DID0gU3ltYm9sLmZvcigneWFtbC5kb2N1bWVudCcpO1xuY29uc3QgTUFQID0gU3ltYm9sLmZvcigneWFtbC5tYXAnKTtcbmNvbnN0IFBBSVIgPSBTeW1ib2wuZm9yKCd5YW1sLnBhaXInKTtcbmNvbnN0IFNDQUxBUiA9IFN5bWJvbC5mb3IoJ3lhbWwuc2NhbGFyJyk7XG5jb25zdCBTRVEgPSBTeW1ib2wuZm9yKCd5YW1sLnNlcScpO1xuY29uc3QgTk9ERV9UWVBFID0gU3ltYm9sLmZvcigneWFtbC5ub2RlLnR5cGUnKTtcbmNvbnN0IGlzQWxpYXMgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IEFMSUFTO1xuY29uc3QgaXNEb2N1bWVudCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gRE9DO1xuY29uc3QgaXNNYXAgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IE1BUDtcbmNvbnN0IGlzUGFpciA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gUEFJUjtcbmNvbnN0IGlzU2NhbGFyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTQ0FMQVI7XG5jb25zdCBpc1NlcSA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gU0VRO1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIEFMSUFTOlxuICAgICAgICAgICAgY2FzZSBNQVA6XG4gICAgICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgaGFzQW5jaG9yID0gKG5vZGUpID0+IChpc1NjYWxhcihub2RlKSB8fCBpc0NvbGxlY3Rpb24obm9kZSkpICYmICEhbm9kZS5hbmNob3I7XG5cbmV4cG9ydCB7IEFMSUFTLCBET0MsIE1BUCwgTk9ERV9UWVBFLCBQQUlSLCBTQ0FMQVIsIFNFUSwgaGFzQW5jaG9yLCBpc0FsaWFzLCBpc0NvbGxlY3Rpb24sIGlzRG9jdW1lbnQsIGlzTWFwLCBpc05vZGUsIGlzUGFpciwgaXNTY2FsYXIsIGlzU2VxIH07XG4iLCAiaW1wb3J0IHsgaXNEb2N1bWVudCwgaXNOb2RlLCBpc1BhaXIsIGlzQ29sbGVjdGlvbiwgaXNNYXAsIGlzU2VxLCBpc1NjYWxhciwgaXNBbGlhcyB9IGZyb20gJy4vbm9kZXMvaWRlbnRpdHkuanMnO1xuXG5jb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIG5vZGUnKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGFuIEFTVCBub2RlIG9yIGRvY3VtZW50LlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIGBub2RlYCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIC0gYGtleWA6IEZvciBzZXF1ZW5jZSB2YWx1ZXMgYW5kIG1hcCBgUGFpcmAsIHRoZSBub2RlJ3MgaW5kZXggaW4gdGhlXG4gKiAgICAgY29sbGVjdGlvbi4gV2l0aGluIGEgYFBhaXJgLCBgJ2tleSdgIG9yIGAndmFsdWUnYCwgY29ycmVzcG9uZGluZ2x5LlxuICogICAgIGBudWxsYCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAqICAgLSBgbm9kZWA6IFRoZSBjdXJyZW50IG5vZGUuXG4gKiAgIC0gYHBhdGhgOiBUaGUgYW5jZXN0cnkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgY29udGludWUgd2l0aCBuZXh0XG4gKiAgICAgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBOb2RlYDogUmVwbGFjZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIGJ5IHZpc2l0aW5nIGl0XG4gKiAgIC0gYG51bWJlcmA6IFdoaWxlIGl0ZXJhdGluZyB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSBvciBtYXAsIHNldCB0aGUgaW5kZXhcbiAqICAgICBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICogICAgIG5vZGUgaGFzIGNoYW5nZWQuXG4gKlxuICogSWYgYHZpc2l0b3JgIGlzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB2YWx1ZXNcbiAqIGVuY291bnRlcmVkIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgZS5nLiBgbnVsbGAgdmFsdWVzLiBBbHRlcm5hdGl2ZWx5LFxuICogc2VwYXJhdGUgdmlzaXRvciBmdW5jdGlvbnMgbWF5IGJlIGRlZmluZWQgZm9yIGVhY2ggYE1hcGAsIGBQYWlyYCwgYFNlcWAsXG4gKiBgQWxpYXNgIGFuZCBgU2NhbGFyYCBub2RlLiBUbyBkZWZpbmUgdGhlIHNhbWUgdmlzaXRvciBmdW5jdGlvbiBmb3IgbW9yZSB0aGFuXG4gKiBvbmUgbm9kZSB0eXBlLCB1c2UgdGhlIGBDb2xsZWN0aW9uYCAobWFwIGFuZCBzZXEpLCBgVmFsdWVgIChtYXAsIHNlcSAmIHNjYWxhcilcbiAqIGFuZCBgTm9kZWAgKGFsaWFzLCBtYXAsIHNlcSAmIHNjYWxhcikgdGFyZ2V0cy4gT2YgYWxsIHRoZXNlLCBvbmx5IHRoZSBtb3N0XG4gKiBzcGVjaWZpYyBkZWZpbmVkIG9uZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQobm9kZSwgdmlzaXRvcikge1xuICAgIGNvbnN0IHZpc2l0b3JfID0gaW5pdFZpc2l0b3IodmlzaXRvcik7XG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSB2aXNpdF8obnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdmlzaXRfKG51bGwsIG5vZGUsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtdKSk7XG59XG4vLyBXaXRob3V0IHRoZSBgYXMgc3ltYm9sYCBjYXN0cywgVFMgZGVjbGFyZXMgdGhlc2UgaW4gdGhlIGB2aXNpdGBcbi8vIG5hbWVzcGFjZSB1c2luZyBgdmFyYCwgYnV0IHRoZW4gY29tcGxhaW5zIGFib3V0IHRoYXQgYmVjYXVzZVxuLy8gYHVuaXF1ZSBzeW1ib2xgIG11c3QgYmUgYGNvbnN0YC5cbi8qKiBUZXJtaW5hdGUgdmlzaXQgdHJhdmVyc2FsIGNvbXBsZXRlbHkgKi9cbnZpc2l0LkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlICovXG52aXNpdC5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuUkVNT1ZFID0gUkVNT1ZFO1xuZnVuY3Rpb24gdmlzaXRfKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCkge1xuICAgIGNvbnN0IGN0cmwgPSBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpO1xuICAgIGlmIChpc05vZGUoY3RybCkgfHwgaXNQYWlyKGN0cmwpKSB7XG4gICAgICAgIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgY3RybCk7XG4gICAgICAgIHJldHVybiB2aXNpdF8oa2V5LCBjdHJsLCB2aXNpdG9yLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHJsICE9PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IHZpc2l0XyhpLCBub2RlLml0ZW1zW2ldLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgY29uc3QgY2sgPSB2aXNpdF8oJ2tleScsIG5vZGUua2V5LCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjayA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2sgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdiA9IHZpc2l0XygndmFsdWUnLCBub2RlLnZhbHVlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjdiA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3YgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3RybDtcbn1cbi8qKlxuICogQXBwbHkgYW4gYXN5bmMgdmlzaXRvciB0byBhbiBBU1Qgbm9kZSBvciBkb2N1bWVudC5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSBgbm9kZWAsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICAtIGBrZXlgOiBGb3Igc2VxdWVuY2UgdmFsdWVzIGFuZCBtYXAgYFBhaXJgLCB0aGUgbm9kZSdzIGluZGV4IGluIHRoZVxuICogICAgIGNvbGxlY3Rpb24uIFdpdGhpbiBhIGBQYWlyYCwgYCdrZXknYCBvciBgJ3ZhbHVlJ2AsIGNvcnJlc3BvbmRpbmdseS5cbiAqICAgICBgbnVsbGAgZm9yIHRoZSByb290IG5vZGUuXG4gKiAgIC0gYG5vZGVgOiBUaGUgY3VycmVudCBub2RlLlxuICogICAtIGBwYXRoYDogVGhlIGFuY2VzdHJ5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYFByb21pc2VgOiBNdXN0IHJlc29sdmUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzXG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsIGNvbnRpbnVlIHdpdGggbmV4dFxuICogICAgIHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgTm9kZWA6IFJlcGxhY2UgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSBieSB2aXNpdGluZyBpdFxuICogICAtIGBudW1iZXJgOiBXaGlsZSBpdGVyYXRpbmcgdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2Ugb3IgbWFwLCBzZXQgdGhlIGluZGV4XG4gKiAgICAgb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRcbiAqICAgICBub2RlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIElmIGB2aXNpdG9yYCBpcyBhIHNpbmdsZSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdmFsdWVzXG4gKiBlbmNvdW50ZXJlZCBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIGUuZy4gYG51bGxgIHZhbHVlcy4gQWx0ZXJuYXRpdmVseSxcbiAqIHNlcGFyYXRlIHZpc2l0b3IgZnVuY3Rpb25zIG1heSBiZSBkZWZpbmVkIGZvciBlYWNoIGBNYXBgLCBgUGFpcmAsIGBTZXFgLFxuICogYEFsaWFzYCBhbmQgYFNjYWxhcmAgbm9kZS4gVG8gZGVmaW5lIHRoZSBzYW1lIHZpc2l0b3IgZnVuY3Rpb24gZm9yIG1vcmUgdGhhblxuICogb25lIG5vZGUgdHlwZSwgdXNlIHRoZSBgQ29sbGVjdGlvbmAgKG1hcCBhbmQgc2VxKSwgYFZhbHVlYCAobWFwLCBzZXEgJiBzY2FsYXIpXG4gKiBhbmQgYE5vZGVgIChhbGlhcywgbWFwLCBzZXEgJiBzY2FsYXIpIHRhcmdldHMuIE9mIGFsbCB0aGVzZSwgb25seSB0aGUgbW9zdFxuICogc3BlY2lmaWMgZGVmaW5lZCBvbmUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIG5vZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZpc2l0QXN5bmMobm9kZSwgdmlzaXRvcikge1xuICAgIGNvbnN0IHZpc2l0b3JfID0gaW5pdFZpc2l0b3IodmlzaXRvcik7XG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSBhd2FpdCB2aXNpdEFzeW5jXyhudWxsLCBub2RlLmNvbnRlbnRzLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbbm9kZV0pKTtcbiAgICAgICAgaWYgKGNkID09PSBSRU1PVkUpXG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBhd2FpdCB2aXNpdEFzeW5jXyhudWxsLCBub2RlLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdEFzeW5jLkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBub2RlICovXG52aXNpdEFzeW5jLlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBub2RlICovXG52aXNpdEFzeW5jLlJFTU9WRSA9IFJFTU9WRTtcbmFzeW5jIGZ1bmN0aW9uIHZpc2l0QXN5bmNfKGtleSwgbm9kZSwgdmlzaXRvciwgcGF0aCkge1xuICAgIGNvbnN0IGN0cmwgPSBhd2FpdCBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpO1xuICAgIGlmIChpc05vZGUoY3RybCkgfHwgaXNQYWlyKGN0cmwpKSB7XG4gICAgICAgIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgY3RybCk7XG4gICAgICAgIHJldHVybiB2aXNpdEFzeW5jXyhrZXksIGN0cmwsIHZpc2l0b3IsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN0cmwgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gYXdhaXQgdmlzaXRBc3luY18oaSwgbm9kZS5pdGVtc1tpXSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjaSAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNrID0gYXdhaXQgdmlzaXRBc3luY18oJ2tleScsIG5vZGUua2V5LCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjayA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2sgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdiA9IGF3YWl0IHZpc2l0QXN5bmNfKCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuZnVuY3Rpb24gaW5pdFZpc2l0b3IodmlzaXRvcikge1xuICAgIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgKHZpc2l0b3IuQ29sbGVjdGlvbiB8fCB2aXNpdG9yLk5vZGUgfHwgdmlzaXRvci5WYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQWxpYXM6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2NhbGFyOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuTm9kZVxuICAgICAgICB9LCB2aXNpdG9yLlZhbHVlICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5WYWx1ZVxuICAgICAgICB9LCB2aXNpdG9yLkNvbGxlY3Rpb24gJiYge1xuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLkNvbGxlY3Rpb24sXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuQ29sbGVjdGlvblxuICAgICAgICB9LCB2aXNpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2l0b3I7XG59XG5mdW5jdGlvbiBjYWxsVmlzaXRvcihrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aXNpdG9yKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlzTWFwKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5NYXA/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpc1NlcShub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuU2VxPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaXNQYWlyKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5QYWlyPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaXNTY2FsYXIobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLlNjYWxhcj8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlzQWxpYXMobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLkFsaWFzPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVwbGFjZU5vZGUoa2V5LCBwYXRoLCBub2RlKSB7XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc0NvbGxlY3Rpb24ocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuaXRlbXNba2V5XSA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGFpcihwYXJlbnQpKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdrZXknKVxuICAgICAgICAgICAgcGFyZW50LmtleSA9IG5vZGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhcmVudC52YWx1ZSA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRG9jdW1lbnQocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQuY29udGVudHMgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcHQgPSBpc0FsaWFzKHBhcmVudCkgPyAnYWxpYXMnIDogJ3NjYWxhcic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugbm9kZSB3aXRoICR7cHR9IHBhcmVudGApO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgdmlzaXQsIHZpc2l0QXN5bmMgfTtcbiIsICJpbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gJy4uL3Zpc2l0LmpzJztcblxuY29uc3QgZXNjYXBlQ2hhcnMgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICAnLCc6ICclMkMnLFxuICAgICdbJzogJyU1QicsXG4gICAgJ10nOiAnJTVEJyxcbiAgICAneyc6ICclN0InLFxuICAgICd9JzogJyU3RCdcbn07XG5jb25zdCBlc2NhcGVUYWdOYW1lID0gKHRuKSA9PiB0bi5yZXBsYWNlKC9bISxbXFxde31dL2csIGNoID0+IGVzY2FwZUNoYXJzW2NoXSk7XG5jbGFzcyBEaXJlY3RpdmVzIHtcbiAgICBjb25zdHJ1Y3Rvcih5YW1sLCB0YWdzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGlyZWN0aXZlcy1lbmQvZG9jLXN0YXJ0IG1hcmtlciBgLS0tYC4gSWYgYG51bGxgLCBhIG1hcmtlciBtYXkgc3RpbGwgYmVcbiAgICAgICAgICogaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50J3Mgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY1N0YXJ0ID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBkb2MtZW5kIG1hcmtlciBgLi4uYC4gICovXG4gICAgICAgIHRoaXMuZG9jRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMueWFtbCA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFlhbWwsIHlhbWwpO1xuICAgICAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRUYWdzLCB0YWdzKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgRGlyZWN0aXZlcyh0aGlzLnlhbWwsIHRoaXMudGFncyk7XG4gICAgICAgIGNvcHkuZG9jU3RhcnQgPSB0aGlzLmRvY1N0YXJ0O1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHVyaW5nIHBhcnNpbmcsIGdldCBhIERpcmVjdGl2ZXMgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IGFuZFxuICAgICAqIHVwZGF0ZSB0aGUgc3RyZWFtIHN0YXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2ZXJzaW9uJ3Mgc3BlYy5cbiAgICAgKi9cbiAgICBhdERvY3VtZW50KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgRGlyZWN0aXZlcyh0aGlzLnlhbWwsIHRoaXMudGFncyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy55YW1sLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnlhbWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4yJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uRXJyb3IgLSBNYXkgYmUgY2FsbGVkIGV2ZW4gaWYgdGhlIGFjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzXG4gICAgICovXG4gICAgYWRkKGxpbmUsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuYXROZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMueWFtbCA9IHsgZXhwbGljaXQ6IERpcmVjdGl2ZXMuZGVmYXVsdFlhbWwuZXhwbGljaXQsIHZlcnNpb246ICcxLjEnIH07XG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRUYWdzKTtcbiAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUudHJpbSgpLnNwbGl0KC9bIFxcdF0rLyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJyVUQUcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclVEFHIGRpcmVjdGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IHR3byBwYXJ0cycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2hhbmRsZSwgcHJlZml4XSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc1toYW5kbGVdID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnJVlBTUwnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sLmV4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoMCwgJyVZQU1MIGRpcmVjdGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSBwYXJ0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW3ZlcnNpb25dID0gcGFydHM7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gPT09ICcxLjEnIHx8IHZlcnNpb24gPT09ICcxLjInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWFtbC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gL15cXGQrXFwuXFxkKyQvLnRlc3QodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoNiwgYFVuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiAke3ZlcnNpb259YCwgaXNWYWxpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG9uRXJyb3IoMCwgYFVua25vd24gZGlyZWN0aXZlICR7bmFtZX1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSB0YWcsIG1hdGNoaW5nIGhhbmRsZXMgdG8gdGhvc2UgZGVmaW5lZCBpbiAlVEFHIGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlZCB0YWcsIHdoaWNoIG1heSBhbHNvIGJlIHRoZSBub24tc3BlY2lmaWMgdGFnIGAnISdgIG9yIGFcbiAgICAgKiAgIGAnIWxvY2FsJ2AgdGFnLCBvciBgbnVsbGAgaWYgdW5yZXNvbHZhYmxlLlxuICAgICAqL1xuICAgIHRhZ05hbWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiAnISc7IC8vIG5vbi1zcGVjaWZpYyB0YWdcbiAgICAgICAgaWYgKHNvdXJjZVswXSAhPT0gJyEnKSB7XG4gICAgICAgICAgICBvbkVycm9yKGBOb3QgYSB2YWxpZCB0YWc6ICR7c291cmNlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVsxXSA9PT0gJzwnKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJiYXRpbSA9IHNvdXJjZS5zbGljZSgyLCAtMSk7XG4gICAgICAgICAgICBpZiAodmVyYmF0aW0gPT09ICchJyB8fCB2ZXJiYXRpbSA9PT0gJyEhJykge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoYFZlcmJhdGltIHRhZ3MgYXJlbid0IHJlc29sdmVkLCBzbyAke3NvdXJjZX0gaXMgaW52YWxpZC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnPicpXG4gICAgICAgICAgICAgICAgb25FcnJvcignVmVyYmF0aW0gdGFncyBtdXN0IGVuZCB3aXRoIGEgPicpO1xuICAgICAgICAgICAgcmV0dXJuIHZlcmJhdGltO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFssIGhhbmRsZSwgc3VmZml4XSA9IHNvdXJjZS5tYXRjaCgvXiguKiEpKFteIV0qKSQvcyk7XG4gICAgICAgIGlmICghc3VmZml4KVxuICAgICAgICAgICAgb25FcnJvcihgVGhlICR7c291cmNlfSB0YWcgaGFzIG5vIHN1ZmZpeGApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aGlzLnRhZ3NbaGFuZGxlXTtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgZGVjb2RlVVJJQ29tcG9uZW50KHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKFN0cmluZyhlcnJvcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGUgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7IC8vIGxvY2FsIHRhZ1xuICAgICAgICBvbkVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSB0YWc6ICR7c291cmNlfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmdWxseSByZXNvbHZlZCB0YWcsIHJldHVybnMgaXRzIHByaW50YWJsZSBzdHJpbmcgZm9ybSxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IGN1cnJlbnQgdGFnIHByZWZpeGVzIGFuZCBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICB0YWdTdHJpbmcodGFnKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGFnLnN0YXJ0c1dpdGgocHJlZml4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlICsgZXNjYXBlVGFnTmFtZSh0YWcuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnWzBdID09PSAnIScgPyB0YWcgOiBgITwke3RhZ30+YDtcbiAgICB9XG4gICAgdG9TdHJpbmcoZG9jKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy55YW1sLmV4cGxpY2l0XG4gICAgICAgICAgICA/IFtgJVlBTUwgJHt0aGlzLnlhbWwudmVyc2lvbiB8fCAnMS4yJ31gXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgdGFnRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudGFncyk7XG4gICAgICAgIGxldCB0YWdOYW1lcztcbiAgICAgICAgaWYgKGRvYyAmJiB0YWdFbnRyaWVzLmxlbmd0aCA+IDAgJiYgaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB7fTtcbiAgICAgICAgICAgIHZpc2l0KGRvYy5jb250ZW50cywgKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKG5vZGUpICYmIG5vZGUudGFnKVxuICAgICAgICAgICAgICAgICAgICB0YWdzW25vZGUudGFnXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhZ05hbWVzID0gT2JqZWN0LmtleXModGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFnTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlLCBwcmVmaXhdIG9mIHRhZ0VudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgPT09ICchIScgJiYgcHJlZml4ID09PSAndGFnOnlhbWwub3JnLDIwMDI6JylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZG9jIHx8IHRhZ05hbWVzLnNvbWUodG4gPT4gdG4uc3RhcnRzV2l0aChwcmVmaXgpKSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAlVEFHICR7aGFuZGxlfSAke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxufVxuRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCA9IHsgZXhwbGljaXQ6IGZhbHNlLCB2ZXJzaW9uOiAnMS4yJyB9O1xuRGlyZWN0aXZlcy5kZWZhdWx0VGFncyA9IHsgJyEhJzogJ3RhZzp5YW1sLm9yZywyMDAyOicgfTtcblxuZXhwb3J0IHsgRGlyZWN0aXZlcyB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gJy4uL3Zpc2l0LmpzJztcblxuLyoqXG4gKiBWZXJpZnkgdGhhdCB0aGUgaW5wdXQgc3RyaW5nIGlzIGEgdmFsaWQgYW5jaG9yLlxuICpcbiAqIFdpbGwgdGhyb3cgb24gZXJyb3JzLlxuICovXG5mdW5jdGlvbiBhbmNob3JJc1ZhbGlkKGFuY2hvcikge1xuICAgIGlmICgvW1xceDAwLVxceDE5XFxzLFtcXF17fV0vLnRlc3QoYW5jaG9yKSkge1xuICAgICAgICBjb25zdCBzYSA9IEpTT04uc3RyaW5naWZ5KGFuY2hvcik7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBBbmNob3IgbXVzdCBub3QgY29udGFpbiB3aGl0ZXNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVyczogJHtzYX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhbmNob3JOYW1lcyhyb290KSB7XG4gICAgY29uc3QgYW5jaG9ycyA9IG5ldyBTZXQoKTtcbiAgICB2aXNpdChyb290LCB7XG4gICAgICAgIFZhbHVlKF9rZXksIG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmFuY2hvcilcbiAgICAgICAgICAgICAgICBhbmNob3JzLmFkZChub2RlLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYW5jaG9ycztcbn1cbi8qKiBGaW5kIGEgbmV3IGFuY2hvciBuYW1lIHdpdGggdGhlIGdpdmVuIGBwcmVmaXhgIGFuZCBhIG9uZS1pbmRleGVkIHN1ZmZpeC4gKi9cbmZ1bmN0aW9uIGZpbmROZXdBbmNob3IocHJlZml4LCBleGNsdWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IHRydWU7ICsraSkge1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7cHJlZml4fSR7aX1gO1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuaGFzKG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTm9kZUFuY2hvcnMoZG9jLCBwcmVmaXgpIHtcbiAgICBjb25zdCBhbGlhc09iamVjdHMgPSBbXTtcbiAgICBjb25zdCBzb3VyY2VPYmplY3RzID0gbmV3IE1hcCgpO1xuICAgIGxldCBwcmV2QW5jaG9ycyA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25BbmNob3I6IChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgIGFsaWFzT2JqZWN0cy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBwcmV2QW5jaG9ycyA/PyAocHJldkFuY2hvcnMgPSBhbmNob3JOYW1lcyhkb2MpKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGZpbmROZXdBbmNob3IocHJlZml4LCBwcmV2QW5jaG9ycyk7XG4gICAgICAgICAgICBwcmV2QW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHRoZSBzb3VyY2Ugbm9kZSBpcyBvbmx5IHJlc29sdmVkIGFmdGVyIGFsbFxuICAgICAgICAgKiBvZiBpdHMgY2hpbGQgbm9kZXMgYXJlLiBUaGlzIGlzIHdoeSBhbmNob3JzIGFyZSBzZXQgb25seSBhZnRlciBhbGwgb2ZcbiAgICAgICAgICogdGhlIG5vZGVzIGhhdmUgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QW5jaG9yczogKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgYWxpYXNPYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gc291cmNlT2JqZWN0cy5nZXQoc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVmLmFuY2hvciAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNTY2FsYXIocmVmLm5vZGUpIHx8IGlzQ29sbGVjdGlvbihyZWYubm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5ub2RlLmFuY2hvciA9IHJlZi5hbmNob3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlc29sdmUgcmVwZWF0ZWQgb2JqZWN0ICh0aGlzIHNob3VsZCBub3QgaGFwcGVuKScpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlT2JqZWN0c1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFuY2hvcklzVmFsaWQsIGFuY2hvck5hbWVzLCBjcmVhdGVOb2RlQW5jaG9ycywgZmluZE5ld0FuY2hvciB9O1xuIiwgIi8qKlxuICogQXBwbGllcyB0aGUgSlNPTi5wYXJzZSByZXZpdmVyIGFsZ29yaXRobSBhcyBkZWZpbmVkIGluIHRoZSBFQ01BLTI2MiBzcGVjLFxuICogaW4gc2VjdGlvbiAyNC41LjEuMSBcIlJ1bnRpbWUgU2VtYW50aWNzOiBJbnRlcm5hbGl6ZUpTT05Qcm9wZXJ0eVwiIG9mIHRoZVxuICogMjAyMSBlZGl0aW9uOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24ucGFyc2VcbiAqXG4gKiBJbmNsdWRlcyBleHRlbnNpb25zIGZvciBoYW5kbGluZyBNYXAgYW5kIFNldCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBhcHBseVJldml2ZXIocmV2aXZlciwgb2JqLCBrZXksIHZhbCkge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gdmFsW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgU3RyaW5nKGkpLCB2MCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1hcnJheS1kZWxldGVcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbFtpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApXG4gICAgICAgICAgICAgICAgICAgIHZhbFtpXSA9IHYxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIEFycmF5LmZyb20odmFsLmtleXMoKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHZhbC5nZXQoayk7XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCBrLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWwuc2V0KGssIHYxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdjAgb2YgQXJyYXkuZnJvbSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCB2MCwgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKHYwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5hZGQodjEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHYwXSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjEgPSBhcHBseVJldml2ZXIocmV2aXZlciwgdmFsLCBrLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxba107XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxba10gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV2aXZlci5jYWxsKG9iaiwga2V5LCB2YWwpO1xufVxuXG5leHBvcnQgeyBhcHBseVJldml2ZXIgfTtcbiIsICJpbXBvcnQgeyBoYXNBbmNob3IgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjb252ZXJ0IGFueSBub2RlIG9yIGl0cyBjb250ZW50cyB0byBuYXRpdmUgSmF2YVNjcmlwdFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBpbnB1dCB2YWx1ZVxuICogQHBhcmFtIGFyZyAtIElmIGB2YWx1ZWAgZGVmaW5lcyBhIGB0b0pTT04oKWAgbWV0aG9kLCB1c2UgdGhpc1xuICogICBhcyBpdHMgZmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSBjdHggLSBDb252ZXJzaW9uIGNvbnRleHQsIG9yaWdpbmFsbHkgc2V0IGluIERvY3VtZW50I3RvSlMoKS4gSWZcbiAqICAgYHsga2VlcDogdHJ1ZSB9YCBpcyBub3Qgc2V0LCBvdXRwdXQgc2hvdWxkIGJlIHN1aXRhYmxlIGZvciBKU09OXG4gKiAgIHN0cmluZ2lmaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9KUyh2YWx1ZSwgYXJnLCBjdHgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYsIGkpID0+IHRvSlModiwgU3RyaW5nKGkpLCBjdHgpKTtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgIGlmICghY3R4IHx8ICFoYXNBbmNob3IodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IGFsaWFzQ291bnQ6IDAsIGNvdW50OiAxLCByZXM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBjdHguYW5jaG9ycy5zZXQodmFsdWUsIGRhdGEpO1xuICAgICAgICBjdHgub25DcmVhdGUgPSByZXMgPT4ge1xuICAgICAgICAgICAgZGF0YS5yZXMgPSByZXM7XG4gICAgICAgICAgICBkZWxldGUgY3R4Lm9uQ3JlYXRlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSB2YWx1ZS50b0pTT04oYXJnLCBjdHgpO1xuICAgICAgICBpZiAoY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnICYmICFjdHg/LmtlZXApXG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IHsgdG9KUyB9O1xuIiwgImltcG9ydCB7IGFwcGx5UmV2aXZlciB9IGZyb20gJy4uL2RvYy9hcHBseVJldml2ZXIuanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBpc0RvY3VtZW50IH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY2xhc3MgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogdHlwZSB9KTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLiAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKVxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHRoaXMucmFuZ2Uuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKiBBIHBsYWluIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLiAqL1xuICAgIHRvSlMoZG9jLCB7IG1hcEFzTWFwLCBtYXhBbGlhc0NvdW50LCBvbkFuY2hvciwgcmV2aXZlciB9ID0ge30pIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50KGRvYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGRvY3VtZW50IGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGtlZXA6IHRydWUsXG4gICAgICAgICAgICBtYXBBc01hcDogbWFwQXNNYXAgPT09IHRydWUsXG4gICAgICAgICAgICBtYXBLZXlXYXJuZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWF4QWxpYXNDb3VudDogdHlwZW9mIG1heEFsaWFzQ291bnQgPT09ICdudW1iZXInID8gbWF4QWxpYXNDb3VudCA6IDEwMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSB0b0pTKHRoaXMsICcnLCBjdHgpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGNvdW50LCByZXMgfSBvZiBjdHguYW5jaG9ycy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICBvbkFuY2hvcihyZXMsIGNvdW50KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTm9kZUJhc2UgfTtcbiIsICJpbXBvcnQgeyBhbmNob3JJc1ZhbGlkIH0gZnJvbSAnLi4vZG9jL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5pbXBvcnQgeyBBTElBUywgaXNBbGlhcywgaXNDb2xsZWN0aW9uLCBpc1BhaXIsIGhhc0FuY2hvciB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgTm9kZUJhc2UgfSBmcm9tICcuL05vZGUuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4vdG9KUy5qcyc7XG5cbmNsYXNzIEFsaWFzIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihBTElBUyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZycsIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsaWFzIG5vZGVzIGNhbm5vdCBoYXZlIHRhZ3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIHZhbHVlIG9mIHRoaXMgYWxpYXMgd2l0aGluIGBkb2NgLCBmaW5kaW5nIHRoZSBsYXN0XG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIGBzb3VyY2VgIGFuY2hvciBiZWZvcmUgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIHJlc29sdmUoZG9jLCBjdHgpIHtcbiAgICAgICAgbGV0IG5vZGVzO1xuICAgICAgICBpZiAoY3R4Py5hbGlhc1Jlc29sdmVDYWNoZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBjdHguYWxpYXNSZXNvbHZlQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICAgICAgdmlzaXQoZG9jLCB7XG4gICAgICAgICAgICAgICAgTm9kZTogKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWxpYXMobm9kZSkgfHwgaGFzQW5jaG9yKG5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjdHgpXG4gICAgICAgICAgICAgICAgY3R4LmFsaWFzUmVzb2x2ZUNhY2hlID0gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSB0aGlzLnNvdXJjZSlcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICB0b0pTT04oX2FyZywgY3R4KSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBjb25zdCB7IGFuY2hvcnMsIGRvYywgbWF4QWxpYXNDb3VudCB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmUoZG9jLCBjdHgpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIGFuY2hvcnMgZm9yIE5vZGUucHJvdG90eXBlLnRvSlMoKVxuICAgICAgICAgICAgdG9KUyhzb3VyY2UsIG51bGwsIGN0eCk7XG4gICAgICAgICAgICBkYXRhID0gYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGRhdGE/LnJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnVGhpcyBzaG91bGQgbm90IGhhcHBlbjogQWxpYXMgYW5jaG9yIHdhcyBub3QgcmVzb2x2ZWQ/JztcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhBbGlhc0NvdW50ID49IDApIHtcbiAgICAgICAgICAgIGRhdGEuY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLmFsaWFzQ291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgZGF0YS5hbGlhc0NvdW50ID0gZ2V0QWxpYXNDb3VudChkb2MsIHNvdXJjZSwgYW5jaG9ycyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5jb3VudCAqIGRhdGEuYWxpYXNDb3VudCA+IG1heEFsaWFzQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnRXhjZXNzaXZlIGFsaWFzIGNvdW50IGluZGljYXRlcyBhIHJlc291cmNlIGV4aGF1c3Rpb24gYXR0YWNrJztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5yZXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgX29uQ29tbWVudCwgX29uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGAqJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBhbmNob3JJc1ZhbGlkKHRoaXMuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy52ZXJpZnlBbGlhc09yZGVyICYmICFjdHguYW5jaG9ycy5oYXModGhpcy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHguaW1wbGljaXRLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NyY30gYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFsaWFzQ291bnQoZG9jLCBub2RlLCBhbmNob3JzKSB7XG4gICAgaWYgKGlzQWxpYXMobm9kZSkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZS5yZXNvbHZlKGRvYyk7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvcnMgJiYgc291cmNlICYmIGFuY2hvcnMuZ2V0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBhbmNob3IgPyBhbmNob3IuY291bnQgKiBhbmNob3IuYWxpYXNDb3VudCA6IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygbm9kZS5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGdldEFsaWFzQ291bnQoZG9jLCBpdGVtLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChjID4gY291bnQpXG4gICAgICAgICAgICAgICAgY291bnQgPSBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGtjID0gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUua2V5LCBhbmNob3JzKTtcbiAgICAgICAgY29uc3QgdmMgPSBnZXRBbGlhc0NvdW50KGRvYywgbm9kZS52YWx1ZSwgYW5jaG9ycyk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChrYywgdmMpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn1cblxuZXhwb3J0IHsgQWxpYXMgfTtcbiIsICJpbXBvcnQgeyBTQ0FMQVIgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IE5vZGVCYXNlIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBpc1NjYWxhclZhbHVlID0gKHZhbHVlKSA9PiAhdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbmNsYXNzIFNjYWxhciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihTQ0FMQVIpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihhcmcsIGN0eCkge1xuICAgICAgICByZXR1cm4gY3R4Py5rZWVwID8gdGhpcy52YWx1ZSA6IHRvSlModGhpcy52YWx1ZSwgYXJnLCBjdHgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5TY2FsYXIuQkxPQ0tfRk9MREVEID0gJ0JMT0NLX0ZPTERFRCc7XG5TY2FsYXIuQkxPQ0tfTElURVJBTCA9ICdCTE9DS19MSVRFUkFMJztcblNjYWxhci5QTEFJTiA9ICdQTEFJTic7XG5TY2FsYXIuUVVPVEVfRE9VQkxFID0gJ1FVT1RFX0RPVUJMRSc7XG5TY2FsYXIuUVVPVEVfU0lOR0xFID0gJ1FVT1RFX1NJTkdMRSc7XG5cbmV4cG9ydCB7IFNjYWxhciwgaXNTY2FsYXJWYWx1ZSB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgaXNOb2RlLCBpc1BhaXIsIE1BUCwgU0VRLCBpc0RvY3VtZW50IH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuY29uc3QgZGVmYXVsdFRhZ1ByZWZpeCA9ICd0YWc6eWFtbC5vcmcsMjAwMjonO1xuZnVuY3Rpb24gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgdGFncykge1xuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LnRhZyA9PT0gdGFnTmFtZSk7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IG1hdGNoLmZpbmQodCA9PiAhdC5mb3JtYXQpID8/IG1hdGNoWzBdO1xuICAgICAgICBpZiAoIXRhZ09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFnICR7dGFnTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybiB0YWdPYmo7XG4gICAgfVxuICAgIHJldHVybiB0YWdzLmZpbmQodCA9PiB0LmlkZW50aWZ5Py4odmFsdWUpICYmICF0LmZvcm1hdCk7XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlLCB0YWdOYW1lLCBjdHgpIHtcbiAgICBpZiAoaXNEb2N1bWVudCh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdmFsdWUuY29udGVudHM7XG4gICAgaWYgKGlzTm9kZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoaXNQYWlyKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBtYXAgPSBjdHguc2NoZW1hW01BUF0uY3JlYXRlTm9kZT8uKGN0eC5zY2hlbWEsIG51bGwsIGN0eCk7XG4gICAgICAgIG1hcC5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuICAgICAgICAodHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBCaWdJbnQpIC8vIG5vdCBzdXBwb3J0ZWQgZXZlcnl3aGVyZVxuICAgICkge1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNlcmlhbGl6ZWpzb25wcm9wZXJ0eVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICB9XG4gICAgY29uc3QgeyBhbGlhc0R1cGxpY2F0ZU9iamVjdHMsIG9uQW5jaG9yLCBvblRhZ09iaiwgc2NoZW1hLCBzb3VyY2VPYmplY3RzIH0gPSBjdHg7XG4gICAgLy8gRGV0ZWN0IGR1cGxpY2F0ZSByZWZlcmVuY2VzIHRvIHRoZSBzYW1lIG9iamVjdCAmIHVzZSBBbGlhcyBub2RlcyBmb3IgYWxsXG4gICAgLy8gYWZ0ZXIgZmlyc3QuIFRoZSBgcmVmYCB3cmFwcGVyIGFsbG93cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byByZXNvbHZlLlxuICAgIGxldCByZWYgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGFsaWFzRHVwbGljYXRlT2JqZWN0cyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlZiA9IHNvdXJjZU9iamVjdHMuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgcmVmLmFuY2hvciA/PyAocmVmLmFuY2hvciA9IG9uQW5jaG9yKHZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsaWFzKHJlZi5hbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmID0geyBhbmNob3I6IG51bGwsIG5vZGU6IG51bGwgfTtcbiAgICAgICAgICAgIHNvdXJjZU9iamVjdHMuc2V0KHZhbHVlLCByZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lPy5zdGFydHNXaXRoKCchIScpKVxuICAgICAgICB0YWdOYW1lID0gZGVmYXVsdFRhZ1ByZWZpeCArIHRhZ05hbWUuc2xpY2UoMik7XG4gICAgbGV0IHRhZ09iaiA9IGZpbmRUYWdPYmplY3QodmFsdWUsIHRhZ05hbWUsIHNjaGVtYS50YWdzKTtcbiAgICBpZiAoIXRhZ09iaikge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWYpXG4gICAgICAgICAgICAgICAgcmVmLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGFnT2JqID1cbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTWFwXG4gICAgICAgICAgICAgICAgPyBzY2hlbWFbTUFQXVxuICAgICAgICAgICAgICAgIDogU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBzY2hlbWFbU0VRXVxuICAgICAgICAgICAgICAgICAgICA6IHNjaGVtYVtNQVBdO1xuICAgIH1cbiAgICBpZiAob25UYWdPYmopIHtcbiAgICAgICAgb25UYWdPYmoodGFnT2JqKTtcbiAgICAgICAgZGVsZXRlIGN0eC5vblRhZ09iajtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRhZ09iaj8uY3JlYXRlTm9kZVxuICAgICAgICA/IHRhZ09iai5jcmVhdGVOb2RlKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpXG4gICAgICAgIDogdHlwZW9mIHRhZ09iaj8ubm9kZUNsYXNzPy5mcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHRhZ09iai5ub2RlQ2xhc3MuZnJvbShjdHguc2NoZW1hLCB2YWx1ZSwgY3R4KVxuICAgICAgICAgICAgOiBuZXcgU2NhbGFyKHZhbHVlKTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGVsc2UgaWYgKCF0YWdPYmouZGVmYXVsdClcbiAgICAgICAgbm9kZS50YWcgPSB0YWdPYmoudGFnO1xuICAgIGlmIChyZWYpXG4gICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTm9kZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBpc05vZGUsIGlzUGFpciwgaXNDb2xsZWN0aW9uLCBpc1NjYWxhciB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgTm9kZUJhc2UgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjb2xsZWN0aW9uRnJvbVBhdGgoc2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCB2ID0gdmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgayA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihrKSAmJiBrID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgIGFba10gPSB2O1xuICAgICAgICAgICAgdiA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gbmV3IE1hcChbW2ssIHZdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUodiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogZmFsc2UsXG4gICAgICAgIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICAgICAgICBvbkFuY2hvcjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBwbGVhc2UgcmVwb3J0IGEgYnVnLicpO1xuICAgICAgICB9LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNvdXJjZU9iamVjdHM6IG5ldyBNYXAoKVxuICAgIH0pO1xufVxuLy8gVHlwZSBndWFyZCBpcyBpbnRlbnRpb25hbGx5IGEgbGl0dGxlIHdyb25nIHNvIGFzIHRvIGJlIG1vcmUgdXNlZnVsLFxuLy8gYXMgaXQgZG9lcyBub3QgY292ZXIgdW50eXBhYmxlIGVtcHR5IG5vbi1zdHJpbmcgaXRlcmFibGVzIChlLmcuIFtdKS5cbmNvbnN0IGlzRW1wdHlQYXRoID0gKHBhdGgpID0+IHBhdGggPT0gbnVsbCB8fFxuICAgICh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgISFwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZSk7XG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNjaGVtYSkge1xuICAgICAgICBzdXBlcih0eXBlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY2hlbWEnLCB7XG4gICAgICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29weSBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gSWYgZGVmaW5lZCwgb3ZlcndyaXRlcyB0aGUgb3JpZ2luYWwncyBzY2hlbWFcbiAgICAgKi9cbiAgICBjbG9uZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBjb3B5LnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgY29weS5pdGVtcyA9IGNvcHkuaXRlbXMubWFwKGl0ID0+IGlzTm9kZShpdCkgfHwgaXNQYWlyKGl0KSA/IGl0LmNsb25lKHNjaGVtYSkgOiBpdCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKVxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHRoaXMucmFuZ2Uuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi4gRm9yIGAhIW1hcGAgYW5kIGAhIW9tYXBgIHRoZSB2YWx1ZSBtdXN0XG4gICAgICogYmUgYSBQYWlyIGluc3RhbmNlIG9yIGEgYHsga2V5LCB2YWx1ZSB9YCBvYmplY3QsIHdoaWNoIG1heSBub3QgaGF2ZSBhIGtleVxuICAgICAqIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICB0aGlzLmFkZCh2YWx1ZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuYWRkSW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5kZWxldGVJbihyZXN0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldEluKHBhdGgsIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmdldEluKHJlc3QsIGtlZXBTY2FsYXIpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXNBbGxOdWxsVmFsdWVzKGFsbG93U2NhbGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmV2ZXJ5KG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1BhaXIobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKG4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChhbGxvd1NjYWxhciAmJlxuICAgICAgICAgICAgICAgICAgICBpc1NjYWxhcihuKSAmJlxuICAgICAgICAgICAgICAgICAgICBuLnZhbHVlID09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4uY29tbWVudEJlZm9yZSAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICFuLnRhZykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjb2xsZWN0aW9uIGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXMoa2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmhhc0luKHJlc3QpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGNvbGxlY3Rpb24uIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgICAgICBub2RlLnNldEluKHJlc3QsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbGxlY3Rpb24sIGNvbGxlY3Rpb25Gcm9tUGF0aCwgaXNFbXB0eVBhdGggfTtcbiIsICIvKipcbiAqIFN0cmluZ2lmaWVzIGEgY29tbWVudC5cbiAqXG4gKiBFbXB0eSBjb21tZW50IGxpbmVzIGFyZSBsZWZ0IGVtcHR5LFxuICogbGluZXMgY29uc2lzdGluZyBvZiBhIHNpbmdsZSBzcGFjZSBhcmUgcmVwbGFjZWQgYnkgYCNgLFxuICogYW5kIGFsbCBvdGhlciBsaW5lcyBhcmUgcHJlZml4ZWQgd2l0aCBhIGAjYC5cbiAqL1xuY29uc3Qgc3RyaW5naWZ5Q29tbWVudCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC9eKD8hJCkoPzogJCk/L2dtLCAnIycpO1xuZnVuY3Rpb24gaW5kZW50Q29tbWVudChjb21tZW50LCBpbmRlbnQpIHtcbiAgICBpZiAoL15cXG4rJC8udGVzdChjb21tZW50KSlcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQuc3Vic3RyaW5nKDEpO1xuICAgIHJldHVybiBpbmRlbnQgPyBjb21tZW50LnJlcGxhY2UoL14oPyEgKiQpL2dtLCBpbmRlbnQpIDogY29tbWVudDtcbn1cbmNvbnN0IGxpbmVDb21tZW50ID0gKHN0ciwgaW5kZW50LCBjb21tZW50KSA9PiBzdHIuZW5kc1dpdGgoJ1xcbicpXG4gICAgPyBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudClcbiAgICA6IGNvbW1lbnQuaW5jbHVkZXMoJ1xcbicpXG4gICAgICAgID8gJ1xcbicgKyBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudClcbiAgICAgICAgOiAoc3RyLmVuZHNXaXRoKCcgJykgPyAnJyA6ICcgJykgKyBjb21tZW50O1xuXG5leHBvcnQgeyBpbmRlbnRDb21tZW50LCBsaW5lQ29tbWVudCwgc3RyaW5naWZ5Q29tbWVudCB9O1xuIiwgImNvbnN0IEZPTERfRkxPVyA9ICdmbG93JztcbmNvbnN0IEZPTERfQkxPQ0sgPSAnYmxvY2snO1xuY29uc3QgRk9MRF9RVU9URUQgPSAncXVvdGVkJztcbi8qKlxuICogVHJpZXMgdG8ga2VlcCBpbnB1dCBhdCB1cCB0byBgbGluZVdpZHRoYCBjaGFyYWN0ZXJzLCBzcGxpdHRpbmcgb25seSBvbiBzcGFjZXNcbiAqIG5vdCBmb2xsb3dlZCBieSBuZXdsaW5lcyBvciBzcGFjZXMgdW5sZXNzIGBtb2RlYCBpcyBgJ3F1b3RlZCdgLiBMaW5lcyBhcmVcbiAqIHRlcm1pbmF0ZWQgd2l0aCBgXFxuYCBhbmQgc3RhcnRlZCB3aXRoIGBpbmRlbnRgLlxuICovXG5mdW5jdGlvbiBmb2xkRmxvd0xpbmVzKHRleHQsIGluZGVudCwgbW9kZSA9ICdmbG93JywgeyBpbmRlbnRBdFN0YXJ0LCBsaW5lV2lkdGggPSA4MCwgbWluQ29udGVudFdpZHRoID0gMjAsIG9uRm9sZCwgb25PdmVyZmxvdyB9ID0ge30pIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBpZiAobGluZVdpZHRoIDwgbWluQ29udGVudFdpZHRoKVxuICAgICAgICBtaW5Db250ZW50V2lkdGggPSAwO1xuICAgIGNvbnN0IGVuZFN0ZXAgPSBNYXRoLm1heCgxICsgbWluQ29udGVudFdpZHRoLCAxICsgbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKHRleHQubGVuZ3RoIDw9IGVuZFN0ZXApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGNvbnN0IGZvbGRzID0gW107XG4gICAgY29uc3QgZXNjYXBlZEZvbGRzID0ge307XG4gICAgbGV0IGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbmRlbnRBdFN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaW5kZW50QXRTdGFydCA+IGxpbmVXaWR0aCAtIE1hdGgubWF4KDIsIG1pbkNvbnRlbnRXaWR0aCkpXG4gICAgICAgICAgICBmb2xkcy5wdXNoKDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnRBdFN0YXJ0O1xuICAgIH1cbiAgICBsZXQgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IHByZXYgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG92ZXJmbG93ID0gZmFsc2U7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBsZXQgZXNjU3RhcnQgPSAtMTtcbiAgICBsZXQgZXNjRW5kID0gLTE7XG4gICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spIHtcbiAgICAgICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpLCBpbmRlbnQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKVxuICAgICAgICAgICAgZW5kID0gaSArIGVuZFN0ZXA7XG4gICAgfVxuICAgIGZvciAobGV0IGNoOyAoY2ggPSB0ZXh0WyhpICs9IDEpXSk7KSB7XG4gICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBlc2NTdGFydCA9IGk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRbaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjRW5kID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSylcbiAgICAgICAgICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGksIGluZGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgZW5kID0gaSArIGluZGVudC5sZW5ndGggKyBlbmRTdGVwO1xuICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFxuJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BhY2Ugc3Vycm91bmRlZCBieSBub24tc3BhY2UgY2FuIGJlIHJlcGxhY2VkIHdpdGggbmV3bGluZSArIGluZGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSAnICcgJiYgbmV4dCAhPT0gJ1xcbicgJiYgbmV4dCAhPT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKHNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3BsaXQgKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGUtc3BhY2UgY29sbGVjdGVkIGF0IGVuZCBtYXkgc3RyZXRjaCBwYXN0IGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHRleHRbKGkgKz0gMSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIG5ld2xpbmUgZXNjYXBlLCBidXQgZG9uJ3QgYnJlYWsgcHJlY2VkaW5nIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqID0gaSA+IGVzY0VuZCArIDEgPyBpIC0gMiA6IGVzY1N0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgaWYgbGluZVdpZHRoICYgbWluQ29udGVudFdpZHRoIGFyZSBzaG9ydGVyIHRoYW4gYW4gZXNjYXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZEZvbGRzW2pdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRGb2xkc1tqXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGogKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGNoO1xuICAgIH1cbiAgICBpZiAob3ZlcmZsb3cgJiYgb25PdmVyZmxvdylcbiAgICAgICAgb25PdmVyZmxvdygpO1xuICAgIGlmIChmb2xkcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGlmIChvbkZvbGQpXG4gICAgICAgIG9uRm9sZCgpO1xuICAgIGxldCByZXMgPSB0ZXh0LnNsaWNlKDAsIGZvbGRzWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGZvbGQgPSBmb2xkc1tpXTtcbiAgICAgICAgY29uc3QgZW5kID0gZm9sZHNbaSArIDFdIHx8IHRleHQubGVuZ3RoO1xuICAgICAgICBpZiAoZm9sZCA9PT0gMClcbiAgICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoMCwgZW5kKX1gO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBlc2NhcGVkRm9sZHNbZm9sZF0pXG4gICAgICAgICAgICAgICAgcmVzICs9IGAke3RleHRbZm9sZF19XFxcXGA7XG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZShmb2xkICsgMSwgZW5kKX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFByZXN1bWVzIGBpICsgMWAgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZVxuICogQHJldHVybnMgaW5kZXggb2YgbGFzdCBuZXdsaW5lIGluIG1vcmUtaW5kZW50ZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGksIGluZGVudCkge1xuICAgIGxldCBlbmQgPSBpO1xuICAgIGxldCBzdGFydCA9IGkgKyAxO1xuICAgIGxldCBjaCA9IHRleHRbc3RhcnRdO1xuICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICBpZiAoaSA8IHN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICAgICAgICBjaCA9IHRleHRbKytpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjaCA9IHRleHRbKytpXTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGNoID0gdGV4dFtzdGFydF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuZXhwb3J0IHsgRk9MRF9CTE9DSywgRk9MRF9GTE9XLCBGT0xEX1FVT1RFRCwgZm9sZEZsb3dMaW5lcyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBmb2xkRmxvd0xpbmVzLCBGT0xEX0ZMT1csIEZPTERfUVVPVEVELCBGT0xEX0JMT0NLIH0gZnJvbSAnLi9mb2xkRmxvd0xpbmVzLmpzJztcblxuY29uc3QgZ2V0Rm9sZE9wdGlvbnMgPSAoY3R4LCBpc0Jsb2NrKSA9PiAoe1xuICAgIGluZGVudEF0U3RhcnQ6IGlzQmxvY2sgPyBjdHguaW5kZW50Lmxlbmd0aCA6IGN0eC5pbmRlbnRBdFN0YXJ0LFxuICAgIGxpbmVXaWR0aDogY3R4Lm9wdGlvbnMubGluZVdpZHRoLFxuICAgIG1pbkNvbnRlbnRXaWR0aDogY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoXG59KTtcbi8vIEFsc28gY2hlY2tzIGZvciBsaW5lcyBzdGFydGluZyB3aXRoICUsIGFzIHBhcnNpbmcgdGhlIG91dHB1dCBhcyBZQU1MIDEuMSB3aWxsXG4vLyBwcmVzdW1lIHRoYXQncyBzdGFydGluZyBhIG5ldyBkb2N1bWVudC5cbmNvbnN0IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIgPSAoc3RyKSA9PiAvXiglfC0tLXxcXC5cXC5cXC4pL20udGVzdChzdHIpO1xuZnVuY3Rpb24gbGluZUxlbmd0aE92ZXJMaW1pdChzdHIsIGxpbmVXaWR0aCwgaW5kZW50TGVuZ3RoKSB7XG4gICAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxpbWl0ID0gbGluZVdpZHRoIC0gaW5kZW50TGVuZ3RoO1xuICAgIGNvbnN0IHN0ckxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKHN0ckxlbiA8PSBsaW1pdClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBzdGFydCA9IDA7IGkgPCBzdHJMZW47ICsraSkge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKGkgLSBzdGFydCA+IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJMZW4gLSBzdGFydCA8PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKGN0eC5vcHRpb25zLmRvdWJsZVF1b3RlZEFzSlNPTilcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSB9ID0gY3R4O1xuICAgIGNvbnN0IG1pbk11bHRpTGluZUxlbmd0aCA9IGN0eC5vcHRpb25zLmRvdWJsZVF1b3RlZE1pbk11bHRpTGluZUxlbmd0aDtcbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGNoID0ganNvbltpXTsgY2g7IGNoID0ganNvblsrK2ldKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJyAnICYmIGpzb25baSArIDFdID09PSAnXFxcXCcgJiYganNvbltpICsgMl0gPT09ICduJykge1xuICAgICAgICAgICAgLy8gc3BhY2UgYmVmb3JlIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG4gICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxcXCAnO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgY2ggPSAnXFxcXCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpXG4gICAgICAgICAgICBzd2l0Y2ggKGpzb25baSArIDFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBqc29uLnN1YnN0cihpICsgMiwgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDAwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxhJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwYic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDFiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwODUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxOJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDBhMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXF8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcyMDI4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxQJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuc3Vic3RyKDAsIDIpID09PSAnMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxceCcgKyBjb2RlLnN1YnN0cigyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyAyXSA9PT0gJ1wiJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5sZW5ndGggPCBtaW5NdWx0aUxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvbGRpbmcgd2lsbCBlYXQgZmlyc3QgbmV3bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcblxcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoanNvbltpICsgMl0gPT09ICdcXFxcJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDNdID09PSAnbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyA0XSAhPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UgYWZ0ZXIgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uW2kgKyAyXSA9PT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RyID0gc3RhcnQgPyBzdHIgKyBqc29uLnNsaWNlKHN0YXJ0KSA6IGpzb247XG4gICAgcmV0dXJuIGltcGxpY2l0S2V5XG4gICAgICAgID8gc3RyXG4gICAgICAgIDogZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgRk9MRF9RVU9URUQsIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgaWYgKGN0eC5vcHRpb25zLnNpbmdsZVF1b3RlID09PSBmYWxzZSB8fFxuICAgICAgICAoY3R4LmltcGxpY2l0S2V5ICYmIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkgfHxcbiAgICAgICAgL1sgXFx0XVxcbnxcXG5bIFxcdF0vLnRlc3QodmFsdWUpIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgKVxuICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCByZXMgPSBcIidcIiArIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApICsgXCInXCI7XG4gICAgcmV0dXJuIGN0eC5pbXBsaWNpdEtleVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IGZvbGRGbG93TGluZXMocmVzLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCB7IHNpbmdsZVF1b3RlIH0gPSBjdHgub3B0aW9ucztcbiAgICBsZXQgcXM7XG4gICAgaWYgKHNpbmdsZVF1b3RlID09PSBmYWxzZSlcbiAgICAgICAgcXMgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhc0RvdWJsZSA9IHZhbHVlLmluY2x1ZGVzKCdcIicpO1xuICAgICAgICBjb25zdCBoYXNTaW5nbGUgPSB2YWx1ZS5pbmNsdWRlcyhcIidcIik7XG4gICAgICAgIGlmIChoYXNEb3VibGUgJiYgIWhhc1NpbmdsZSlcbiAgICAgICAgICAgIHFzID0gc2luZ2xlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlIGlmIChoYXNTaW5nbGUgJiYgIWhhc0RvdWJsZSlcbiAgICAgICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlID8gc2luZ2xlUXVvdGVkU3RyaW5nIDogZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcXModmFsdWUsIGN0eCk7XG59XG4vLyBUaGUgbmVnYXRpdmUgbG9va2JlaGluZCBhdm9pZHMgYSBwb2x5bm9taWFsIHNlYXJjaCxcbi8vIGJ1dCBpc24ndCBzdXBwb3J0ZWQgeWV0IG9uIFNhZmFyaTogaHR0cHM6Ly9jYW5pdXNlLmNvbS9qcy1yZWdleHAtbG9va2JlaGluZFxubGV0IGJsb2NrRW5kTmV3bGluZXM7XG50cnkge1xuICAgIGJsb2NrRW5kTmV3bGluZXMgPSBuZXcgUmVnRXhwKCcoXnwoPzwhXFxuKSlcXG4rKD8hXFxufCQpJywgJ2cnKTtcbn1cbmNhdGNoIHtcbiAgICBibG9ja0VuZE5ld2xpbmVzID0gL1xcbisoPyFcXG58JCkvZztcbn1cbmZ1bmN0aW9uIGJsb2NrU3RyaW5nKHsgY29tbWVudCwgdHlwZSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBibG9ja1F1b3RlLCBjb21tZW50U3RyaW5nLCBsaW5lV2lkdGggfSA9IGN0eC5vcHRpb25zO1xuICAgIC8vIDEuIEJsb2NrIGNhbid0IGVuZCBpbiB3aGl0ZXNwYWNlIHVubGVzcyB0aGUgbGFzdCBsaW5lIGlzIG5vbi1lbXB0eS5cbiAgICAvLyAyLiBTdHJpbmdzIGNvbnNpc3Rpbmcgb2Ygb25seSB3aGl0ZXNwYWNlIGFyZSBiZXN0IHJlbmRlcmVkIGV4cGxpY2l0bHkuXG4gICAgaWYgKCFibG9ja1F1b3RlIHx8IC9cXG5bXFx0IF0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50ID0gY3R4LmluZGVudCB8fFxuICAgICAgICAoY3R4LmZvcmNlQmxvY2tJbmRlbnQgfHwgY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICAgIGNvbnN0IGxpdGVyYWwgPSBibG9ja1F1b3RlID09PSAnbGl0ZXJhbCdcbiAgICAgICAgPyB0cnVlXG4gICAgICAgIDogYmxvY2tRdW90ZSA9PT0gJ2ZvbGRlZCcgfHwgdHlwZSA9PT0gU2NhbGFyLkJMT0NLX0ZPTERFRFxuICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgOiB0eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIGxpbmVXaWR0aCwgaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwgPyAnfFxcbicgOiAnPlxcbic7XG4gICAgLy8gZGV0ZXJtaW5lIGNob21waW5nIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBlbmRcbiAgICBsZXQgY2hvbXA7XG4gICAgbGV0IGVuZFN0YXJ0O1xuICAgIGZvciAoZW5kU3RhcnQgPSB2YWx1ZS5sZW5ndGg7IGVuZFN0YXJ0ID4gMDsgLS1lbmRTdGFydCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW2VuZFN0YXJ0IC0gMV07XG4gICAgICAgIGlmIChjaCAhPT0gJ1xcbicgJiYgY2ggIT09ICdcXHQnICYmIGNoICE9PSAnICcpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGVuZCA9IHZhbHVlLnN1YnN0cmluZyhlbmRTdGFydCk7XG4gICAgY29uc3QgZW5kTmxQb3MgPSBlbmQuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGVuZE5sUG9zID09PSAtMSkge1xuICAgICAgICBjaG9tcCA9ICctJzsgLy8gc3RyaXBcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IGVuZCB8fCBlbmRObFBvcyAhPT0gZW5kLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY2hvbXAgPSAnKyc7IC8vIGtlZXBcbiAgICAgICAgaWYgKG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNob21wID0gJyc7IC8vIGNsaXBcbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC1lbmQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGVuZFtlbmQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKVxuICAgICAgICAgICAgZW5kID0gZW5kLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoYmxvY2tFbmROZXdsaW5lcywgYCQmJHtpbmRlbnR9YCk7XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBpbmRlbnQgaW5kaWNhdG9yIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBzdGFydFxuICAgIGxldCBzdGFydFdpdGhTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBzdGFydEVuZDtcbiAgICBsZXQgc3RhcnRObFBvcyA9IC0xO1xuICAgIGZvciAoc3RhcnRFbmQgPSAwOyBzdGFydEVuZCA8IHZhbHVlLmxlbmd0aDsgKytzdGFydEVuZCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW3N0YXJ0RW5kXTtcbiAgICAgICAgaWYgKGNoID09PSAnICcpXG4gICAgICAgICAgICBzdGFydFdpdGhTcGFjZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0YXJ0TmxQb3MgPSBzdGFydEVuZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHZhbHVlLnN1YnN0cmluZygwLCBzdGFydE5sUG9zIDwgc3RhcnRFbmQgPyBzdGFydE5sUG9zICsgMSA6IHN0YXJ0RW5kKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRTaXplID0gaW5kZW50ID8gJzInIDogJzEnOyAvLyByb290IGlzIGF0IC0xXG4gICAgLy8gTGVhZGluZyB8IG9yID4gaXMgYWRkZWQgbGF0ZXJcbiAgICBsZXQgaGVhZGVyID0gKHN0YXJ0V2l0aFNwYWNlID8gaW5kZW50U2l6ZSA6ICcnKSArIGNob21wO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGhlYWRlciArPSAnICcgKyBjb21tZW50U3RyaW5nKGNvbW1lbnQucmVwbGFjZSgvID9bXFxyXFxuXSsvZywgJyAnKSk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKCFsaXRlcmFsKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlZFZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rL2csICdcXG4kJicpXG4gICAgICAgICAgICAucmVwbGFjZSgvKD86XnxcXG4pKFtcXHQgXS4qKSg/OihbXFxuXFx0IF0qKVxcbig/IVtcXG5cXHQgXSkpPy9nLCAnJDEkMicpIC8vIG1vcmUtaW5kZW50ZWQgbGluZXMgYXJlbid0IGZvbGRlZFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgXiBtb3JlLWluZC4gXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICAgICAgbGV0IGxpdGVyYWxGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICBjb25zdCBmb2xkT3B0aW9ucyA9IGdldEZvbGRPcHRpb25zKGN0eCwgdHJ1ZSk7XG4gICAgICAgIGlmIChibG9ja1F1b3RlICE9PSAnZm9sZGVkJyAmJiB0eXBlICE9PSBTY2FsYXIuQkxPQ0tfRk9MREVEKSB7XG4gICAgICAgICAgICBmb2xkT3B0aW9ucy5vbk92ZXJmbG93ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxpdGVyYWxGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBmb2xkRmxvd0xpbmVzKGAke3N0YXJ0fSR7Zm9sZGVkVmFsdWV9JHtlbmR9YCwgaW5kZW50LCBGT0xEX0JMT0NLLCBmb2xkT3B0aW9ucyk7XG4gICAgICAgIGlmICghbGl0ZXJhbEZhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuIGA+JHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHtib2R5fWA7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICByZXR1cm4gYHwke2hlYWRlcn1cXG4ke2luZGVudH0ke3N0YXJ0fSR7dmFsdWV9JHtlbmR9YDtcbn1cbmZ1bmN0aW9uIHBsYWluU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IGl0ZW07XG4gICAgY29uc3QgeyBhY3R1YWxTdHJpbmcsIGltcGxpY2l0S2V5LCBpbmRlbnQsIGluZGVudFN0ZXAsIGluRmxvdyB9ID0gY3R4O1xuICAgIGlmICgoaW1wbGljaXRLZXkgJiYgdmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB8fFxuICAgICAgICAoaW5GbG93ICYmIC9bW1xcXXt9LF0vLnRlc3QodmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoL15bXFxuXFx0ICxbXFxde30jJiohfD4nXCIlQGBdfF5bPy1dJHxeWz8tXVsgXFx0XXxbXFxuOl1bIFxcdF18WyBcXHRdXFxufFtcXG5cXHQgXSN8W1xcblxcdCA6XSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIG5vdCBhbGxvd2VkOlxuICAgICAgICAvLyAtICctJyBvciAnPydcbiAgICAgICAgLy8gLSBzdGFydCB3aXRoIGFuIGluZGljYXRvciBjaGFyYWN0ZXIgKGV4Y2VwdCBbPzotXSkgb3IgL1s/LV0gL1xuICAgICAgICAvLyAtICdcXG4gJywgJzogJyBvciAnIFxcbicgYW55d2hlcmVcbiAgICAgICAgLy8gLSAnIycgbm90IHByZWNlZGVkIGJ5IGEgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgLy8gLSBlbmQgd2l0aCAnICcgb3IgJzonXG4gICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3cgfHwgIXZhbHVlLmluY2x1ZGVzKCdcXG4nKVxuICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eClcbiAgICAgICAgICAgIDogYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgaWYgKCFpbXBsaWNpdEtleSAmJlxuICAgICAgICAhaW5GbG93ICYmXG4gICAgICAgIHR5cGUgIT09IFNjYWxhci5QTEFJTiAmJlxuICAgICAgICB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGluZGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltcGxpY2l0S2V5ICYmIGluZGVudCA9PT0gaW5kZW50U3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApO1xuICAgIC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAgIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG4gICAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKHRhZykgPT4gdGFnLmRlZmF1bHQgJiYgdGFnLnRhZyAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicgJiYgdGFnLnRlc3Q/LnRlc3Qoc3RyKTtcbiAgICAgICAgY29uc3QgeyBjb21wYXQsIHRhZ3MgfSA9IGN0eC5kb2Muc2NoZW1hO1xuICAgICAgICBpZiAodGFncy5zb21lKHRlc3QpIHx8IGNvbXBhdD8uc29tZSh0ZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXksIGluRmxvdyB9ID0gY3R4O1xuICAgIGNvbnN0IHNzID0gdHlwZW9mIGl0ZW0udmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gaXRlbVxuICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHsgdmFsdWU6IFN0cmluZyhpdGVtLnZhbHVlKSB9KTtcbiAgICBsZXQgeyB0eXBlIH0gPSBpdGVtO1xuICAgIGlmICh0eXBlICE9PSBTY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgIC8vIGZvcmNlIGRvdWJsZSBxdW90ZXMgb24gY29udHJvbCBjaGFyYWN0ZXJzICYgdW5wYWlyZWQgc3Vycm9nYXRlc1xuICAgICAgICBpZiAoL1tcXHgwMC1cXHgwOFxceDBiLVxceDFmXFx4N2YtXFx4OWZcXHV7RDgwMH0tXFx1e0RGRkZ9XS91LnRlc3Qoc3MudmFsdWUpKVxuICAgICAgICAgICAgdHlwZSA9IFNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgfVxuICAgIGNvbnN0IF9zdHJpbmdpZnkgPSAoX3R5cGUpID0+IHtcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuQkxPQ0tfRk9MREVEOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXIuQkxPQ0tfTElURVJBTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93XG4gICAgICAgICAgICAgICAgICAgID8gcXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpIC8vIGJsb2NrcyBhcmUgbm90IHZhbGlkIGluc2lkZSBmbG93IGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICAgICAgOiBibG9ja1N0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlFVT1RFX0RPVUJMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUVVPVEVfU0lOR0xFOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaW5nbGVRdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5QTEFJTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhaW5TdHJpbmcoc3MsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVzID0gX3N0cmluZ2lmeSh0eXBlKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEtleVR5cGUsIGRlZmF1bHRTdHJpbmdUeXBlIH0gPSBjdHgub3B0aW9ucztcbiAgICAgICAgY29uc3QgdCA9IChpbXBsaWNpdEtleSAmJiBkZWZhdWx0S2V5VHlwZSkgfHwgZGVmYXVsdFN0cmluZ1R5cGU7XG4gICAgICAgIHJlcyA9IF9zdHJpbmdpZnkodCk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlZmF1bHQgc3RyaW5nIHR5cGUgJHt0fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBhbmNob3JJc1ZhbGlkIH0gZnJvbSAnLi4vZG9jL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgaXNQYWlyLCBpc0FsaWFzLCBpc05vZGUsIGlzU2NhbGFyLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4vc3RyaW5naWZ5U3RyaW5nLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChkb2MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYmxvY2tRdW90ZTogdHJ1ZSxcbiAgICAgICAgY29tbWVudFN0cmluZzogc3RyaW5naWZ5Q29tbWVudCxcbiAgICAgICAgZGVmYXVsdEtleVR5cGU6IG51bGwsXG4gICAgICAgIGRlZmF1bHRTdHJpbmdUeXBlOiAnUExBSU4nLFxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxuICAgICAgICBkb3VibGVRdW90ZWRBc0pTT046IGZhbHNlLFxuICAgICAgICBkb3VibGVRdW90ZWRNaW5NdWx0aUxpbmVMZW5ndGg6IDQwLFxuICAgICAgICBmYWxzZVN0cjogJ2ZhbHNlJyxcbiAgICAgICAgZmxvd0NvbGxlY3Rpb25QYWRkaW5nOiB0cnVlLFxuICAgICAgICBpbmRlbnRTZXE6IHRydWUsXG4gICAgICAgIGxpbmVXaWR0aDogODAsXG4gICAgICAgIG1pbkNvbnRlbnRXaWR0aDogMjAsXG4gICAgICAgIG51bGxTdHI6ICdudWxsJyxcbiAgICAgICAgc2ltcGxlS2V5czogZmFsc2UsXG4gICAgICAgIHNpbmdsZVF1b3RlOiBudWxsLFxuICAgICAgICB0cnVlU3RyOiAndHJ1ZScsXG4gICAgICAgIHZlcmlmeUFsaWFzT3JkZXI6IHRydWVcbiAgICB9LCBkb2Muc2NoZW1hLnRvU3RyaW5nT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgbGV0IGluRmxvdztcbiAgICBzd2l0Y2ggKG9wdC5jb2xsZWN0aW9uU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgaW5GbG93ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvdyc6XG4gICAgICAgICAgICBpbkZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpbkZsb3cgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmNob3JzOiBuZXcgU2V0KCksXG4gICAgICAgIGRvYyxcbiAgICAgICAgZmxvd0NvbGxlY3Rpb25QYWRkaW5nOiBvcHQuZmxvd0NvbGxlY3Rpb25QYWRkaW5nID8gJyAnIDogJycsXG4gICAgICAgIGluZGVudDogJycsXG4gICAgICAgIGluZGVudFN0ZXA6IHR5cGVvZiBvcHQuaW5kZW50ID09PSAnbnVtYmVyJyA/ICcgJy5yZXBlYXQob3B0LmluZGVudCkgOiAnICAnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IG9wdFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRUYWdPYmplY3QodGFncywgaXRlbSkge1xuICAgIGlmIChpdGVtLnRhZykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRhZ3MuZmlsdGVyKHQgPT4gdC50YWcgPT09IGl0ZW0udGFnKTtcbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guZmluZCh0ID0+IHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdCkgPz8gbWF0Y2hbMF07XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgbGV0IG9iajtcbiAgICBpZiAoaXNTY2FsYXIoaXRlbSkpIHtcbiAgICAgICAgb2JqID0gaXRlbS52YWx1ZTtcbiAgICAgICAgbGV0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5Py4ob2JqKSk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0TWF0Y2ggPSBtYXRjaC5maWx0ZXIodCA9PiB0LnRlc3QpO1xuICAgICAgICAgICAgaWYgKHRlc3RNYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSA/PyBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iaiA9IGl0ZW07XG4gICAgICAgIHRhZ09iaiA9IHRhZ3MuZmluZCh0ID0+IHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9iaj8uY29uc3RydWN0b3I/Lm5hbWUgPz8gKG9iaiA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBvYmopO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhZyBub3QgcmVzb2x2ZWQgZm9yICR7bmFtZX0gdmFsdWVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ09iajtcbn1cbi8vIG5lZWRzIHRvIGJlIGNhbGxlZCBiZWZvcmUgdmFsdWUgc3RyaW5naWZpZXIgdG8gYWxsb3cgZm9yIGNpcmN1bGFyIGFuY2hvciByZWZzXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wcyhub2RlLCB0YWdPYmosIHsgYW5jaG9ycywgZG9jIH0pIHtcbiAgICBpZiAoIWRvYy5kaXJlY3RpdmVzKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcbiAgICBjb25zdCBhbmNob3IgPSAoaXNTY2FsYXIobm9kZSkgfHwgaXNDb2xsZWN0aW9uKG5vZGUpKSAmJiBub2RlLmFuY2hvcjtcbiAgICBpZiAoYW5jaG9yICYmIGFuY2hvcklzVmFsaWQoYW5jaG9yKSkge1xuICAgICAgICBhbmNob3JzLmFkZChhbmNob3IpO1xuICAgICAgICBwcm9wcy5wdXNoKGAmJHthbmNob3J9YCk7XG4gICAgfVxuICAgIGNvbnN0IHRhZyA9IG5vZGUudGFnID8/ICh0YWdPYmouZGVmYXVsdCA/IG51bGwgOiB0YWdPYmoudGFnKTtcbiAgICBpZiAodGFnKVxuICAgICAgICBwcm9wcy5wdXNoKGRvYy5kaXJlY3RpdmVzLnRhZ1N0cmluZyh0YWcpKTtcbiAgICByZXR1cm4gcHJvcHMuam9pbignICcpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgaWYgKGlzQWxpYXMoaXRlbSkpIHtcbiAgICAgICAgaWYgKGN0eC5kb2MuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCk7XG4gICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzPy5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgY2lyY3VsYXIgc3RydWN0dXJlIHdpdGhvdXQgYWxpYXMgbm9kZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzKVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMgPSBuZXcgU2V0KFtpdGVtXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXNvbHZlKGN0eC5kb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZSA9IGlzTm9kZShpdGVtKVxuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBjdHguZG9jLmNyZWF0ZU5vZGUoaXRlbSwgeyBvblRhZ09iajogbyA9PiAodGFnT2JqID0gbykgfSk7XG4gICAgdGFnT2JqID8/ICh0YWdPYmogPSBnZXRUYWdPYmplY3QoY3R4LmRvYy5zY2hlbWEudGFncywgbm9kZSkpO1xuICAgIGNvbnN0IHByb3BzID0gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCBjdHgpO1xuICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IChjdHguaW5kZW50QXRTdGFydCA/PyAwKSArIHByb3BzLmxlbmd0aCArIDE7XG4gICAgY29uc3Qgc3RyID0gdHlwZW9mIHRhZ09iai5zdHJpbmdpZnkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB0YWdPYmouc3RyaW5naWZ5KG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgOiBpc1NjYWxhcihub2RlKVxuICAgICAgICAgICAgPyBzdHJpbmdpZnlTdHJpbmcobm9kZSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBub2RlLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgaWYgKCFwcm9wcylcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICByZXR1cm4gaXNTY2FsYXIobm9kZSkgfHwgc3RyWzBdID09PSAneycgfHwgc3RyWzBdID09PSAnWydcbiAgICAgICAgPyBgJHtwcm9wc30gJHtzdHJ9YFxuICAgICAgICA6IGAke3Byb3BzfVxcbiR7Y3R4LmluZGVudH0ke3N0cn1gO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdHJpbmdpZnlDb250ZXh0LCBzdHJpbmdpZnkgfTtcbiIsICJpbXBvcnQgeyBpc0NvbGxlY3Rpb24sIGlzTm9kZSwgaXNTY2FsYXIsIGlzU2VxIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGxpbmVDb21tZW50LCBpbmRlbnRDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5UGFpcih7IGtleSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBhbGxOdWxsVmFsdWVzLCBkb2MsIGluZGVudCwgaW5kZW50U3RlcCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nLCBpbmRlbnRTZXEsIHNpbXBsZUtleXMgfSB9ID0gY3R4O1xuICAgIGxldCBrZXlDb21tZW50ID0gKGlzTm9kZShrZXkpICYmIGtleS5jb21tZW50KSB8fCBudWxsO1xuICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICAgIGlmIChrZXlDb21tZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24oa2V5KSB8fCAoIWlzTm9kZShrZXkpICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ1dpdGggc2ltcGxlIGtleXMsIGNvbGxlY3Rpb24gY2Fubm90IGJlIHVzZWQgYXMgYSBrZXkgdmFsdWUnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGV4cGxpY2l0S2V5ID0gIXNpbXBsZUtleXMgJiZcbiAgICAgICAgKCFrZXkgfHxcbiAgICAgICAgICAgIChrZXlDb21tZW50ICYmIHZhbHVlID09IG51bGwgJiYgIWN0eC5pbkZsb3cpIHx8XG4gICAgICAgICAgICBpc0NvbGxlY3Rpb24oa2V5KSB8fFxuICAgICAgICAgICAgKGlzU2NhbGFyKGtleSlcbiAgICAgICAgICAgICAgICA/IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfRk9MREVEIHx8IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQga2V5Q29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeShrZXksIGN0eCwgKCkgPT4gKGtleUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAhY3R4LmluRmxvdyAmJiBzdHIubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICBpZiAoc2ltcGxlS2V5cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywgc2luZ2xlIGxpbmUgc2NhbGFyIG11c3Qgbm90IHNwYW4gbW9yZSB0aGFuIDEwMjQgY2hhcmFjdGVycycpO1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmIChhbGxOdWxsVmFsdWVzIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb21tZW50RG9uZSAmJiBvbkNvbW1lbnQpXG4gICAgICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gc3RyID09PSAnJyA/ICc/JyA6IGV4cGxpY2l0S2V5ID8gYD8gJHtzdHJ9YCA6IHN0cjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgoYWxsTnVsbFZhbHVlcyAmJiAhc2ltcGxlS2V5cykgfHwgKHZhbHVlID09IG51bGwgJiYgZXhwbGljaXRLZXkpKSB7XG4gICAgICAgIHN0ciA9IGA/ICR7c3RyfWA7XG4gICAgICAgIGlmIChrZXlDb21tZW50ICYmICFrZXlDb21tZW50RG9uZSkge1xuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgaWYgKGtleUNvbW1lbnREb25lKVxuICAgICAgICBrZXlDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICAgICAgc3RyID0gYD8gJHtzdHJ9XFxuJHtpbmRlbnR9OmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBgJHtzdHJ9OmA7XG4gICAgICAgIGlmIChrZXlDb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgfVxuICAgIGxldCB2c2IsIHZjYiwgdmFsdWVDb21tZW50O1xuICAgIGlmIChpc05vZGUodmFsdWUpKSB7XG4gICAgICAgIHZzYiA9ICEhdmFsdWUuc3BhY2VCZWZvcmU7XG4gICAgICAgIHZjYiA9IHZhbHVlLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgIHZhbHVlQ29tbWVudCA9IHZhbHVlLmNvbW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2c2IgPSBmYWxzZTtcbiAgICAgICAgdmNiID0gbnVsbDtcbiAgICAgICAgdmFsdWVDb21tZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICB2YWx1ZSA9IGRvYy5jcmVhdGVOb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgY3R4LmltcGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAha2V5Q29tbWVudCAmJiBpc1NjYWxhcih2YWx1ZSkpXG4gICAgICAgIGN0eC5pbmRlbnRBdFN0YXJ0ID0gc3RyLmxlbmd0aCArIDE7XG4gICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgaWYgKCFpbmRlbnRTZXEgJiZcbiAgICAgICAgaW5kZW50U3RlcC5sZW5ndGggPj0gMiAmJlxuICAgICAgICAhY3R4LmluRmxvdyAmJlxuICAgICAgICAhZXhwbGljaXRLZXkgJiZcbiAgICAgICAgaXNTZXEodmFsdWUpICYmXG4gICAgICAgICF2YWx1ZS5mbG93ICYmXG4gICAgICAgICF2YWx1ZS50YWcgJiZcbiAgICAgICAgIXZhbHVlLmFuY2hvcikge1xuICAgICAgICAvLyBJZiBpbmRlbnRTZXEgPT09IGZhbHNlLCBjb25zaWRlciAnLSAnIGFzIHBhcnQgb2YgaW5kZW50YXRpb24gd2hlcmUgcG9zc2libGVcbiAgICAgICAgY3R4LmluZGVudCA9IGN0eC5pbmRlbnQuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVDb21tZW50RG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlU3RyID0gc3RyaW5naWZ5KHZhbHVlLCBjdHgsICgpID0+ICh2YWx1ZUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgbGV0IHdzID0gJyAnO1xuICAgIGlmIChrZXlDb21tZW50IHx8IHZzYiB8fCB2Y2IpIHtcbiAgICAgICAgd3MgPSB2c2IgPyAnXFxuJyA6ICcnO1xuICAgICAgICBpZiAodmNiKSB7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcodmNiKTtcbiAgICAgICAgICAgIHdzICs9IGBcXG4ke2luZGVudENvbW1lbnQoY3MsIGN0eC5pbmRlbnQpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlU3RyID09PSAnJyAmJiAhY3R4LmluRmxvdykge1xuICAgICAgICAgICAgaWYgKHdzID09PSAnXFxuJyAmJiB2YWx1ZUNvbW1lbnQpXG4gICAgICAgICAgICAgICAgd3MgPSAnXFxuXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdzICs9IGBcXG4ke2N0eC5pbmRlbnR9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghZXhwbGljaXRLZXkgJiYgaXNDb2xsZWN0aW9uKHZhbHVlKSkge1xuICAgICAgICBjb25zdCB2czAgPSB2YWx1ZVN0clswXTtcbiAgICAgICAgY29uc3QgbmwwID0gdmFsdWVTdHIuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIGNvbnN0IGhhc05ld2xpbmUgPSBubDAgIT09IC0xO1xuICAgICAgICBjb25zdCBmbG93ID0gY3R4LmluRmxvdyA/PyB2YWx1ZS5mbG93ID8/IHZhbHVlLml0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKGhhc05ld2xpbmUgfHwgIWZsb3cpIHtcbiAgICAgICAgICAgIGxldCBoYXNQcm9wc0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChoYXNOZXdsaW5lICYmICh2czAgPT09ICcmJyB8fCB2czAgPT09ICchJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3AwID0gdmFsdWVTdHIuaW5kZXhPZignICcpO1xuICAgICAgICAgICAgICAgIGlmICh2czAgPT09ICcmJyAmJlxuICAgICAgICAgICAgICAgICAgICBzcDAgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIHNwMCA8IG5sMCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVN0cltzcDAgKyAxXSA9PT0gJyEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwMCA9IHZhbHVlU3RyLmluZGV4T2YoJyAnLCBzcDAgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwMCA9PT0gLTEgfHwgbmwwIDwgc3AwKVxuICAgICAgICAgICAgICAgICAgICBoYXNQcm9wc0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNQcm9wc0xpbmUpXG4gICAgICAgICAgICAgICAgd3MgPSBgXFxuJHtjdHguaW5kZW50fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVTdHIgPT09ICcnIHx8IHZhbHVlU3RyWzBdID09PSAnXFxuJykge1xuICAgICAgICB3cyA9ICcnO1xuICAgIH1cbiAgICBzdHIgKz0gd3MgKyB2YWx1ZVN0cjtcbiAgICBpZiAoY3R4LmluRmxvdykge1xuICAgICAgICBpZiAodmFsdWVDb21tZW50RG9uZSAmJiBvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVDb21tZW50ICYmICF2YWx1ZUNvbW1lbnREb25lKSB7XG4gICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcodmFsdWVDb21tZW50KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcCkge1xuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlQYWlyIH07XG4iLCAiZnVuY3Rpb24gZGVidWcobG9nTGV2ZWwsIC4uLm1lc3NhZ2VzKSB7XG4gICAgaWYgKGxvZ0xldmVsID09PSAnZGVidWcnKVxuICAgICAgICBjb25zb2xlLmxvZyguLi5tZXNzYWdlcyk7XG59XG5mdW5jdGlvbiB3YXJuKGxvZ0xldmVsLCB3YXJuaW5nKSB7XG4gICAgaWYgKGxvZ0xldmVsID09PSAnZGVidWcnIHx8IGxvZ0xldmVsID09PSAnd2FybicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZGVidWcsIHdhcm4gfTtcbiIsICJpbXBvcnQgeyBpc1NjYWxhciwgaXNBbGlhcywgaXNTZXEsIGlzTWFwIH0gZnJvbSAnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuLy8gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIG1lcmdlIGtleSBpcyBhIHNpbmdsZSBtYXBwaW5nIG5vZGUsIGVhY2ggb2Zcbi8vIGl0cyBrZXkvdmFsdWUgcGFpcnMgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY3VycmVudCBtYXBwaW5nLCB1bmxlc3MgdGhlIGtleVxuLy8gYWxyZWFkeSBleGlzdHMgaW4gaXQuIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lcmdlIGtleSBpcyBhXG4vLyBzZXF1ZW5jZSwgdGhlbiB0aGlzIHNlcXVlbmNlIGlzIGV4cGVjdGVkIHRvIGNvbnRhaW4gbWFwcGluZyBub2RlcyBhbmQgZWFjaFxuLy8gb2YgdGhlc2Ugbm9kZXMgaXMgbWVyZ2VkIGluIHR1cm4gYWNjb3JkaW5nIHRvIGl0cyBvcmRlciBpbiB0aGUgc2VxdWVuY2UuXG4vLyBLZXlzIGluIG1hcHBpbmcgbm9kZXMgZWFybGllciBpbiB0aGUgc2VxdWVuY2Ugb3ZlcnJpZGUga2V5cyBzcGVjaWZpZWQgaW5cbi8vIGxhdGVyIG1hcHBpbmcgbm9kZXMuIC0tIGh0dHA6Ly95YW1sLm9yZy90eXBlL21lcmdlLmh0bWxcbmNvbnN0IE1FUkdFX0tFWSA9ICc8PCc7XG5jb25zdCBtZXJnZSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT09IE1FUkdFX0tFWSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyAmJiB2YWx1ZS5kZXNjcmlwdGlvbiA9PT0gTUVSR0VfS0VZKSxcbiAgICBkZWZhdWx0OiAna2V5JyxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsXG4gICAgdGVzdDogL148PCQvLFxuICAgIHJlc29sdmU6ICgpID0+IE9iamVjdC5hc3NpZ24obmV3IFNjYWxhcihTeW1ib2woTUVSR0VfS0VZKSksIHtcbiAgICAgICAgYWRkVG9KU01hcDogYWRkTWVyZ2VUb0pTTWFwXG4gICAgfSksXG4gICAgc3RyaW5naWZ5OiAoKSA9PiBNRVJHRV9LRVlcbn07XG5jb25zdCBpc01lcmdlS2V5ID0gKGN0eCwga2V5KSA9PiAobWVyZ2UuaWRlbnRpZnkoa2V5KSB8fFxuICAgIChpc1NjYWxhcihrZXkpICYmXG4gICAgICAgICgha2V5LnR5cGUgfHwga2V5LnR5cGUgPT09IFNjYWxhci5QTEFJTikgJiZcbiAgICAgICAgbWVyZ2UuaWRlbnRpZnkoa2V5LnZhbHVlKSkpICYmXG4gICAgY3R4Py5kb2Muc2NoZW1hLnRhZ3Muc29tZSh0YWcgPT4gdGFnLnRhZyA9PT0gbWVyZ2UudGFnICYmIHRhZy5kZWZhdWx0KTtcbmZ1bmN0aW9uIGFkZE1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9IGN0eCAmJiBpc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICBpZiAoaXNTZXEodmFsdWUpKVxuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIHZhbHVlLml0ZW1zKVxuICAgICAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgaXQpO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIHZhbHVlKVxuICAgICAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgaXQpO1xuICAgIGVsc2VcbiAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZShjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHggJiYgaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKCFpc01hcChzb3VyY2UpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzIG9yIG1hcCBhbGlhc2VzJyk7XG4gICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnQgeyBhZGRNZXJnZVRvSlNNYXAsIGlzTWVyZ2VLZXksIG1lcmdlIH07XG4iLCAiaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL2xvZy5qcyc7XG5pbXBvcnQgeyBpc01lcmdlS2V5LCBhZGRNZXJnZVRvSlNNYXAgfSBmcm9tICcuLi9zY2hlbWEveWFtbC0xLjEvbWVyZ2UuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuZnVuY3Rpb24gYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIHsga2V5LCB2YWx1ZSB9KSB7XG4gICAgaWYgKGlzTm9kZShrZXkpICYmIGtleS5hZGRUb0pTTWFwKVxuICAgICAgICBrZXkuYWRkVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpO1xuICAgIC8vIFRPRE86IFNob3VsZCBkcm9wIHRoaXMgc3BlY2lhbCBjYXNlIGZvciBiYXJlIDw8IGhhbmRsaW5nXG4gICAgZWxzZSBpZiAoaXNNZXJnZUtleShjdHgsIGtleSkpXG4gICAgICAgIGFkZE1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBqc0tleSA9IHRvSlMoa2V5LCAnJywgY3R4KTtcbiAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgbWFwLnNldChqc0tleSwgdG9KUyh2YWx1ZSwganNLZXksIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgbWFwLmFkZChqc0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdLZXkgPSBzdHJpbmdpZnlLZXkoa2V5LCBqc0tleSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGpzVmFsdWUgPSB0b0pTKHZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcClcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBzdHJpbmdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXBbc3RyaW5nS2V5XSA9IGpzVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXksIGpzS2V5LCBjdHgpIHtcbiAgICBpZiAoanNLZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBqc0tleSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBTdHJpbmcoanNLZXkpO1xuICAgIGlmIChpc05vZGUoa2V5KSAmJiBjdHg/LmRvYykge1xuICAgICAgICBjb25zdCBzdHJDdHggPSBjcmVhdGVTdHJpbmdpZnlDb250ZXh0KGN0eC5kb2MsIHt9KTtcbiAgICAgICAgc3RyQ3R4LmFuY2hvcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjdHguYW5jaG9ycy5rZXlzKCkpXG4gICAgICAgICAgICBzdHJDdHguYW5jaG9ycy5hZGQobm9kZS5hbmNob3IpO1xuICAgICAgICBzdHJDdHguaW5GbG93ID0gdHJ1ZTtcbiAgICAgICAgc3RyQ3R4LmluU3RyaW5naWZ5S2V5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RyS2V5ID0ga2V5LnRvU3RyaW5nKHN0ckN0eCk7XG4gICAgICAgIGlmICghY3R4Lm1hcEtleVdhcm5lZCkge1xuICAgICAgICAgICAgbGV0IGpzb25TdHIgPSBKU09OLnN0cmluZ2lmeShzdHJLZXkpO1xuICAgICAgICAgICAgaWYgKGpzb25TdHIubGVuZ3RoID4gNDApXG4gICAgICAgICAgICAgICAganNvblN0ciA9IGpzb25TdHIuc3Vic3RyaW5nKDAsIDM2KSArICcuLi5cIic7XG4gICAgICAgICAgICB3YXJuKGN0eC5kb2Mub3B0aW9ucy5sb2dMZXZlbCwgYEtleXMgd2l0aCBjb2xsZWN0aW9uIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkIGR1ZSB0byBKUyBPYmplY3QgcmVzdHJpY3Rpb25zOiAke2pzb25TdHJ9LiBTZXQgbWFwQXNNYXA6IHRydWUgdG8gdXNlIG9iamVjdCBrZXlzLmApO1xuICAgICAgICAgICAgY3R4Lm1hcEtleVdhcm5lZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cktleTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzS2V5KTtcbn1cblxuZXhwb3J0IHsgYWRkUGFpclRvSlNNYXAgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi4vZG9jL2NyZWF0ZU5vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5UGFpciB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlQYWlyLmpzJztcbmltcG9ydCB7IGFkZFBhaXJUb0pTTWFwIH0gZnJvbSAnLi9hZGRQYWlyVG9KU01hcC5qcyc7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIFBBSVIsIGlzTm9kZSB9IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGsgPSBjcmVhdGVOb2RlKGtleSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIGNvbnN0IHYgPSBjcmVhdGVOb2RlKHZhbHVlLCB1bmRlZmluZWQsIGN0eCk7XG4gICAgcmV0dXJuIG5ldyBQYWlyKGssIHYpO1xufVxuY2xhc3MgUGFpciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogUEFJUiB9KTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY2xvbmUoc2NoZW1hKSB7XG4gICAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpc05vZGUoa2V5KSlcbiAgICAgICAgICAgIGtleSA9IGtleS5jbG9uZShzY2hlbWEpO1xuICAgICAgICBpZiAoaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBjdHg/Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIHJldHVybiBhZGRQYWlyVG9KU01hcChjdHgsIHBhaXIsIHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgcmV0dXJuIGN0eD8uZG9jXG4gICAgICAgICAgICA/IHN0cmluZ2lmeVBhaXIodGhpcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfTtcbiIsICJpbXBvcnQgeyBpc05vZGUsIGlzUGFpciB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGxpbmVDb21tZW50LCBpbmRlbnRDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5Q29sbGVjdGlvbihjb2xsZWN0aW9uLCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmbG93ID0gY3R4LmluRmxvdyA/PyBjb2xsZWN0aW9uLmZsb3c7XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gZmxvdyA/IHN0cmluZ2lmeUZsb3dDb2xsZWN0aW9uIDogc3RyaW5naWZ5QmxvY2tDb2xsZWN0aW9uO1xuICAgIHJldHVybiBzdHJpbmdpZnkoY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbih7IGNvbW1lbnQsIGl0ZW1zIH0sIGN0eCwgeyBibG9ja0l0ZW1QcmVmaXgsIGZsb3dDaGFycywgaXRlbUluZGVudCwgb25DaG9tcEtlZXAsIG9uQ29tbWVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBpbmRlbnQ6IGl0ZW1JbmRlbnQsIHR5cGU6IG51bGwgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlOyAvLyBmbGFnIGZvciB0aGUgcHJlY2VkaW5nIG5vZGUncyBzdGF0dXNcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBsZXQgY29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChpc05vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgY2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGl0ZW0uY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlrID0gaXNOb2RlKGl0ZW0ua2V5KSA/IGl0ZW0ua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpaykge1xuICAgICAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKGNob21wS2VlcCAmJiBjb21tZW50KVxuICAgICAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxpbmVzLnB1c2goYmxvY2tJdGVtUHJlZml4ICsgc3RyKTtcbiAgICB9XG4gICAgbGV0IHN0cjtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0ciA9IGZsb3dDaGFycy5zdGFydCArIGZsb3dDaGFycy5lbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBsaW5lc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnR9JHtsaW5lfWAgOiAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBzdHIgKz0gJ1xcbicgKyBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbih7IGl0ZW1zIH0sIGN0eCwgeyBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBpbmRlbnRTdGVwLCBmbG93Q29sbGVjdGlvblBhZGRpbmc6IGZjUGFkZGluZywgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSA9IGN0eDtcbiAgICBpdGVtSW5kZW50ICs9IGluZGVudFN0ZXA7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwge1xuICAgICAgICBpbmRlbnQ6IGl0ZW1JbmRlbnQsXG4gICAgICAgIGluRmxvdzogdHJ1ZSxcbiAgICAgICAgdHlwZTogbnVsbFxuICAgIH0pO1xuICAgIGxldCByZXFOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IGxpbmVzQXRWYWx1ZSA9IDA7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaXRlbS5jb21tZW50QmVmb3JlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWsuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaWsuY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpay5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl2ID0gaXNOb2RlKGl0ZW0udmFsdWUpID8gaXRlbS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXYuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGl2LmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS52YWx1ZSA9PSBudWxsICYmIGlrPy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGlrLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpKTtcbiAgICAgICAgaWYgKGkgPCBpdGVtcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgc3RyICs9ICcsJztcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lICYmIChsaW5lcy5sZW5ndGggPiBsaW5lc0F0VmFsdWUgfHwgc3RyLmluY2x1ZGVzKCdcXG4nKSkpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgICAgICBsaW5lc0F0VmFsdWUgPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZmxvd0NoYXJzO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lcy5yZWR1Y2UoKHN1bSwgbGluZSkgPT4gc3VtICsgbGluZS5sZW5ndGggKyAyLCAyKTtcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSBjdHgub3B0aW9ucy5saW5lV2lkdGggPiAwICYmIGxlbiA+IGN0eC5vcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxTmV3bGluZSkge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHN0YXJ0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKVxuICAgICAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50U3RlcH0ke2luZGVudH0ke2xpbmV9YCA6ICdcXG4nO1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0cn1cXG4ke2luZGVudH0ke2VuZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0YXJ0fSR7ZmNQYWRkaW5nfSR7bGluZXMuam9pbignICcpfSR7ZmNQYWRkaW5nfSR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb21tZW50QmVmb3JlKHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9LCBsaW5lcywgY29tbWVudCwgY2hvbXBLZWVwKSB7XG4gICAgaWYgKGNvbW1lbnQgJiYgY2hvbXBLZWVwKVxuICAgICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBjb25zdCBpYyA9IGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhjb21tZW50KSwgaW5kZW50KTtcbiAgICAgICAgbGluZXMucHVzaChpYy50cmltU3RhcnQoKSk7IC8vIEF2b2lkIGRvdWJsZSBpbmRlbnQgb24gZmlyc3QgbGluZVxuICAgIH1cbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5Q29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5Q29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBhZGRQYWlyVG9KU01hcCB9IGZyb20gJy4vYWRkUGFpclRvSlNNYXAuanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBNQVAsIGlzUGFpciwgaXNTY2FsYXIgfSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfSBmcm9tICcuL1BhaXIuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXJWYWx1ZSB9IGZyb20gJy4vU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gZmluZFBhaXIoaXRlbXMsIGtleSkge1xuICAgIGNvbnN0IGsgPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGZvciAoY29uc3QgaXQgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKGlzUGFpcihpdCkpIHtcbiAgICAgICAgICAgIGlmIChpdC5rZXkgPT09IGtleSB8fCBpdC5rZXkgPT09IGspXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKGl0LmtleSkgJiYgaXQua2V5LnZhbHVlID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgWUFNTE1hcCBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIHN0YXRpYyBnZXQgdGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoTUFQLCBzY2hlbWEpO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2VuZXJpYyBjb2xsZWN0aW9uIHBhcnNpbmcgbWV0aG9kIHRoYXQgY2FuIGJlIGV4dGVuZGVkXG4gICAgICogdG8gb3RoZXIgbm9kZSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIFlBTUxNYXBcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsga2VlcFVuZGVmaW5lZCwgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWRkID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSAmJiAhcmVwbGFjZXIuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBrZWVwVW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG9iailcbiAgICAgICAgICAgICAgICBhZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKVxuICAgICAgICAgICAgICAgIGFkZChrZXksIG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5zb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWFwLml0ZW1zLnNvcnQoc2NoZW1hLnNvcnRNYXBFbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gSWYgbm90IHNldCBgdHJ1ZWAsIHVzaW5nIGEga2V5IHRoYXQgaXMgYWxyZWFkeSBpbiB0aGVcbiAgICAgKiAgIGNvbGxlY3Rpb24gd2lsbCB0aHJvdy4gT3RoZXJ3aXNlLCBvdmVyd3JpdGVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgKi9cbiAgICBhZGQocGFpciwgb3ZlcndyaXRlKSB7XG4gICAgICAgIGxldCBfcGFpcjtcbiAgICAgICAgaWYgKGlzUGFpcihwYWlyKSlcbiAgICAgICAgICAgIF9wYWlyID0gcGFpcjtcbiAgICAgICAgZWxzZSBpZiAoIXBhaXIgfHwgdHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8ICEoJ2tleScgaW4gcGFpcikpIHtcbiAgICAgICAgICAgIC8vIEluIFR5cGVTY3JpcHQsIHRoaXMgbmV2ZXIgaGFwcGVucy5cbiAgICAgICAgICAgIF9wYWlyID0gbmV3IFBhaXIocGFpciwgcGFpcj8udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9wYWlyID0gbmV3IFBhaXIocGFpci5rZXksIHBhaXIudmFsdWUpO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgX3BhaXIua2V5KTtcbiAgICAgICAgY29uc3Qgc29ydEVudHJpZXMgPSB0aGlzLnNjaGVtYT8uc29ydE1hcEVudHJpZXM7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke19wYWlyLmtleX0gYWxyZWFkeSBzZXRgKTtcbiAgICAgICAgICAgIC8vIEZvciBzY2FsYXJzLCBrZWVwIHRoZSBvbGQgbm9kZSAmIGl0cyBjb21tZW50cyBhbmQgYW5jaG9yc1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKHByZXYudmFsdWUpICYmIGlzU2NhbGFyVmFsdWUoX3BhaXIudmFsdWUpKVxuICAgICAgICAgICAgICAgIHByZXYudmFsdWUudmFsdWUgPSBfcGFpci52YWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc29ydEVudHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpdGVtID0+IHNvcnRFbnRyaWVzKF9wYWlyLCBpdGVtKSA8IDApO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgX3BhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKF9wYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKCFpdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0KSwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpdD8udmFsdWU7XG4gICAgICAgIHJldHVybiAoIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIobm9kZSkgPyBub2RlLnZhbHVlIDogbm9kZSkgPz8gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkKG5ldyBQYWlyKGtleSwgdmFsdWUpLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpXG4gICAgICogQHBhcmFtIHtDbGFzc30gVHlwZSAtIElmIHNldCwgZm9yY2VzIHRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIHR5cGVcbiAgICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUeXBlLCBNYXAsIG9yIE9iamVjdFxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgbWFwID0gVHlwZSA/IG5ldyBUeXBlKCkgOiBjdHg/Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIGlmIChjdHg/Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIWlzUGFpcihpdGVtKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcCBpdGVtcyBtdXN0IGFsbCBiZSBwYWlyczsgZm91bmQgJHtKU09OLnN0cmluZ2lmeShpdGVtKX0gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3R4LmFsbE51bGxWYWx1ZXMgJiYgdGhpcy5oYXNBbGxOdWxsVmFsdWVzKGZhbHNlKSlcbiAgICAgICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbih0aGlzLCBjdHgsIHtcbiAgICAgICAgICAgIGJsb2NrSXRlbVByZWZpeDogJycsXG4gICAgICAgICAgICBmbG93Q2hhcnM6IHsgc3RhcnQ6ICd7JywgZW5kOiAnfScgfSxcbiAgICAgICAgICAgIGl0ZW1JbmRlbnQ6IGN0eC5pbmRlbnQgfHwgJycsXG4gICAgICAgICAgICBvbkNob21wS2VlcCxcbiAgICAgICAgICAgIG9uQ29tbWVudFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFlBTUxNYXAsIGZpbmRQYWlyIH07XG4iLCAiaW1wb3J0IHsgaXNNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5cbmNvbnN0IG1hcCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnbWFwJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTE1hcCxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNNYXAobWFwKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGU6IChzY2hlbWEsIG9iaiwgY3R4KSA9PiBZQU1MTWFwLmZyb20oc2NoZW1hLCBvYmosIGN0eClcbn07XG5cbmV4cG9ydCB7IG1hcCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBTRVEsIGlzU2NhbGFyIH0gZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBpc1NjYWxhclZhbHVlIH0gZnJvbSAnLi9TY2FsYXIuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4vdG9KUy5qcyc7XG5cbmNsYXNzIFlBTUxTZXEgZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgICBzdGF0aWMgZ2V0IHRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJztcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKFNFUSwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBga2V5YCBtdXN0IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyIGZvciB0aGlzIHRvIHN1Y2NlZWQuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKGl0KSA/IGl0LnZhbHVlIDogaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIElmIGBrZXlgIGRvZXMgbm90IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgdmFsaWQgaW5kZXgsIG5vdCAke2tleX0uYCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmIChpc1NjYWxhcihwcmV2KSAmJiBpc1NjYWxhclZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIHByZXYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgY29uc3Qgc2VxID0gW107XG4gICAgICAgIGlmIChjdHg/Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKHNlcSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBzZXEucHVzaCh0b0pTKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbih0aGlzLCBjdHgsIHtcbiAgICAgICAgICAgIGJsb2NrSXRlbVByZWZpeDogJy0gJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ1snLCBlbmQ6ICddJyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogKGN0eC5pbmRlbnQgfHwgJycpICsgJyAgJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3Qgc2VxID0gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICAgICAgaWYgKG9iaiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGl0IG9mIG9iaikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gb2JqIGluc3RhbmNlb2YgU2V0ID8gaXQgOiBTdHJpbmcoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgaXQgPSByZXBsYWNlci5jYWxsKG9iaiwga2V5LCBpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKGNyZWF0ZU5vZGUoaXQsIHVuZGVmaW5lZCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc0l0ZW1JbmRleChrZXkpIHtcbiAgICBsZXQgaWR4ID0gaXNTY2FsYXIoa2V5KSA/IGtleS52YWx1ZSA6IGtleTtcbiAgICBpZiAoaWR4ICYmIHR5cGVvZiBpZHggPT09ICdzdHJpbmcnKVxuICAgICAgICBpZHggPSBOdW1iZXIoaWR4KTtcbiAgICByZXR1cm4gdHlwZW9mIGlkeCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihpZHgpICYmIGlkeCA+PSAwXG4gICAgICAgID8gaWR4XG4gICAgICAgIDogbnVsbDtcbn1cblxuZXhwb3J0IHsgWUFNTFNlcSB9O1xuIiwgImltcG9ydCB7IGlzU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuXG5jb25zdCBzZXEgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBub2RlQ2xhc3M6IFlBTUxTZXEsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgICByZXNvbHZlKHNlcSwgb25FcnJvcikge1xuICAgICAgICBpZiAoIWlzU2VxKHNlcSkpXG4gICAgICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIHNlcXVlbmNlIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH0sXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgb2JqLCBjdHgpID0+IFlBTUxTZXEuZnJvbShzY2hlbWEsIG9iaiwgY3R4KVxufTtcblxuZXhwb3J0IHsgc2VxIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IHN0cmluZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oeyBhY3R1YWxTdHJpbmc6IHRydWUgfSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IHN0cmluZyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmNvbnN0IG51bGxUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhcihudWxsKSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgc3RyaW5naWZ5OiAoeyBzb3VyY2UgfSwgY3R4KSA9PiB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiBudWxsVGFnLnRlc3QudGVzdChzb3VyY2UpXG4gICAgICAgID8gc291cmNlXG4gICAgICAgIDogY3R4Lm9wdGlvbnMubnVsbFN0clxufTtcblxuZXhwb3J0IHsgbnVsbFRhZyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmNvbnN0IGJvb2xUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgdGVzdDogL14oPzpbVHRdcnVlfFRSVUV8W0ZmXWFsc2V8RkFMU0UpJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IG5ldyBTY2FsYXIoc3RyWzBdID09PSAndCcgfHwgc3RyWzBdID09PSAnVCcpLFxuICAgIHN0cmluZ2lmeSh7IHNvdXJjZSwgdmFsdWUgfSwgY3R4KSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgYm9vbFRhZy50ZXN0LnRlc3Qoc291cmNlKSkge1xuICAgICAgICAgICAgY29uc3Qgc3YgPSBzb3VyY2VbMF0gPT09ICd0JyB8fCBzb3VyY2VbMF0gPT09ICdUJztcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gc3YpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgYm9vbFRhZyB9O1xuIiwgImZ1bmN0aW9uIHN0cmluZ2lmeU51bWJlcih7IGZvcm1hdCwgbWluRnJhY3Rpb25EaWdpdHMsIHRhZywgdmFsdWUgfSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKVxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBudW0gPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBOdW1iZXIodmFsdWUpO1xuICAgIGlmICghaXNGaW5pdGUobnVtKSlcbiAgICAgICAgcmV0dXJuIGlzTmFOKG51bSkgPyAnLm5hbicgOiBudW0gPCAwID8gJy0uaW5mJyA6ICcuaW5mJztcbiAgICBsZXQgbiA9IE9iamVjdC5pcyh2YWx1ZSwgLTApID8gJy0wJyA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoIWZvcm1hdCAmJlxuICAgICAgICBtaW5GcmFjdGlvbkRpZ2l0cyAmJlxuICAgICAgICAoIXRhZyB8fCB0YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcpICYmXG4gICAgICAgIC9eXFxkLy50ZXN0KG4pKSB7XG4gICAgICAgIGxldCBpID0gbi5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgaSA9IG4ubGVuZ3RoO1xuICAgICAgICAgICAgbiArPSAnLic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGQgPSBtaW5GcmFjdGlvbkRpZ2l0cyAtIChuLmxlbmd0aCAtIGkgLSAxKTtcbiAgICAgICAgd2hpbGUgKGQtLSA+IDApXG4gICAgICAgICAgICBuICs9ICcwJztcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeU51bWJlciB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5TnVtYmVyLmpzJztcblxuY29uc3QgZmxvYXROYU4gPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgdGVzdDogL14oPzpbLStdP1xcLig/OmluZnxJbmZ8SU5GKXxcXC5uYW58XFwuTmFOfFxcLk5BTikkLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gc3RyLnNsaWNlKC0zKS50b0xvd2VyQ2FzZSgpID09PSAnbmFuJ1xuICAgICAgICA/IE5hTlxuICAgICAgICA6IHN0clswXSA9PT0gJy0nXG4gICAgICAgICAgICA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICAgICAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBmbG9hdEV4cCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdFWFAnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rKD86XFwuWzAtOV0qKT8pW2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgICBzdHJpbmdpZnkobm9kZSkge1xuICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShudW0pID8gbnVtLnRvRXhwb25lbnRpYWwoKSA6IHN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICB9XG59O1xuY29uc3QgZmxvYXQgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgdGVzdDogL15bLStdPyg/OlxcLlswLTldK3xbMC05XStcXC5bMC05XSopJC8sXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIpKTtcbiAgICAgICAgY29uc3QgZG90ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdCAhPT0gLTEgJiYgc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgbm9kZS5taW5GcmFjdGlvbkRpZ2l0cyA9IHN0ci5sZW5ndGggLSBkb3QgLSAxO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnQgeyBmbG9hdCwgZmxvYXRFeHAsIGZsb2F0TmFOIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGludElkZW50aWZ5ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuY29uc3QgaW50UmVzb2x2ZSA9IChzdHIsIG9mZnNldCwgcmFkaXgsIHsgaW50QXNCaWdJbnQgfSkgPT4gKGludEFzQmlnSW50ID8gQmlnSW50KHN0cikgOiBwYXJzZUludChzdHIuc3Vic3RyaW5nKG9mZnNldCksIHJhZGl4KSk7XG5mdW5jdGlvbiBpbnRTdHJpbmdpZnkobm9kZSwgcmFkaXgsIHByZWZpeCkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgaWYgKGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwKVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRPY3QgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdPQ1QnLFxuICAgIHRlc3Q6IC9eMG9bMC03XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwbycpXG59O1xuY29uc3QgaW50ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgdGVzdDogL15bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAwLCAxMCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGludEhleCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDAsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ0hFWCcsXG4gICAgdGVzdDogL14weFswLTlhLWZBLUZdKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCAxNiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDE2LCAnMHgnKVxufTtcblxuZXhwb3J0IHsgaW50LCBpbnRIZXgsIGludE9jdCB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgbnVsbFRhZyB9IGZyb20gJy4uL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4uL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBib29sVGFnIH0gZnJvbSAnLi9ib29sLmpzJztcbmltcG9ydCB7IGZsb2F0TmFOLCBmbG9hdEV4cCwgZmxvYXQgfSBmcm9tICcuL2Zsb2F0LmpzJztcbmltcG9ydCB7IGludE9jdCwgaW50LCBpbnRIZXggfSBmcm9tICcuL2ludC5qcyc7XG5cbmNvbnN0IHNjaGVtYSA9IFtcbiAgICBtYXAsXG4gICAgc2VxLFxuICAgIHN0cmluZyxcbiAgICBudWxsVGFnLFxuICAgIGJvb2xUYWcsXG4gICAgaW50T2N0LFxuICAgIGludCxcbiAgICBpbnRIZXgsXG4gICAgZmxvYXROYU4sXG4gICAgZmxvYXRFeHAsXG4gICAgZmxvYXRcbl07XG5cbmV4cG9ydCB7IHNjaGVtYSB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4uL2NvbW1vbi9zZXEuanMnO1xuXG5mdW5jdGlvbiBpbnRJZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuY29uc3Qgc3RyaW5naWZ5SlNPTiA9ICh7IHZhbHVlIH0pID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbmNvbnN0IGpzb25TY2FsYXJzID0gW1xuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBzdHIsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgICAgICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhcihudWxsKSxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcsXG4gICAgICAgIHRlc3Q6IC9ebnVsbCQvLFxuICAgICAgICByZXNvbHZlOiAoKSA9PiBudWxsLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICAgICAgdGVzdDogL150cnVlJHxeZmFsc2UkLyxcbiAgICAgICAgcmVzb2x2ZTogc3RyID0+IHN0ciA9PT0gJ3RydWUnLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgICAgICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikkLyxcbiAgICAgICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIHsgaW50QXNCaWdJbnQgfSkgPT4gaW50QXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ciwgMTApLFxuICAgICAgICBzdHJpbmdpZnk6ICh7IHZhbHVlIH0pID0+IGludElkZW50aWZ5KHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICAgICAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopKD86XFwuWzAtOV0qKT8oPzpbZUVdWy0rXT9bMC05XSspPyQvLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gcGFyc2VGbG9hdChzdHIpLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9XG5dO1xuY29uc3QganNvbkVycm9yID0ge1xuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAnJyxcbiAgICB0ZXN0OiAvXi8sXG4gICAgcmVzb2x2ZShzdHIsIG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihgVW5yZXNvbHZlZCBwbGFpbiBzY2FsYXIgJHtKU09OLnN0cmluZ2lmeShzdHIpfWApO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5jb25zdCBzY2hlbWEgPSBbbWFwLCBzZXFdLmNvbmNhdChqc29uU2NhbGFycywganNvbkVycm9yKTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5jb25zdCBiaW5hcnkgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSwgLy8gQnVmZmVyIGluaGVyaXRzIGZyb20gVWludDhBcnJheVxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICovXG4gICAgcmVzb2x2ZShzcmMsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBPbiBJRSAxMSwgYXRvYigpIGNhbid0IGhhbmRsZSBuZXdsaW5lc1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gYXRvYihzcmMucmVwbGFjZSgvW1xcblxccl0vZywgJycpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb25FcnJvcignVGhpcyBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHJlYWRpbmcgYmluYXJ5IHRhZ3M7IGVpdGhlciBCdWZmZXIgb3IgYXRvYiBpcyByZXF1aXJlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RyaW5naWZ5KHsgY29tbWVudCwgdHlwZSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHZhbHVlOyAvLyBjaGVja2VkIGVhcmxpZXIgYnkgYmluYXJ5LmlkZW50aWZ5KClcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgICAgICBzdHIgPSBidG9hKHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgd3JpdGluZyBiaW5hcnkgdGFnczsgZWl0aGVyIEJ1ZmZlciBvciBidG9hIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA/PyAodHlwZSA9IFNjYWxhci5CTE9DS19MSVRFUkFMKTtcbiAgICAgICAgaWYgKHR5cGUgIT09IFNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IE1hdGgubWF4KGN0eC5vcHRpb25zLmxpbmVXaWR0aCAtIGN0eC5pbmRlbnQubGVuZ3RoLCBjdHgub3B0aW9ucy5taW5Db250ZW50V2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgbiA9IE1hdGguY2VpbChzdHIubGVuZ3RoIC8gbGluZVdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG8gPSAwOyBpIDwgbjsgKytpLCBvICs9IGxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICAgIGxpbmVzW2ldID0gc3RyLnN1YnN0cihvLCBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gbGluZXMuam9pbih0eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTCA/ICdcXG4nIDogJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5U3RyaW5nKHsgY29tbWVudCwgdHlwZSwgdmFsdWU6IHN0ciB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGJpbmFyeSB9O1xuIiwgImltcG9ydCB7IGlzU2VxLCBpc1BhaXIsIGlzTWFwIH0gZnJvbSAnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciwgUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZVBhaXJzKHNlcSwgb25FcnJvcikge1xuICAgIGlmIChpc1NlcShzZXEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHNlcS5pdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc01hcChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoJ0VhY2ggcGFpciBtdXN0IGhhdmUgaXRzIG93biBzZXF1ZW5jZSBpbmRpY2F0b3InKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0gaXRlbS5pdGVtc1swXSB8fCBuZXcgUGFpcihuZXcgU2NhbGFyKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBwYWlyLmtleS5jb21tZW50QmVmb3JlID0gcGFpci5rZXkuY29tbWVudEJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnRCZWZvcmV9XFxuJHtwYWlyLmtleS5jb21tZW50QmVmb3JlfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY24gPSBwYWlyLnZhbHVlID8/IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjbi5jb21tZW50ID0gY24uY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnR9XFxuJHtjbi5jb21tZW50fWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtID0gcGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcS5pdGVtc1tpXSA9IGlzUGFpcihpdGVtKSA/IGl0ZW0gOiBuZXcgUGFpcihpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgcmV0dXJuIHNlcTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBwYWlycyA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIFN0cmluZyhpKyspLCBpdCk7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0dXBsZSB3aXRoIG9uZSBrZXksIG5vdCAke2tleXMubGVuZ3RofSBrZXlzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWlycy5pdGVtcy5wdXNoKGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5jb25zdCBwYWlycyA9IHtcbiAgICBjb2xsZWN0aW9uOiAnc2VxJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZVBhaXJzLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZVBhaXJzXG59O1xuXG5leHBvcnQgeyBjcmVhdGVQYWlycywgcGFpcnMsIHJlc29sdmVQYWlycyB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBpc1BhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi4vLi4vbm9kZXMvdG9KUy5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUGFpcnMsIGNyZWF0ZVBhaXJzIH0gZnJvbSAnLi9wYWlycy5qcyc7XG5cbmNsYXNzIFlBTUxPTWFwIGV4dGVuZHMgWUFNTFNlcSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWRkID0gWUFNTE1hcC5wcm90b3R5cGUuYWRkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVsZXRlID0gWUFNTE1hcC5wcm90b3R5cGUuZGVsZXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0ID0gWUFNTE1hcC5wcm90b3R5cGUuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFzID0gWUFNTE1hcC5wcm90b3R5cGUuaGFzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0ID0gWUFNTE1hcC5wcm90b3R5cGUuc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGFnID0gWUFNTE9NYXAudGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBgY3R4YCBpcyBnaXZlbiwgdGhlIHJldHVybiB0eXBlIGlzIGFjdHVhbGx5IGBNYXA8dW5rbm93biwgdW5rbm93bj5gLFxuICAgICAqIGJ1dCBUeXBlU2NyaXB0IHdvbid0IGFsbG93IHdpZGVuaW5nIHRoZSBzaWduYXR1cmUgb2YgYSBjaGlsZCBtZXRob2QuXG4gICAgICovXG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBzdXBlci50b0pTT04oXyk7XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGN0eD8ub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUobWFwKTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGxldCBrZXksIHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUGFpcihwYWlyKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHRvSlMocGFpci5rZXksICcnLCBjdHgpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9KUyhwYWlyLnZhbHVlLCBrZXksIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0b0pTKHBhaXIsICcnLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzJyk7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlycyA9IGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCk7XG4gICAgICAgIGNvbnN0IG9tYXAgPSBuZXcgdGhpcygpO1xuICAgICAgICBvbWFwLml0ZW1zID0gcGFpcnMuaXRlbXM7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbn1cbllBTUxPTWFwLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJztcbmNvbnN0IG9tYXAgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgTWFwLFxuICAgIG5vZGVDbGFzczogWUFNTE9NYXAsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsXG4gICAgcmVzb2x2ZShzZXEsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKTtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSB9IG9mIHBhaXJzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoYE9yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzOiAke2tleS52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5LZXlzLnB1c2goa2V5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxPTWFwKCksIHBhaXJzKTtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGU6IChzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpID0+IFlBTUxPTWFwLmZyb20oc2NoZW1hLCBpdGVyYWJsZSwgY3R4KVxufTtcblxuZXhwb3J0IHsgWUFNTE9NYXAsIG9tYXAgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5mdW5jdGlvbiBib29sU3RyaW5naWZ5KHsgdmFsdWUsIHNvdXJjZSB9LCBjdHgpIHtcbiAgICBjb25zdCBib29sT2JqID0gdmFsdWUgPyB0cnVlVGFnIDogZmFsc2VUYWc7XG4gICAgaWYgKHNvdXJjZSAmJiBib29sT2JqLnRlc3QudGVzdChzb3VyY2UpKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIHJldHVybiB2YWx1ZSA/IGN0eC5vcHRpb25zLnRydWVTdHIgOiBjdHgub3B0aW9ucy5mYWxzZVN0cjtcbn1cbmNvbnN0IHRydWVUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSB0cnVlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgdGVzdDogL14oPzpZfHl8W1l5XWVzfFlFU3xbVHRdcnVlfFRSVUV8W09vXW58T04pJC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gbmV3IFNjYWxhcih0cnVlKSxcbiAgICBzdHJpbmdpZnk6IGJvb2xTdHJpbmdpZnlcbn07XG5jb25zdCBmYWxzZVRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT09IGZhbHNlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgdGVzdDogL14oPzpOfG58W05uXW98Tk98W0ZmXWFsc2V8RkFMU0V8W09vXWZmfE9GRikkLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyKGZhbHNlKSxcbiAgICBzdHJpbmdpZnk6IGJvb2xTdHJpbmdpZnlcbn07XG5cbmV4cG9ydCB7IGZhbHNlVGFnLCB0cnVlVGFnIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXig/OlstK10/XFwuKD86aW5mfEluZnxJTkYpfFxcLm5hbnxcXC5OYU58XFwuTkFOKSQvLFxuICAgIHJlc29sdmU6IChzdHIpID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgZmxvYXRFeHAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnRVhQJyxcbiAgICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT8oPzpcXC5bMC05X10qKT9bZUVdWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiAoc3RyKSA9PiBwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csICcnKSksXG4gICAgc3RyaW5naWZ5KG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUobnVtKSA/IG51bS50b0V4cG9uZW50aWFsKCkgOiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpbMC05XVswLTlfXSopP1xcLlswLTlfXSokLyxcbiAgICByZXNvbHZlKHN0cikge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFNjYWxhcihwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csICcnKSkpO1xuICAgICAgICBjb25zdCBkb3QgPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IHN0ci5zdWJzdHJpbmcoZG90ICsgMSkucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICAgICAgICBpZiAoZltmLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICAgICAgbm9kZS5taW5GcmFjdGlvbkRpZ2l0cyA9IGYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5cbmV4cG9ydCB7IGZsb2F0LCBmbG9hdEV4cCwgZmxvYXROYU4gfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5TnVtYmVyLmpzJztcblxuY29uc3QgaW50SWRlbnRpZnkgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5mdW5jdGlvbiBpbnRSZXNvbHZlKHN0ciwgb2Zmc2V0LCByYWRpeCwgeyBpbnRBc0JpZ0ludCB9KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBpZiAoc2lnbiA9PT0gJy0nIHx8IHNpZ24gPT09ICcrJylcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZyhvZmZzZXQpLnJlcGxhY2UoL18vZywgJycpO1xuICAgIGlmIChpbnRBc0JpZ0ludCkge1xuICAgICAgICBzd2l0Y2ggKHJhZGl4KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBiJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMG8ke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMHgke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSBCaWdJbnQoc3RyKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gPT09ICctJyA/IEJpZ0ludCgtMSkgKiBuIDogbjtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBhcnNlSW50KHN0ciwgcmFkaXgpO1xuICAgIHJldHVybiBzaWduID09PSAnLScgPyAtMSAqIG4gOiBuO1xufVxuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gJy0nICsgcHJlZml4ICsgc3RyLnN1YnN0cigxKSA6IHByZWZpeCArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlcihub2RlKTtcbn1cbmNvbnN0IGludEJpbiA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ0JJTicsXG4gICAgdGVzdDogL15bLStdPzBiWzAtMV9dKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCAyLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMiwgJzBiJylcbn07XG5jb25zdCBpbnRPY3QgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdPQ1QnLFxuICAgIHRlc3Q6IC9eWy0rXT8wWzAtN19dKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAxLCA4LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgOCwgJzAnKVxufTtcbmNvbnN0IGludCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XVswLTlfXSokLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMCwgMTAsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eWy0rXT8weFswLTlhLWZBLUZfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydCB7IGludCwgaW50QmluLCBpbnRIZXgsIGludE9jdCB9O1xuIiwgImltcG9ydCB7IGlzTWFwLCBpc1BhaXIsIGlzU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgUGFpciwgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcblxuY2xhc3MgWUFNTFNldCBleHRlbmRzIFlBTUxNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIH1cbiAgICBhZGQoa2V5KSB7XG4gICAgICAgIGxldCBwYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKGtleSkpXG4gICAgICAgICAgICBwYWlyID0ga2V5O1xuICAgICAgICBlbHNlIGlmIChrZXkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAna2V5JyBpbiBrZXkgJiZcbiAgICAgICAgICAgICd2YWx1ZScgaW4ga2V5ICYmXG4gICAgICAgICAgICBrZXkudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIoa2V5LmtleSwgbnVsbCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhaXIgPSBuZXcgUGFpcihrZXksIG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgICAgICBpZiAoIXByZXYpXG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGBrZWVwUGFpcmAgaXMgYHRydWVgLCByZXR1cm5zIHRoZSBQYWlyIG1hdGNoaW5nIGBrZXlgLlxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhhdCBQYWlyJ3Mga2V5LlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBQYWlyKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICByZXR1cm4gIWtlZXBQYWlyICYmIGlzUGFpcihwYWlyKVxuICAgICAgICAgICAgPyBpc1NjYWxhcihwYWlyLmtleSlcbiAgICAgICAgICAgICAgICA/IHBhaXIua2V5LnZhbHVlXG4gICAgICAgICAgICAgICAgOiBwYWlyLmtleVxuICAgICAgICAgICAgOiBwYWlyO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4gdmFsdWUgZm9yIHNldChrZXksIHZhbHVlKSBpbiBhIFlBTUwgc2V0LCBub3QgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICBpZiAocHJldiAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihwcmV2KSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXByZXYgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgUGFpcihrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIHJldHVybiBzdXBlci50b0pTT04oXywgY3R4LCBTZXQpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGFsbE51bGxWYWx1ZXM6IHRydWUgfSksIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyB0aGlzKHNjaGVtYSk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXJhYmxlKSlcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKGl0ZXJhYmxlLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldC5pdGVtcy5wdXNoKGNyZWF0ZVBhaXIodmFsdWUsIG51bGwsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbn1cbllBTUxTZXQudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc7XG5jb25zdCBzZXQgPSB7XG4gICAgY29sbGVjdGlvbjogJ21hcCcsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgU2V0LFxuICAgIG5vZGVDbGFzczogWUFNTFNldCxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLFxuICAgIGNyZWF0ZU5vZGU6IChzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpID0+IFlBTUxTZXQuZnJvbShzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChpc01hcChtYXApKSB7XG4gICAgICAgICAgICBpZiAobWFwLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxTZXQoKSwgbWFwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBZQU1MU2V0LCBzZXQgfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5TnVtYmVyLmpzJztcblxuLyoqIEludGVybmFsIHR5cGVzIGhhbmRsZSBiaWdpbnQgYXMgbnVtYmVyLCBiZWNhdXNlIFRTIGNhbid0IGZpZ3VyZSBpdCBvdXQuICovXG5mdW5jdGlvbiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgYXNCaWdJbnQpIHtcbiAgICBjb25zdCBzaWduID0gc3RyWzBdO1xuICAgIGNvbnN0IHBhcnRzID0gc2lnbiA9PT0gJy0nIHx8IHNpZ24gPT09ICcrJyA/IHN0ci5zdWJzdHJpbmcoMSkgOiBzdHI7XG4gICAgY29uc3QgbnVtID0gKG4pID0+IGFzQmlnSW50ID8gQmlnSW50KG4pIDogTnVtYmVyKG4pO1xuICAgIGNvbnN0IHJlcyA9IHBhcnRzXG4gICAgICAgIC5yZXBsYWNlKC9fL2csICcnKVxuICAgICAgICAuc3BsaXQoJzonKVxuICAgICAgICAucmVkdWNlKChyZXMsIHApID0+IHJlcyAqIG51bSg2MCkgKyBudW0ocCksIG51bSgwKSk7XG4gICAgcmV0dXJuIChzaWduID09PSAnLScgPyBudW0oLTEpICogcmVzIDogcmVzKTtcbn1cbi8qKlxuICogaGhoaDptbTpzcy5zc3NcbiAqXG4gKiBJbnRlcm5hbCB0eXBlcyBoYW5kbGUgYmlnaW50IGFzIG51bWJlciwgYmVjYXVzZSBUUyBjYW4ndCBmaWd1cmUgaXQgb3V0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTZXhhZ2VzaW1hbChub2RlKSB7XG4gICAgbGV0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgbGV0IG51bSA9IChuKSA9PiBuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKVxuICAgICAgICBudW0gPSBuID0+IEJpZ0ludChuKTtcbiAgICBlbHNlIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICBsZXQgc2lnbiA9ICcnO1xuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgdmFsdWUgKj0gbnVtKC0xKTtcbiAgICB9XG4gICAgY29uc3QgXzYwID0gbnVtKDYwKTtcbiAgICBjb25zdCBwYXJ0cyA9IFt2YWx1ZSAlIF82MF07IC8vIHNlY29uZHMsIGluY2x1ZGluZyBtc1xuICAgIGlmICh2YWx1ZSA8IDYwKSB7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQoMCk7IC8vIGF0IGxlYXN0IG9uZSA6IGlzIHJlcXVpcmVkXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAtIHBhcnRzWzBdKSAvIF82MDtcbiAgICAgICAgcGFydHMudW5zaGlmdCh2YWx1ZSAlIF82MCk7IC8vIG1pbnV0ZXNcbiAgICAgICAgaWYgKHZhbHVlID49IDYwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAtIHBhcnRzWzBdKSAvIF82MDtcbiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUpOyAvLyBob3Vyc1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoc2lnbiArXG4gICAgICAgIHBhcnRzXG4gICAgICAgICAgICAubWFwKG4gPT4gU3RyaW5nKG4pLnBhZFN0YXJ0KDIsICcwJykpXG4gICAgICAgICAgICAuam9pbignOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvMDAwMDAwXFxkKiQvLCAnJykgLy8gJSA2MCBtYXkgaW50cm9kdWNlIGVycm9yXG4gICAgKTtcbn1cbmNvbnN0IGludFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ1RJTUUnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCB7IGludEFzQmlnSW50IH0pID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBpbnRBc0JpZ0ludCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IGZsb2F0VGltZSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKStcXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBmYWxzZSksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IHRpbWVzdGFtcCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJyxcbiAgICAvLyBJZiB0aGUgdGltZSB6b25lIGlzIG9taXR0ZWQsIHRoZSB0aW1lc3RhbXAgaXMgYXNzdW1lZCB0byBiZSBzcGVjaWZpZWQgaW4gVVRDLiBUaGUgdGltZSBwYXJ0XG4gICAgLy8gbWF5IGJlIG9taXR0ZWQgYWx0b2dldGhlciwgcmVzdWx0aW5nIGluIGEgZGF0ZSBmb3JtYXQuIEluIHN1Y2ggYSBjYXNlLCB0aGUgdGltZSBwYXJ0IGlzXG4gICAgLy8gYXNzdW1lZCB0byBiZSAwMDowMDowMFogKHN0YXJ0IG9mIGRheSwgVVRDKS5cbiAgICB0ZXN0OiBSZWdFeHAoJ14oWzAtOV17NH0pLShbMC05XXsxLDJ9KS0oWzAtOV17MSwyfSknICsgLy8gWVlZWS1NbS1EZFxuICAgICAgICAnKD86JyArIC8vIHRpbWUgaXMgb3B0aW9uYWxcbiAgICAgICAgJyg/OnR8VHxbIFxcXFx0XSspJyArIC8vIHQgfCBUIHwgd2hpdGVzcGFjZVxuICAgICAgICAnKFswLTldezEsMn0pOihbMC05XXsxLDJ9KTooWzAtOV17MSwyfShcXFxcLlswLTldKyk/KScgKyAvLyBIaDpNbTpTcyguc3MpP1xuICAgICAgICAnKD86WyBcXFxcdF0qKFp8Wy0rXVswMTJdP1swLTldKD86OlswLTldezJ9KT8pKT8nICsgLy8gWiB8ICs1IHwgLTAzOjMwXG4gICAgICAgICcpPyQnKSxcbiAgICByZXNvbHZlKHN0cikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0ci5tYXRjaCh0aW1lc3RhbXAudGVzdCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyEhdGltZXN0YW1wIGV4cGVjdHMgYSBkYXRlLCBzdGFydGluZyB3aXRoIHl5eXktbW0tZGQnKTtcbiAgICAgICAgY29uc3QgWywgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRdID0gbWF0Y2gubWFwKE51bWJlcik7XG4gICAgICAgIGNvbnN0IG1pbGxpc2VjID0gbWF0Y2hbN10gPyBOdW1iZXIoKG1hdGNoWzddICsgJzAwJykuc3Vic3RyKDEsIDMpKSA6IDA7XG4gICAgICAgIGxldCBkYXRlID0gRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIgfHwgMCwgbWludXRlIHx8IDAsIHNlY29uZCB8fCAwLCBtaWxsaXNlYyk7XG4gICAgICAgIGNvbnN0IHR6ID0gbWF0Y2hbOF07XG4gICAgICAgIGlmICh0eiAmJiB0eiAhPT0gJ1onKSB7XG4gICAgICAgICAgICBsZXQgZCA9IHBhcnNlU2V4YWdlc2ltYWwodHosIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkKSA8IDMwKVxuICAgICAgICAgICAgICAgIGQgKj0gNjA7XG4gICAgICAgICAgICBkYXRlIC09IDYwMDAwICogZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6ICh7IHZhbHVlIH0pID0+IHZhbHVlPy50b0lTT1N0cmluZygpLnJlcGxhY2UoLyhUMDA6MDA6MDApP1xcLjAwMFokLywgJycpID8/ICcnXG59O1xuXG5leHBvcnQgeyBmbG9hdFRpbWUsIGludFRpbWUsIHRpbWVzdGFtcCB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgbnVsbFRhZyB9IGZyb20gJy4uL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4uL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBiaW5hcnkgfSBmcm9tICcuL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyB0cnVlVGFnLCBmYWxzZVRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRCaW4sIGludE9jdCwgaW50LCBpbnRIZXggfSBmcm9tICcuL2ludC5qcyc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJy4vbWVyZ2UuanMnO1xuaW1wb3J0IHsgb21hcCB9IGZyb20gJy4vb21hcC5qcyc7XG5pbXBvcnQgeyBwYWlycyB9IGZyb20gJy4vcGFpcnMuanMnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi9zZXQuanMnO1xuaW1wb3J0IHsgaW50VGltZSwgZmxvYXRUaW1lLCB0aW1lc3RhbXAgfSBmcm9tICcuL3RpbWVzdGFtcC5qcyc7XG5cbmNvbnN0IHNjaGVtYSA9IFtcbiAgICBtYXAsXG4gICAgc2VxLFxuICAgIHN0cmluZyxcbiAgICBudWxsVGFnLFxuICAgIHRydWVUYWcsXG4gICAgZmFsc2VUYWcsXG4gICAgaW50QmluLFxuICAgIGludE9jdCxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0LFxuICAgIGJpbmFyeSxcbiAgICBtZXJnZSxcbiAgICBvbWFwLFxuICAgIHBhaXJzLFxuICAgIHNldCxcbiAgICBpbnRUaW1lLFxuICAgIGZsb2F0VGltZSxcbiAgICB0aW1lc3RhbXBcbl07XG5cbmV4cG9ydCB7IHNjaGVtYSB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBudWxsVGFnIH0gZnJvbSAnLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGJvb2xUYWcgfSBmcm9tICcuL2NvcmUvYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9jb3JlL2Zsb2F0LmpzJztcbmltcG9ydCB7IGludE9jdCwgaW50SGV4LCBpbnQgfSBmcm9tICcuL2NvcmUvaW50LmpzJztcbmltcG9ydCB7IHNjaGVtYSB9IGZyb20gJy4vY29yZS9zY2hlbWEuanMnO1xuaW1wb3J0IHsgc2NoZW1hIGFzIHNjaGVtYSQxIH0gZnJvbSAnLi9qc29uL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBiaW5hcnkgfSBmcm9tICcuL3lhbWwtMS4xL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJy4veWFtbC0xLjEvbWVyZ2UuanMnO1xuaW1wb3J0IHsgb21hcCB9IGZyb20gJy4veWFtbC0xLjEvb21hcC5qcyc7XG5pbXBvcnQgeyBwYWlycyB9IGZyb20gJy4veWFtbC0xLjEvcGFpcnMuanMnO1xuaW1wb3J0IHsgc2NoZW1hIGFzIHNjaGVtYSQyIH0gZnJvbSAnLi95YW1sLTEuMS9zY2hlbWEuanMnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi95YW1sLTEuMS9zZXQuanMnO1xuaW1wb3J0IHsgdGltZXN0YW1wLCBpbnRUaW1lLCBmbG9hdFRpbWUgfSBmcm9tICcuL3lhbWwtMS4xL3RpbWVzdGFtcC5qcyc7XG5cbmNvbnN0IHNjaGVtYXMgPSBuZXcgTWFwKFtcbiAgICBbJ2NvcmUnLCBzY2hlbWFdLFxuICAgIFsnZmFpbHNhZmUnLCBbbWFwLCBzZXEsIHN0cmluZ11dLFxuICAgIFsnanNvbicsIHNjaGVtYSQxXSxcbiAgICBbJ3lhbWwxMScsIHNjaGVtYSQyXSxcbiAgICBbJ3lhbWwtMS4xJywgc2NoZW1hJDJdXG5dKTtcbmNvbnN0IHRhZ3NCeU5hbWUgPSB7XG4gICAgYmluYXJ5LFxuICAgIGJvb2w6IGJvb2xUYWcsXG4gICAgZmxvYXQsXG4gICAgZmxvYXRFeHAsXG4gICAgZmxvYXROYU4sXG4gICAgZmxvYXRUaW1lLFxuICAgIGludCxcbiAgICBpbnRIZXgsXG4gICAgaW50T2N0LFxuICAgIGludFRpbWUsXG4gICAgbWFwLFxuICAgIG1lcmdlLFxuICAgIG51bGw6IG51bGxUYWcsXG4gICAgb21hcCxcbiAgICBwYWlycyxcbiAgICBzZXEsXG4gICAgc2V0LFxuICAgIHRpbWVzdGFtcFxufTtcbmNvbnN0IGNvcmVLbm93blRhZ3MgPSB7XG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeSc6IGJpbmFyeSxcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnOiBtZXJnZSxcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6b21hcCc6IG9tYXAsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJzogcGFpcnMsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc6IHNldCxcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJzogdGltZXN0YW1wXG59O1xuZnVuY3Rpb24gZ2V0VGFncyhjdXN0b21UYWdzLCBzY2hlbWFOYW1lLCBhZGRNZXJnZVRhZykge1xuICAgIGNvbnN0IHNjaGVtYVRhZ3MgPSBzY2hlbWFzLmdldChzY2hlbWFOYW1lKTtcbiAgICBpZiAoc2NoZW1hVGFncyAmJiAhY3VzdG9tVGFncykge1xuICAgICAgICByZXR1cm4gYWRkTWVyZ2VUYWcgJiYgIXNjaGVtYVRhZ3MuaW5jbHVkZXMobWVyZ2UpXG4gICAgICAgICAgICA/IHNjaGVtYVRhZ3MuY29uY2F0KG1lcmdlKVxuICAgICAgICAgICAgOiBzY2hlbWFUYWdzLnNsaWNlKCk7XG4gICAgfVxuICAgIGxldCB0YWdzID0gc2NoZW1hVGFncztcbiAgICBpZiAoIXRhZ3MpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VzdG9tVGFncykpXG4gICAgICAgICAgICB0YWdzID0gW107XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20oc2NoZW1hcy5rZXlzKCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4ga2V5ICE9PSAneWFtbDExJylcbiAgICAgICAgICAgICAgICAubWFwKGtleSA9PiBKU09OLnN0cmluZ2lmeShrZXkpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNjaGVtYSBcIiR7c2NoZW1hTmFtZX1cIjsgdXNlIG9uZSBvZiAke2tleXN9IG9yIGRlZmluZSBjdXN0b21UYWdzIGFycmF5YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VzdG9tVGFncykpIHtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgY3VzdG9tVGFncylcbiAgICAgICAgICAgIHRhZ3MgPSB0YWdzLmNvbmNhdCh0YWcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY3VzdG9tVGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0YWdzID0gY3VzdG9tVGFncyh0YWdzLnNsaWNlKCkpO1xuICAgIH1cbiAgICBpZiAoYWRkTWVyZ2VUYWcpXG4gICAgICAgIHRhZ3MgPSB0YWdzLmNvbmNhdChtZXJnZSk7XG4gICAgcmV0dXJuIHRhZ3MucmVkdWNlKCh0YWdzLCB0YWcpID0+IHtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gdHlwZW9mIHRhZyA9PT0gJ3N0cmluZycgPyB0YWdzQnlOYW1lW3RhZ10gOiB0YWc7XG4gICAgICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gSlNPTi5zdHJpbmdpZnkodGFnKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YWdzQnlOYW1lKVxuICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY3VzdG9tIHRhZyAke3RhZ05hbWV9OyB1c2Ugb25lIG9mICR7a2V5c31gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhZ3MuaW5jbHVkZXModGFnT2JqKSlcbiAgICAgICAgICAgIHRhZ3MucHVzaCh0YWdPYmopO1xuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9LCBbXSk7XG59XG5cbmV4cG9ydCB7IGNvcmVLbm93blRhZ3MsIGdldFRhZ3MgfTtcbiIsICJpbXBvcnQgeyBNQVAsIFNDQUxBUiwgU0VRIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgZ2V0VGFncywgY29yZUtub3duVGFncyB9IGZyb20gJy4vdGFncy5qcyc7XG5cbmNvbnN0IHNvcnRNYXBFbnRyaWVzQnlLZXkgPSAoYSwgYikgPT4gYS5rZXkgPCBiLmtleSA/IC0xIDogYS5rZXkgPiBiLmtleSA/IDEgOiAwO1xuY2xhc3MgU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbXBhdCwgY3VzdG9tVGFncywgbWVyZ2UsIHJlc29sdmVLbm93blRhZ3MsIHNjaGVtYSwgc29ydE1hcEVudHJpZXMsIHRvU3RyaW5nRGVmYXVsdHMgfSkge1xuICAgICAgICB0aGlzLmNvbXBhdCA9IEFycmF5LmlzQXJyYXkoY29tcGF0KVxuICAgICAgICAgICAgPyBnZXRUYWdzKGNvbXBhdCwgJ2NvbXBhdCcpXG4gICAgICAgICAgICA6IGNvbXBhdFxuICAgICAgICAgICAgICAgID8gZ2V0VGFncyhudWxsLCBjb21wYXQpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB0aGlzLm5hbWUgPSAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycgJiYgc2NoZW1hKSB8fCAnY29yZSc7XG4gICAgICAgIHRoaXMua25vd25UYWdzID0gcmVzb2x2ZUtub3duVGFncyA/IGNvcmVLbm93blRhZ3MgOiB7fTtcbiAgICAgICAgdGhpcy50YWdzID0gZ2V0VGFncyhjdXN0b21UYWdzLCB0aGlzLm5hbWUsIG1lcmdlKTtcbiAgICAgICAgdGhpcy50b1N0cmluZ09wdGlvbnMgPSB0b1N0cmluZ0RlZmF1bHRzID8/IG51bGw7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBNQVAsIHsgdmFsdWU6IG1hcCB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNDQUxBUiwgeyB2YWx1ZTogc3RyaW5nIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU0VRLCB7IHZhbHVlOiBzZXEgfSk7XG4gICAgICAgIC8vIFVzZWQgYnkgY3JlYXRlTWFwKClcbiAgICAgICAgdGhpcy5zb3J0TWFwRW50cmllcyA9XG4gICAgICAgICAgICB0eXBlb2Ygc29ydE1hcEVudHJpZXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHNvcnRNYXBFbnRyaWVzXG4gICAgICAgICAgICAgICAgOiBzb3J0TWFwRW50cmllcyA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICA/IHNvcnRNYXBFbnRyaWVzQnlLZXlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hLnByb3RvdHlwZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGhpcykpO1xuICAgICAgICBjb3B5LnRhZ3MgPSB0aGlzLnRhZ3Muc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBTY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdpZnlDb250ZXh0LCBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBpbmRlbnRDb21tZW50LCBsaW5lQ29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgPT09IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcyAhPT0gZmFsc2UgJiYgZG9jLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyID0gZG9jLmRpcmVjdGl2ZXMudG9TdHJpbmcoZG9jKTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQpXG4gICAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgIGxpbmVzLnB1c2goJy0tLScpO1xuICAgIGNvbnN0IGN0eCA9IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKTtcbiAgICBjb25zdCB7IGNvbW1lbnRTdHJpbmcgfSA9IGN0eC5vcHRpb25zO1xuICAgIGlmIChkb2MuY29tbWVudEJlZm9yZSkge1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgbGluZXMudW5zaGlmdCgnJyk7XG4gICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyhkb2MuY29tbWVudEJlZm9yZSk7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQoaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICB9XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50Q29tbWVudCA9IG51bGw7XG4gICAgaWYgKGRvYy5jb250ZW50cykge1xuICAgICAgICBpZiAoaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuc3BhY2VCZWZvcmUgJiYgaGFzRGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyhkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChpbmRlbnRDb21tZW50KGNzLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdG9wLWxldmVsIGJsb2NrIHNjYWxhcnMgbmVlZCB0byBiZSBpbmRlbnRlZCBpZiBmb2xsb3dlZCBieSBhIGNvbW1lbnRcbiAgICAgICAgICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gISFkb2MuY29tbWVudDtcbiAgICAgICAgICAgIGNvbnRlbnRDb21tZW50ID0gZG9jLmNvbnRlbnRzLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25DaG9tcEtlZXAgPSBjb250ZW50Q29tbWVudCA/IHVuZGVmaW5lZCA6ICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKTtcbiAgICAgICAgbGV0IGJvZHkgPSBzdHJpbmdpZnkoZG9jLmNvbnRlbnRzLCBjdHgsICgpID0+IChjb250ZW50Q29tbWVudCA9IG51bGwpLCBvbkNob21wS2VlcCk7XG4gICAgICAgIGlmIChjb250ZW50Q29tbWVudClcbiAgICAgICAgICAgIGJvZHkgKz0gbGluZUNvbW1lbnQoYm9keSwgJycsIGNvbW1lbnRTdHJpbmcoY29udGVudENvbW1lbnQpKTtcbiAgICAgICAgaWYgKChib2R5WzBdID09PSAnfCcgfHwgYm9keVswXSA9PT0gJz4nKSAmJlxuICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPT09ICctLS0nKSB7XG4gICAgICAgICAgICAvLyBUb3AtbGV2ZWwgYmxvY2sgc2NhbGFycyB3aXRoIGEgcHJlY2VkaW5nIGRvYyBtYXJrZXIgb3VnaHQgdG8gdXNlIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBsaW5lIGZvciB0aGVpciBoZWFkZXIuXG4gICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9IGAtLS0gJHtib2R5fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGluZXMucHVzaChib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxpbmVzLnB1c2goc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4KSk7XG4gICAgfVxuICAgIGlmIChkb2MuZGlyZWN0aXZlcz8uZG9jRW5kKSB7XG4gICAgICAgIGlmIChkb2MuY29tbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb21tZW50KTtcbiAgICAgICAgICAgIGlmIChjcy5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAuLi4gJHtjc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJy4uLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGMgPSBkb2MuY29tbWVudDtcbiAgICAgICAgaWYgKGRjICYmIGNob21wS2VlcClcbiAgICAgICAgICAgIGRjID0gZGMucmVwbGFjZSgvXlxcbisvLCAnJyk7XG4gICAgICAgIGlmIChkYykge1xuICAgICAgICAgICAgaWYgKCghY2hvbXBLZWVwIHx8IGNvbnRlbnRDb21tZW50KSAmJiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSAhPT0gJycpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhkYyksICcnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpICsgJ1xcbic7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeURvY3VtZW50IH07XG4iLCAiaW1wb3J0IHsgQWxpYXMgfSBmcm9tICcuLi9ub2Rlcy9BbGlhcy5qcyc7XG5pbXBvcnQgeyBpc0VtcHR5UGF0aCwgY29sbGVjdGlvbkZyb21QYXRoIH0gZnJvbSAnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIERPQywgaXNOb2RlLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgUGFpciB9IGZyb20gJy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4uL25vZGVzL3RvSlMuanMnO1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnLi4vc2NoZW1hL1NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlEb2N1bWVudCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlEb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBhbmNob3JOYW1lcywgZmluZE5ld0FuY2hvciwgY3JlYXRlTm9kZUFuY2hvcnMgfSBmcm9tICcuL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgYXBwbHlSZXZpdmVyIH0gZnJvbSAnLi9hcHBseVJldml2ZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4vY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBEaXJlY3RpdmVzIH0gZnJvbSAnLi9kaXJlY3RpdmVzLmpzJztcblxuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICAvKiogQSBjb21tZW50IGJlZm9yZSB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudEJlZm9yZSA9IG51bGw7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhpcyBEb2N1bWVudCAqL1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICAvKiogRXJyb3JzIGVuY291bnRlcmVkIGR1cmluZyBwYXJzaW5nLiAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAvKiogV2FybmluZ3MgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogRE9DIH0pO1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGludEFzQmlnSW50OiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBTb3VyY2VUb2tlbnM6IGZhbHNlLFxuICAgICAgICAgICAgbG9nTGV2ZWw6ICd3YXJuJyxcbiAgICAgICAgICAgIHByZXR0eUVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmluZ0tleXM6IGZhbHNlLFxuICAgICAgICAgICAgdW5pcXVlS2V5czogdHJ1ZSxcbiAgICAgICAgICAgIHZlcnNpb246ICcxLjInXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgIGxldCB7IHZlcnNpb24gfSA9IG9wdDtcbiAgICAgICAgaWYgKG9wdGlvbnM/Ll9kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBvcHRpb25zLl9kaXJlY3RpdmVzLmF0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMueWFtbC5leHBsaWNpdClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb24gfSk7XG4gICAgICAgIHRoaXMuc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IHJlYWxseSBrbm93IHRoYXQgdGhpcyBtYXRjaGVzIENvbnRlbnRzLlxuICAgICAgICB0aGlzLmNvbnRlbnRzID1cbiAgICAgICAgICAgIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCBfcmVwbGFjZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhpcyBEb2N1bWVudCBhbmQgaXRzIGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQ3VzdG9tIE5vZGUgdmFsdWVzIHRoYXQgaW5oZXJpdCBmcm9tIGBPYmplY3RgIHN0aWxsIHJlZmVyIHRvIHRoZWlyIG9yaWdpbmFsIGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoRG9jdW1lbnQucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBbTk9ERV9UWVBFXTogeyB2YWx1ZTogRE9DIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvcHkuY29tbWVudEJlZm9yZSA9IHRoaXMuY29tbWVudEJlZm9yZTtcbiAgICAgICAgY29weS5jb21tZW50ID0gdGhpcy5jb21tZW50O1xuICAgICAgICBjb3B5LmVycm9ycyA9IHRoaXMuZXJyb3JzLnNsaWNlKCk7XG4gICAgICAgIGNvcHkud2FybmluZ3MgPSB0aGlzLndhcm5pbmdzLnNsaWNlKCk7XG4gICAgICAgIGNvcHkub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICBjb3B5LmRpcmVjdGl2ZXMgPSB0aGlzLmRpcmVjdGl2ZXMuY2xvbmUoKTtcbiAgICAgICAgY29weS5zY2hlbWEgPSB0aGlzLnNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IHJlYWxseSBrbm93IHRoYXQgdGhpcyBtYXRjaGVzIENvbnRlbnRzLlxuICAgICAgICBjb3B5LmNvbnRlbnRzID0gaXNOb2RlKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuY2xvbmUoY29weS5zY2hlbWEpXG4gICAgICAgICAgICA6IHRoaXMuY29udGVudHM7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKVxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHRoaXMucmFuZ2Uuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGRvY3VtZW50LiAqL1xuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuYWRkKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSB2YWx1ZSB0byB0aGUgZG9jdW1lbnQuICovXG4gICAgYWRkSW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLmFkZEluKHBhdGgsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGBBbGlhc2Agbm9kZSwgZW5zdXJpbmcgdGhhdCB0aGUgdGFyZ2V0IGBub2RlYCBoYXMgdGhlIHJlcXVpcmVkIGFuY2hvci5cbiAgICAgKlxuICAgICAqIElmIGBub2RlYCBhbHJlYWR5IGhhcyBhbiBhbmNob3IsIGBuYW1lYCBpcyBpZ25vcmVkLlxuICAgICAqIE90aGVyd2lzZSwgdGhlIGBub2RlLmFuY2hvcmAgdmFsdWUgd2lsbCBiZSBzZXQgdG8gYG5hbWVgLFxuICAgICAqIG9yIGlmIGFuIGFuY2hvciB3aXRoIHRoYXQgbmFtZSBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIGRvY3VtZW50LFxuICAgICAqIGBuYW1lYCB3aWxsIGJlIHVzZWQgYXMgYSBwcmVmaXggZm9yIGEgbmV3IHVuaXF1ZSBhbmNob3IuXG4gICAgICogSWYgYG5hbWVgIGlzIHVuZGVmaW5lZCwgdGhlIGdlbmVyYXRlZCBhbmNob3Igd2lsbCB1c2UgJ2EnIGFzIGEgcHJlZml4LlxuICAgICAqL1xuICAgIGNyZWF0ZUFsaWFzKG5vZGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFub2RlLmFuY2hvcikge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGFuY2hvck5hbWVzKHRoaXMpO1xuICAgICAgICAgICAgbm9kZS5hbmNob3IgPVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICAgICAgICAgICFuYW1lIHx8IHByZXYuaGFzKG5hbWUpID8gZmluZE5ld0FuY2hvcihuYW1lIHx8ICdhJywgcHJldikgOiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWxpYXMobm9kZS5hbmNob3IpO1xuICAgIH1cbiAgICBjcmVhdGVOb2RlKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoeyAnJzogdmFsdWUgfSwgJycsIHZhbHVlKTtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlUb1N0ciA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdiBpbnN0YW5jZW9mIFN0cmluZyB8fCB2IGluc3RhbmNlb2YgTnVtYmVyO1xuICAgICAgICAgICAgY29uc3QgYXNTdHIgPSByZXBsYWNlci5maWx0ZXIoa2V5VG9TdHIpLm1hcChTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKGFzU3RyLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmVwbGFjZXIgPSByZXBsYWNlci5jb25jYXQoYXNTdHIpO1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgYW5jaG9yUHJlZml4LCBmbG93LCBrZWVwVW5kZWZpbmVkLCBvblRhZ09iaiwgdGFnIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCB7IG9uQW5jaG9yLCBzZXRBbmNob3JzLCBzb3VyY2VPYmplY3RzIH0gPSBjcmVhdGVOb2RlQW5jaG9ycyh0aGlzLCBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgIGFuY2hvclByZWZpeCB8fCAnYScpO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBhbGlhc0R1cGxpY2F0ZU9iamVjdHM6IGFsaWFzRHVwbGljYXRlT2JqZWN0cyA/PyB0cnVlLFxuICAgICAgICAgICAga2VlcFVuZGVmaW5lZDoga2VlcFVuZGVmaW5lZCA/PyBmYWxzZSxcbiAgICAgICAgICAgIG9uQW5jaG9yLFxuICAgICAgICAgICAgb25UYWdPYmosXG4gICAgICAgICAgICByZXBsYWNlcjogX3JlcGxhY2VyLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUodmFsdWUsIHRhZywgY3R4KTtcbiAgICAgICAgaWYgKGZsb3cgJiYgaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgbm9kZS5mbG93ID0gdHJ1ZTtcbiAgICAgICAgc2V0QW5jaG9ycygpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGtleSBhbmQgYSB2YWx1ZSBpbnRvIGEgYFBhaXJgIHVzaW5nIHRoZSBjdXJyZW50IHNjaGVtYSxcbiAgICAgKiByZWN1cnNpdmVseSB3cmFwcGluZyBhbGwgdmFsdWVzIGFzIGBTY2FsYXJgIG9yIGBDb2xsZWN0aW9uYCBub2Rlcy5cbiAgICAgKi9cbiAgICBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrID0gdGhpcy5jcmVhdGVOb2RlKGtleSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFBhaXIoaywgdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZShrZXkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUHJlc3VtZWQgaW1wb3NzaWJsZSBpZiBTdHJpY3QgZXh0ZW5kcyBmYWxzZVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZUluKHBhdGgpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmdldChrZXksIGtlZXBTY2FsYXIpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBwYXRoYCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29udGVudHMudmFsdWVcbiAgICAgICAgICAgICAgICA6IHRoaXMuY29udGVudHM7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5nZXRJbihwYXRoLCBrZWVwU2NhbGFyKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpID8gdGhpcy5jb250ZW50cy5oYXMoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgYXQgYHBhdGhgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBba2V5XSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGRvY3VtZW50LiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKi9cbiAgICBzZXRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IHJlYWxseSBrbm93IHRoYXQgdGhpcyBtYXRjaGVzIENvbnRlbnRzLlxuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgQXJyYXkuZnJvbShwYXRoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuc2V0SW4ocGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgWUFNTCB2ZXJzaW9uIGFuZCBzY2hlbWEgdXNlZCBieSB0aGUgZG9jdW1lbnQuXG4gICAgICogQSBgbnVsbGAgdmVyc2lvbiBkaXNhYmxlcyBzdXBwb3J0IGZvciBkaXJlY3RpdmVzLCBleHBsaWNpdCB0YWdzLCBhbmNob3JzLCBhbmQgYWxpYXNlcy5cbiAgICAgKiBJdCBhbHNvIHJlcXVpcmVzIHRoZSBgc2NoZW1hYCBvcHRpb24gdG8gYmUgZ2l2ZW4gYXMgYSBgU2NoZW1hYCBpbnN0YW5jZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlcyBhbGwgcHJldmlvdXNseSBzZXQgc2NoZW1hIG9wdGlvbnMuXG4gICAgICovXG4gICAgc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcbiAgICAgICAgbGV0IG9wdDtcbiAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSAnMS4xJztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbjogJzEuMScgfSk7XG4gICAgICAgICAgICAgICAgb3B0ID0geyByZXNvbHZlS25vd25UYWdzOiBmYWxzZSwgc2NoZW1hOiAneWFtbC0xLjEnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb24gfSk7XG4gICAgICAgICAgICAgICAgb3B0ID0geyByZXNvbHZlS25vd25UYWdzOiB0cnVlLCBzY2hlbWE6ICdjb3JlJyB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRpcmVjdGl2ZXM7XG4gICAgICAgICAgICAgICAgb3B0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IEpTT04uc3RyaW5naWZ5KHZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJzEuMScsICcxLjInIG9yIG51bGwgYXMgZmlyc3QgYXJndW1lbnQsIGJ1dCBmb3VuZDogJHtzdn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgdXNpbmcgYGluc3RhbmNlb2YgU2NoZW1hYCB0byBhbGxvdyBmb3IgZHVjayB0eXBpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NoZW1hIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBvcHRpb25zLnNjaGVtYTtcbiAgICAgICAgZWxzZSBpZiAob3B0KVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBuZXcgU2NoZW1hKE9iamVjdC5hc3NpZ24ob3B0LCBvcHRpb25zKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2l0aCBhIG51bGwgWUFNTCB2ZXJzaW9uLCB0aGUgeyBzY2hlbWE6IFNjaGVtYSB9IG9wdGlvbiBpcyByZXF1aXJlZGApO1xuICAgIH1cbiAgICAvLyBqc29uICYganNvbkFyZyBhcmUgb25seSB1c2VkIGZyb20gdG9KU09OKClcbiAgICB0b0pTKHsganNvbiwganNvbkFyZywgbWFwQXNNYXAsIG1heEFsaWFzQ291bnQsIG9uQW5jaG9yLCByZXZpdmVyIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBhbmNob3JzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBkb2M6IHRoaXMsXG4gICAgICAgICAgICBrZWVwOiAhanNvbixcbiAgICAgICAgICAgIG1hcEFzTWFwOiBtYXBBc01hcCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIG1hcEtleVdhcm5lZDogZmFsc2UsXG4gICAgICAgICAgICBtYXhBbGlhc0NvdW50OiB0eXBlb2YgbWF4QWxpYXNDb3VudCA9PT0gJ251bWJlcicgPyBtYXhBbGlhc0NvdW50IDogMTAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvSlModGhpcy5jb250ZW50cywganNvbkFyZyA/PyAnJywgY3R4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFuY2hvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBjb3VudCwgcmVzIH0gb2YgY3R4LmFuY2hvcnMudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgb25BbmNob3IocmVzLCBjb3VudCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcHBseVJldml2ZXIocmV2aXZlciwgeyAnJzogcmVzIH0sICcnLCByZXMpXG4gICAgICAgICAgICA6IHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkb2N1bWVudCBgY29udGVudHNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb25BcmcgVXNlZCBieSBgSlNPTi5zdHJpbmdpZnlgIHRvIGluZGljYXRlIHRoZSBhcnJheSBpbmRleCBvclxuICAgICAqICAgcHJvcGVydHkgbmFtZS5cbiAgICAgKi9cbiAgICB0b0pTT04oanNvbkFyZywgb25BbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KUyh7IGpzb246IHRydWUsIGpzb25BcmcsIG1hcEFzTWFwOiBmYWxzZSwgb25BbmNob3IgfSk7XG4gICAgfVxuICAgIC8qKiBBIFlBTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50LiAqL1xuICAgIHRvU3RyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgd2l0aCBlcnJvcnMgY2Fubm90IGJlIHN0cmluZ2lmaWVkJyk7XG4gICAgICAgIGlmICgnaW5kZW50JyBpbiBvcHRpb25zICYmXG4gICAgICAgICAgICAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5pbmRlbnQpIHx8IE51bWJlcihvcHRpb25zLmluZGVudCkgPD0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmluZGVudCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaW5kZW50XCIgb3B0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBub3QgJHtzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlEb2N1bWVudCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRDb2xsZWN0aW9uKGNvbnRlbnRzKSB7XG4gICAgaWYgKGlzQ29sbGVjdGlvbihjb250ZW50cykpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBZQU1MIGNvbGxlY3Rpb24gYXMgZG9jdW1lbnQgY29udGVudHMnKTtcbn1cblxuZXhwb3J0IHsgRG9jdW1lbnQgfTtcbiIsICJjbGFzcyBZQU1MRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcG9zLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbn1cbmNsYXNzIFlBTUxQYXJzZUVycm9yIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ1lBTUxQYXJzZUVycm9yJywgcG9zLCBjb2RlLCBtZXNzYWdlKTtcbiAgICB9XG59XG5jbGFzcyBZQU1MV2FybmluZyBleHRlbmRzIFlBTUxFcnJvciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCdZQU1MV2FybmluZycsIHBvcywgY29kZSwgbWVzc2FnZSk7XG4gICAgfVxufVxuY29uc3QgcHJldHRpZnlFcnJvciA9IChzcmMsIGxjKSA9PiAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IucG9zWzBdID09PSAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGVycm9yLmxpbmVQb3MgPSBlcnJvci5wb3MubWFwKHBvcyA9PiBsYy5saW5lUG9zKHBvcykpO1xuICAgIGNvbnN0IHsgbGluZSwgY29sIH0gPSBlcnJvci5saW5lUG9zWzBdO1xuICAgIGVycm9yLm1lc3NhZ2UgKz0gYCBhdCBsaW5lICR7bGluZX0sIGNvbHVtbiAke2NvbH1gO1xuICAgIGxldCBjaSA9IGNvbCAtIDE7XG4gICAgbGV0IGxpbmVTdHIgPSBzcmNcbiAgICAgICAgLnN1YnN0cmluZyhsYy5saW5lU3RhcnRzW2xpbmUgLSAxXSwgbGMubGluZVN0YXJ0c1tsaW5lXSlcbiAgICAgICAgLnJlcGxhY2UoL1tcXG5cXHJdKyQvLCAnJyk7XG4gICAgLy8gVHJpbSB0byBtYXggODAgY2hhcnMsIGtlZXBpbmcgY29sIHBvc2l0aW9uIG5lYXIgdGhlIG1pZGRsZVxuICAgIGlmIChjaSA+PSA2MCAmJiBsaW5lU3RyLmxlbmd0aCA+IDgwKSB7XG4gICAgICAgIGNvbnN0IHRyaW1TdGFydCA9IE1hdGgubWluKGNpIC0gMzksIGxpbmVTdHIubGVuZ3RoIC0gNzkpO1xuICAgICAgICBsaW5lU3RyID0gJ1x1MjAyNicgKyBsaW5lU3RyLnN1YnN0cmluZyh0cmltU3RhcnQpO1xuICAgICAgICBjaSAtPSB0cmltU3RhcnQgLSAxO1xuICAgIH1cbiAgICBpZiAobGluZVN0ci5sZW5ndGggPiA4MClcbiAgICAgICAgbGluZVN0ciA9IGxpbmVTdHIuc3Vic3RyaW5nKDAsIDc5KSArICdcdTIwMjYnO1xuICAgIC8vIEluY2x1ZGUgcHJldmlvdXMgbGluZSBpbiBjb250ZXh0IGlmIHBvaW50aW5nIGF0IGxpbmUgc3RhcnRcbiAgICBpZiAobGluZSA+IDEgJiYgL14gKiQvLnRlc3QobGluZVN0ci5zdWJzdHJpbmcoMCwgY2kpKSkge1xuICAgICAgICAvLyBSZWdleHAgd29uJ3QgbWF0Y2ggaWYgc3RhcnQgaXMgdHJpbW1lZFxuICAgICAgICBsZXQgcHJldiA9IHNyYy5zdWJzdHJpbmcobGMubGluZVN0YXJ0c1tsaW5lIC0gMl0sIGxjLmxpbmVTdGFydHNbbGluZSAtIDFdKTtcbiAgICAgICAgaWYgKHByZXYubGVuZ3RoID4gODApXG4gICAgICAgICAgICBwcmV2ID0gcHJldi5zdWJzdHJpbmcoMCwgNzkpICsgJ1x1MjAyNlxcbic7XG4gICAgICAgIGxpbmVTdHIgPSBwcmV2ICsgbGluZVN0cjtcbiAgICB9XG4gICAgaWYgKC9bXiBdLy50ZXN0KGxpbmVTdHIpKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDE7XG4gICAgICAgIGNvbnN0IGVuZCA9IGVycm9yLmxpbmVQb3NbMV07XG4gICAgICAgIGlmIChlbmQ/LmxpbmUgPT09IGxpbmUgJiYgZW5kLmNvbCA+IGNvbCkge1xuICAgICAgICAgICAgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihlbmQuY29sIC0gY29sLCA4MCAtIGNpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnRlciA9ICcgJy5yZXBlYXQoY2kpICsgJ14nLnJlcGVhdChjb3VudCk7XG4gICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gYDpcXG5cXG4ke2xpbmVTdHJ9XFxuJHtwb2ludGVyfVxcbmA7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgWUFNTEVycm9yLCBZQU1MUGFyc2VFcnJvciwgWUFNTFdhcm5pbmcsIHByZXR0aWZ5RXJyb3IgfTtcbiIsICJmdW5jdGlvbiByZXNvbHZlUHJvcHModG9rZW5zLCB7IGZsb3csIGluZGljYXRvciwgbmV4dCwgb2Zmc2V0LCBvbkVycm9yLCBwYXJlbnRJbmRlbnQsIHN0YXJ0T25OZXdsaW5lIH0pIHtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSBmYWxzZTtcbiAgICBsZXQgYXROZXdsaW5lID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGhhc1NwYWNlID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgY29tbWVudFNlcCA9ICcnO1xuICAgIGxldCBoYXNOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IHJlcVNwYWNlID0gZmFsc2U7XG4gICAgbGV0IHRhYiA9IG51bGw7XG4gICAgbGV0IGFuY2hvciA9IG51bGw7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgbGV0IG5ld2xpbmVBZnRlclByb3AgPSBudWxsO1xuICAgIGxldCBjb21tYSA9IG51bGw7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmIChyZXFTcGFjZSkge1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnY29tbWEnKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgICAgICAgICAgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFiKSB7XG4gICAgICAgICAgICBpZiAoYXROZXdsaW5lICYmIHRva2VuLnR5cGUgIT09ICdjb21tZW50JyAmJiB0b2tlbi50eXBlICE9PSAnbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRhYiwgJ1RBQl9BU19JTkRFTlQnLCAnVGFicyBhcmUgbm90IGFsbG93ZWQgYXMgaW5kZW50YXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGRvYyBsZXZlbCwgdGFicyBhdCBsaW5lIHN0YXJ0IG1heSBiZSBwYXJzZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBsZWFkaW5nIHdoaXRlIHNwYWNlIHJhdGhlciB0aGFuIGluZGVudGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEluIGEgZmxvdyBjb2xsZWN0aW9uLCBvbmx5IHRoZSBwYXJzZXIgaGFuZGxlcyBpbmRlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFmbG93ICYmXG4gICAgICAgICAgICAgICAgICAgIChpbmRpY2F0b3IgIT09ICdkb2Mtc3RhcnQnIHx8IG5leHQ/LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5zb3VyY2UuaW5jbHVkZXMoJ1xcdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYiA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgIGlmICghaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNvbW1lbnRTZXAgKyBjYjtcbiAgICAgICAgICAgICAgICBjb21tZW50U2VwID0gJyc7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoYXROZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmb3VuZCB8fCBpbmRpY2F0b3IgIT09ICdzZXEtaXRlbS1pbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRTZXAgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFzTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmVBZnRlclByb3AgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uc291cmNlLmVuZHNXaXRoKCc6JykpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0ICsgdG9rZW4uc291cmNlLmxlbmd0aCAtIDEsICdCQURfQUxJQVMnLCAnQW5jaG9yIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID8/IChzdGFydCA9IHRva2VuLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0YWcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01VTFRJUExFX1RBR1MnLCAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZycpO1xuICAgICAgICAgICAgICAgIHRhZyA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID8/IChzdGFydCA9IHRva2VuLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGluZGljYXRvcjpcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBoZXJlIGhhbmRsZSBwcmVjZWRpbmcgY29tbWVudHMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yIHx8IHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0JBRF9QUk9QX09SREVSJywgYEFuY2hvcnMgYW5kIHRhZ3MgbXVzdCBiZSBhZnRlciB0aGUgJHt0b2tlbi5zb3VyY2V9IGluZGljYXRvcmApO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnNvdXJjZX0gaW4gJHtmbG93ID8/ICdjb2xsZWN0aW9uJ31gKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciA9PT0gJ3NlcS1pdGVtLWluZCcgfHwgaW5kaWNhdG9yID09PSAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBpZiAoZmxvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmbG93fWApO1xuICAgICAgICAgICAgICAgICAgICBjb21tYSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dG9rZW4udHlwZX0gdG9rZW5gKTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGVuZCA9IGxhc3QgPyBsYXN0Lm9mZnNldCArIGxhc3Quc291cmNlLmxlbmd0aCA6IG9mZnNldDtcbiAgICBpZiAocmVxU3BhY2UgJiZcbiAgICAgICAgbmV4dCAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnY29tbWEnICYmXG4gICAgICAgIChuZXh0LnR5cGUgIT09ICdzY2FsYXInIHx8IG5leHQuc291cmNlICE9PSAnJykpIHtcbiAgICAgICAgb25FcnJvcihuZXh0Lm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICB9XG4gICAgaWYgKHRhYiAmJlxuICAgICAgICAoKGF0TmV3bGluZSAmJiB0YWIuaW5kZW50IDw9IHBhcmVudEluZGVudCkgfHxcbiAgICAgICAgICAgIG5leHQ/LnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICBuZXh0Py50eXBlID09PSAnYmxvY2stc2VxJykpXG4gICAgICAgIG9uRXJyb3IodGFiLCAnVEFCX0FTX0lOREVOVCcsICdUYWJzIGFyZSBub3QgYWxsb3dlZCBhcyBpbmRlbnRhdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgc3BhY2VCZWZvcmUsXG4gICAgICAgIGNvbW1lbnQsXG4gICAgICAgIGhhc05ld2xpbmUsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgdGFnLFxuICAgICAgICBuZXdsaW5lQWZ0ZXJQcm9wLFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCA/PyBlbmRcbiAgICB9O1xufVxuXG5leHBvcnQgeyByZXNvbHZlUHJvcHMgfTtcbiIsICJmdW5jdGlvbiBjb250YWluc05ld2xpbmUoa2V5KSB7XG4gICAgaWYgKCFrZXkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGlmIChrZXkuc291cmNlLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChrZXkuZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Yga2V5LmVuZClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiBrZXkuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGl0LnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc05ld2xpbmUoaXQua2V5KSB8fCBjb250YWluc05ld2xpbmUoaXQudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgY29udGFpbnNOZXdsaW5lIH07XG4iLCAiaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuXG5mdW5jdGlvbiBmbG93SW5kZW50Q2hlY2soaW5kZW50LCBmYywgb25FcnJvcikge1xuICAgIGlmIChmYz8udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZmMuZW5kWzBdO1xuICAgICAgICBpZiAoZW5kLmluZGVudCA9PT0gaW5kZW50ICYmXG4gICAgICAgICAgICAoZW5kLnNvdXJjZSA9PT0gJ10nIHx8IGVuZC5zb3VyY2UgPT09ICd9JykgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zTmV3bGluZShmYykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdGbG93IGVuZCBpbmRpY2F0b3Igc2hvdWxkIGJlIG1vcmUgaW5kZW50ZWQgdGhhbiBwYXJlbnQnO1xuICAgICAgICAgICAgb25FcnJvcihlbmQsICdCQURfSU5ERU5UJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZmxvd0luZGVudENoZWNrIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5cbmZ1bmN0aW9uIG1hcEluY2x1ZGVzKGN0eCwgaXRlbXMsIHNlYXJjaCkge1xuICAgIGNvbnN0IHsgdW5pcXVlS2V5cyB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgaWYgKHVuaXF1ZUtleXMgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNFcXVhbCA9IHR5cGVvZiB1bmlxdWVLZXlzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdW5pcXVlS2V5c1xuICAgICAgICA6IChhLCBiKSA9PiBhID09PSBiIHx8IChpc1NjYWxhcihhKSAmJiBpc1NjYWxhcihiKSAmJiBhLnZhbHVlID09PSBiLnZhbHVlKTtcbiAgICByZXR1cm4gaXRlbXMuc29tZShwYWlyID0+IGlzRXF1YWwocGFpci5rZXksIHNlYXJjaCkpO1xufVxuXG5leHBvcnQgeyBtYXBJbmNsdWRlcyB9O1xuIiwgImltcG9ydCB7IFBhaXIgfSBmcm9tICcuLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5pbXBvcnQgeyBjb250YWluc05ld2xpbmUgfSBmcm9tICcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyc7XG5pbXBvcnQgeyBmbG93SW5kZW50Q2hlY2sgfSBmcm9tICcuL3V0aWwtZmxvdy1pbmRlbnQtY2hlY2suanMnO1xuaW1wb3J0IHsgbWFwSW5jbHVkZXMgfSBmcm9tICcuL3V0aWwtbWFwLWluY2x1ZGVzLmpzJztcblxuY29uc3Qgc3RhcnRDb2xNc2cgPSAnQWxsIG1hcHBpbmcgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nO1xuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrTWFwKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBibSwgb25FcnJvciwgdGFnKSB7XG4gICAgY29uc3QgTm9kZUNsYXNzID0gdGFnPy5ub2RlQ2xhc3MgPz8gWUFNTE1hcDtcbiAgICBjb25zdCBtYXAgPSBuZXcgTm9kZUNsYXNzKGN0eC5zY2hlbWEpO1xuICAgIGlmIChjdHguYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGJtLm9mZnNldDtcbiAgICBsZXQgY29tbWVudEVuZCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjb2xsSXRlbSBvZiBibS5pdGVtcykge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBrZXksIHNlcCwgdmFsdWUgfSA9IGNvbGxJdGVtO1xuICAgICAgICAvLyBrZXkgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBrZXlQcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgPz8gc2VwPy5bMF0sXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBibS5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW1wbGljaXRLZXkgPSAha2V5UHJvcHMuZm91bmQ7XG4gICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkxPQ0tfQVNfSU1QTElDSVRfS0VZJywgJ0EgYmxvY2sgc2VxdWVuY2UgbWF5IG5vdCBiZSB1c2VkIGFzIGFuIGltcGxpY2l0IG1hcCBrZXknKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgnaW5kZW50JyBpbiBrZXkgJiYga2V5LmluZGVudCAhPT0gYm0uaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9JTkRFTlQnLCBzdGFydENvbE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleVByb3BzLmFuY2hvciAmJiAha2V5UHJvcHMudGFnICYmICFzZXApIHtcbiAgICAgICAgICAgICAgICBjb21tZW50RW5kID0ga2V5UHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGlmIChrZXlQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5jb21tZW50ICs9ICdcXG4nICsga2V5UHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgPSBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlQcm9wcy5uZXdsaW5lQWZ0ZXJQcm9wIHx8IGNvbnRhaW5zTmV3bGluZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXkgPz8gc3RhcnRbc3RhcnQubGVuZ3RoIC0gMV0sICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5UHJvcHMuZm91bmQ/LmluZGVudCAhPT0gYm0uaW5kZW50KSB7XG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9JTkRFTlQnLCBzdGFydENvbE1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8ga2V5IHZhbHVlXG4gICAgICAgIGN0eC5hdEtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGtleVN0YXJ0ID0ga2V5UHJvcHMuZW5kO1xuICAgICAgICBjb25zdCBrZXlOb2RlID0ga2V5XG4gICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwga2V5LCBrZXlQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIGtleVN0YXJ0LCBzdGFydCwgbnVsbCwga2V5UHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICBmbG93SW5kZW50Q2hlY2soYm0uaW5kZW50LCBrZXksIG9uRXJyb3IpO1xuICAgICAgICBjdHguYXRLZXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgdmFsdWVQcm9wcyA9IHJlc29sdmVQcm9wcyhzZXAgPz8gW10sIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBibS5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogIWtleSB8fCBrZXkudHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCA9IHZhbHVlUHJvcHMuZW5kO1xuICAgICAgICBpZiAodmFsdWVQcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlPy50eXBlID09PSAnYmxvY2stbWFwJyAmJiAhdmFsdWVQcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdOZXN0ZWQgbWFwcGluZ3MgYXJlIG5vdCBhbGxvd2VkIGluIGNvbXBhY3QgbWFwcGluZ3MnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMuc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BzLnN0YXJ0IDwgdmFsdWVQcm9wcy5mb3VuZC5vZmZzZXQgLSAxMDI0KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgYmxvY2sgbWFwcGluZyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBvZmZzZXQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwgdmFsdWUsIG9uRXJyb3IpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGtleSB3aXRoIG5vIHZhbHVlXG4gICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnTUlTU0lOR19DSEFSJywgJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgZm9sbG93ZWQgYnkgbWFwIHZhbHVlcycpO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlOb2RlLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCArPSAnXFxuJyArIHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCA9IHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tZW50RW5kICYmIGNvbW1lbnRFbmQgPCBvZmZzZXQpXG4gICAgICAgIG9uRXJyb3IoY29tbWVudEVuZCwgJ0lNUE9TU0lCTEUnLCAnTWFwIGNvbW1lbnQgd2l0aCB0cmFpbGluZyBjb250ZW50Jyk7XG4gICAgbWFwLnJhbmdlID0gW2JtLm9mZnNldCwgb2Zmc2V0LCBjb21tZW50RW5kID8/IG9mZnNldF07XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrTWFwIH07XG4iLCAiaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcbmltcG9ydCB7IGZsb3dJbmRlbnRDaGVjayB9IGZyb20gJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja1NlcSh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYnMsIG9uRXJyb3IsIHRhZykge1xuICAgIGNvbnN0IE5vZGVDbGFzcyA9IHRhZz8ubm9kZUNsYXNzID8/IFlBTUxTZXE7XG4gICAgY29uc3Qgc2VxID0gbmV3IE5vZGVDbGFzcyhjdHguc2NoZW1hKTtcbiAgICBpZiAoY3R4LmF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGlmIChjdHguYXRLZXkpXG4gICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBicy5vZmZzZXQ7XG4gICAgbGV0IGNvbW1lbnRFbmQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgeyBzdGFydCwgdmFsdWUgfSBvZiBicy5pdGVtcykge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgaW5kaWNhdG9yOiAnc2VxLWl0ZW0taW5kJyxcbiAgICAgICAgICAgIG5leHQ6IHZhbHVlLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHBhcmVudEluZGVudDogYnMuaW5kZW50LFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5hbmNob3IgfHwgcHJvcHMudGFnIHx8IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlPy50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5lbmQsICdCQURfSU5ERU5UJywgJ0FsbCBzZXF1ZW5jZSBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbicpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnU2VxdWVuY2UgaXRlbSB3aXRob3V0IC0gaW5kaWNhdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tZW50RW5kID0gcHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBzZXEuY29tbWVudCA9IHByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHZhbHVlXG4gICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzdGFydCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICBmbG93SW5kZW50Q2hlY2soYnMuaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgIG9mZnNldCA9IG5vZGUucmFuZ2VbMl07XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBzZXEucmFuZ2UgPSBbYnMub2Zmc2V0LCBvZmZzZXQsIGNvbW1lbnRFbmQgPz8gb2Zmc2V0XTtcbiAgICByZXR1cm4gc2VxO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tTZXEgfTtcbiIsICJmdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgb2Zmc2V0LCByZXFTcGFjZSwgb25FcnJvcikge1xuICAgIGxldCBjb21tZW50ID0gJyc7XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBsZXQgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcCA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGVuZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHR5cGUgfSA9IHRva2VuO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXFTcGFjZSAmJiAhaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2IgPSBzb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNiO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IHNlcCArIGNiO1xuICAgICAgICAgICAgICAgICAgICBzZXAgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcCArPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3R5cGV9IGF0IG5vZGUgZW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBvZmZzZXQgfTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUVuZCB9O1xuIiwgImltcG9ydCB7IGlzUGFpciB9IGZyb20gJy4uL25vZGVzL2lkZW50aXR5LmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5pbXBvcnQgeyBjb250YWluc05ld2xpbmUgfSBmcm9tICcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyc7XG5pbXBvcnQgeyBtYXBJbmNsdWRlcyB9IGZyb20gJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnO1xuXG5jb25zdCBibG9ja01zZyA9ICdCbG9jayBjb2xsZWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIGZsb3cgY29sbGVjdGlvbnMnO1xuY29uc3QgaXNCbG9jayA9ICh0b2tlbikgPT4gdG9rZW4gJiYgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKTtcbmZ1bmN0aW9uIHJlc29sdmVGbG93Q29sbGVjdGlvbih7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgZmMsIG9uRXJyb3IsIHRhZykge1xuICAgIGNvbnN0IGlzTWFwID0gZmMuc3RhcnQuc291cmNlID09PSAneyc7XG4gICAgY29uc3QgZmNOYW1lID0gaXNNYXAgPyAnZmxvdyBtYXAnIDogJ2Zsb3cgc2VxdWVuY2UnO1xuICAgIGNvbnN0IE5vZGVDbGFzcyA9ICh0YWc/Lm5vZGVDbGFzcyA/PyAoaXNNYXAgPyBZQU1MTWFwIDogWUFNTFNlcSkpO1xuICAgIGNvbnN0IGNvbGwgPSBuZXcgTm9kZUNsYXNzKGN0eC5zY2hlbWEpO1xuICAgIGNvbGwuZmxvdyA9IHRydWU7XG4gICAgY29uc3QgYXRSb290ID0gY3R4LmF0Um9vdDtcbiAgICBpZiAoYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgaWYgKGN0eC5hdEtleSlcbiAgICAgICAgY3R4LmF0S2V5ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGZjLm9mZnNldCArIGZjLnN0YXJ0LnNvdXJjZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYy5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb2xsSXRlbSA9IGZjLml0ZW1zW2ldO1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBrZXksIHNlcCwgdmFsdWUgfSA9IGNvbGxJdGVtO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgPz8gc2VwPy5bMF0sXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBmYy5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMuYW5jaG9yICYmICFwcm9wcy50YWcgJiYgIXNlcCAmJiAhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBwcm9wcy5jb21tYSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5jb21tYSwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAsIGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPCBmYy5pdGVtcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLnN0YXJ0LCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkIGVtcHR5IGl0ZW0gaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGwuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCArPSAnXFxuJyArIHByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCA9IHByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNNYXAgJiYgY3R4Lm9wdGlvbnMuc3RyaWN0ICYmIGNvbnRhaW5zTmV3bGluZShrZXkpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5LCAvLyBjaGVja2VkIGJ5IGNvbnRhaW5zTmV3bGluZSgpXG4gICAgICAgICAgICAgICAgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBvZiBmbG93IHNlcXVlbmNlIHBhaXJzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5jb21tYSwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAsIGluICR7ZmNOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5jb21tYSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLnN0YXJ0LCAnTUlTU0lOR19DSEFSJywgYE1pc3NpbmcgLCBiZXR3ZWVuICR7ZmNOYW1lfSBpdGVtc2ApO1xuICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldkl0ZW1Db21tZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgbG9vcDogZm9yIChjb25zdCBzdCBvZiBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZJdGVtQ29tbWVudCA9IHN0LnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldkl0ZW1Db21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2ID0gY29sbC5pdGVtc1tjb2xsLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQYWlyKHByZXYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXYudmFsdWUgPz8gcHJldi5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2LmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNvbW1lbnQgKz0gJ1xcbicgKyBwcmV2SXRlbUNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuY29tbWVudCA9IHByZXZJdGVtQ29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY29tbWVudCA9IHByb3BzLmNvbW1lbnQuc3Vic3RyaW5nKHByZXZJdGVtQ29tbWVudC5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc01hcCAmJiAhc2VwICYmICFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgLy8gaXRlbSBpcyBhIHZhbHVlIGluIGEgc2VxXG4gICAgICAgICAgICAvLyBcdTIxOTIga2V5ICYgc2VwIGFyZSBlbXB0eSwgc3RhcnQgZG9lcyBub3QgaW5jbHVkZSA/IG9yIDpcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBwcm9wcy5lbmQsIHNlcCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgY29sbC5pdGVtcy5wdXNoKHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUucmFuZ2VbMl07XG4gICAgICAgICAgICBpZiAoaXNCbG9jayh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZU5vZGUucmFuZ2UsICdCTE9DS19JTl9GTE9XJywgYmxvY2tNc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlbSBpcyBhIGtleSt2YWx1ZSBwYWlyXG4gICAgICAgICAgICAvLyBrZXkgdmFsdWVcbiAgICAgICAgICAgIGN0eC5hdEtleSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBrZXlTdGFydCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwga2V5LCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKGtleSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdmFsdWUgcHJvcGVydGllc1xuICAgICAgICAgICAgY29uc3QgdmFsdWVQcm9wcyA9IHJlc29sdmVQcm9wcyhzZXAgPz8gW10sIHtcbiAgICAgICAgICAgICAgICBmbG93OiBmY05hbWUsXG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yOiAnbWFwLXZhbHVlLWluZCcsXG4gICAgICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBrZXlOb2RlLnJhbmdlWzJdLFxuICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgcGFyZW50SW5kZW50OiBmYy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01hcCAmJiAhcHJvcHMuZm91bmQgJiYgY3R4Lm9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdCA9PT0gdmFsdWVQcm9wcy5mb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHN0LCAnTVVMVElMSU5FX0lNUExJQ0lUX0tFWScsICdJbXBsaWNpdCBrZXlzIG9mIGZsb3cgc2VxdWVuY2UgcGFpcnMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLnN0YXJ0IDwgdmFsdWVQcm9wcy5mb3VuZC5vZmZzZXQgLSAxMDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZVByb3BzLmZvdW5kLCAnS0VZX09WRVJfMTAyNF9DSEFSUycsICdUaGUgOiBpbmRpY2F0b3IgbXVzdCBiZSBhdCBtb3N0IDEwMjQgY2hhcnMgYWZ0ZXIgdGhlIHN0YXJ0IG9mIGFuIGltcGxpY2l0IGZsb3cgc2VxdWVuY2Uga2V5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3NvdXJjZScgaW4gdmFsdWUgJiYgdmFsdWUuc291cmNlPy5bMF0gPT09ICc6JylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZSwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nIHNwYWNlIGFmdGVyIDogaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuc3RhcnQsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyAsIG9yIDogYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IHZhbHVlUHJvcHMuZm91bmRcbiAgICAgICAgICAgICAgICAgICAgPyBjb21wb3NlRW1wdHlOb2RlKGN0eCwgdmFsdWVQcm9wcy5lbmQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZU5vZGUucmFuZ2UsICdCTE9DS19JTl9GTE9XJywgYmxvY2tNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5vZGUuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ICs9ICdcXG4nICsgdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ID0gdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBjb2xsO1xuICAgICAgICAgICAgICAgIGlmIChtYXBJbmNsdWRlcyhjdHgsIG1hcC5pdGVtcywga2V5Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChjdHguc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBtYXAuZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUmFuZ2UgPSAodmFsdWVOb2RlID8/IGtleU5vZGUpLnJhbmdlO1xuICAgICAgICAgICAgICAgIG1hcC5yYW5nZSA9IFtrZXlOb2RlLnJhbmdlWzBdLCBlbmRSYW5nZVsxXSwgZW5kUmFuZ2VbMl1dO1xuICAgICAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaChtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlID8gdmFsdWVOb2RlLnJhbmdlWzJdIDogdmFsdWVQcm9wcy5lbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwZWN0ZWRFbmQgPSBpc01hcCA/ICd9JyA6ICddJztcbiAgICBjb25zdCBbY2UsIC4uLmVlXSA9IGZjLmVuZDtcbiAgICBsZXQgY2VQb3MgPSBvZmZzZXQ7XG4gICAgaWYgKGNlPy5zb3VyY2UgPT09IGV4cGVjdGVkRW5kKVxuICAgICAgICBjZVBvcyA9IGNlLm9mZnNldCArIGNlLnNvdXJjZS5sZW5ndGg7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmY05hbWVbMF0udG9VcHBlckNhc2UoKSArIGZjTmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGNvbnN0IG1zZyA9IGF0Um9vdFxuICAgICAgICAgICAgPyBgJHtuYW1lfSBtdXN0IGVuZCB3aXRoIGEgJHtleHBlY3RlZEVuZH1gXG4gICAgICAgICAgICA6IGAke25hbWV9IGluIGJsb2NrIGNvbGxlY3Rpb24gbXVzdCBiZSBzdWZmaWNpZW50bHkgaW5kZW50ZWQgYW5kIGVuZCB3aXRoIGEgJHtleHBlY3RlZEVuZH1gO1xuICAgICAgICBvbkVycm9yKG9mZnNldCwgYXRSb290ID8gJ01JU1NJTkdfQ0hBUicgOiAnQkFEX0lOREVOVCcsIG1zZyk7XG4gICAgICAgIGlmIChjZSAmJiBjZS5zb3VyY2UubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgZWUudW5zaGlmdChjZSk7XG4gICAgfVxuICAgIGlmIChlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IHJlc29sdmVFbmQoZWUsIGNlUG9zLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoZW5kLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb2xsLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgZW5kLmNvbW1lbnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gZW5kLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29sbC5yYW5nZSA9IFtmYy5vZmZzZXQsIGNlUG9zLCBlbmQub2Zmc2V0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbGwucmFuZ2UgPSBbZmMub2Zmc2V0LCBjZVBvcywgY2VQb3NdO1xuICAgIH1cbiAgICByZXR1cm4gY29sbDtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUZsb3dDb2xsZWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVCbG9ja01hcCB9IGZyb20gJy4vcmVzb2x2ZS1ibG9jay1tYXAuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUJsb2NrU2VxIH0gZnJvbSAnLi9yZXNvbHZlLWJsb2NrLXNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRmxvd0NvbGxlY3Rpb24gfSBmcm9tICcuL3Jlc29sdmUtZmxvdy1jb2xsZWN0aW9uLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZ05hbWUsIHRhZykge1xuICAgIGNvbnN0IGNvbGwgPSB0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJ1xuICAgICAgICA/IHJlc29sdmVCbG9ja01hcChDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnKVxuICAgICAgICA6IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnXG4gICAgICAgICAgICA/IHJlc29sdmVCbG9ja1NlcShDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnKVxuICAgICAgICAgICAgOiByZXNvbHZlRmxvd0NvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZyk7XG4gICAgY29uc3QgQ29sbCA9IGNvbGwuY29uc3RydWN0b3I7XG4gICAgLy8gSWYgd2UgZ290IGEgdGFnTmFtZSBtYXRjaGluZyB0aGUgY2xhc3MsIG9yIHRoZSB0YWcgbmFtZSBpcyAnIScsXG4gICAgLy8gdGhlbiB1c2UgdGhlIHRhZ05hbWUgZnJvbSB0aGUgbm9kZSBjbGFzcyB1c2VkIHRvIGNyZWF0ZSBpdC5cbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnIHx8IHRhZ05hbWUgPT09IENvbGwudGFnTmFtZSkge1xuICAgICAgICBjb2xsLnRhZyA9IENvbGwudGFnTmFtZTtcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgfVxuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBjb2xsLnRhZyA9IHRhZ05hbWU7XG4gICAgcmV0dXJuIGNvbGw7XG59XG5mdW5jdGlvbiBjb21wb3NlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgcHJvcHMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0YWdUb2tlbiA9IHByb3BzLnRhZztcbiAgICBjb25zdCB0YWdOYW1lID0gIXRhZ1Rva2VuXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGN0eC5kaXJlY3RpdmVzLnRhZ05hbWUodGFnVG9rZW4uc291cmNlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZykpO1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJykge1xuICAgICAgICBjb25zdCB7IGFuY2hvciwgbmV3bGluZUFmdGVyUHJvcDogbmwgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBsYXN0UHJvcCA9IGFuY2hvciAmJiB0YWdUb2tlblxuICAgICAgICAgICAgPyBhbmNob3Iub2Zmc2V0ID4gdGFnVG9rZW4ub2Zmc2V0XG4gICAgICAgICAgICAgICAgPyBhbmNob3JcbiAgICAgICAgICAgICAgICA6IHRhZ1Rva2VuXG4gICAgICAgICAgICA6IChhbmNob3IgPz8gdGFnVG9rZW4pO1xuICAgICAgICBpZiAobGFzdFByb3AgJiYgKCFubCB8fCBubC5vZmZzZXQgPCBsYXN0UHJvcC5vZmZzZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ01pc3NpbmcgbmV3bGluZSBhZnRlciBibG9jayBzZXF1ZW5jZSBwcm9wcyc7XG4gICAgICAgICAgICBvbkVycm9yKGxhc3RQcm9wLCAnTUlTU0lOR19DSEFSJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwVHlwZSA9IHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnXG4gICAgICAgID8gJ21hcCdcbiAgICAgICAgOiB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJ1xuICAgICAgICAgICAgPyAnc2VxJ1xuICAgICAgICAgICAgOiB0b2tlbi5zdGFydC5zb3VyY2UgPT09ICd7J1xuICAgICAgICAgICAgICAgID8gJ21hcCdcbiAgICAgICAgICAgICAgICA6ICdzZXEnO1xuICAgIC8vIHNob3J0Y3V0OiBjaGVjayBpZiBpdCdzIGEgZ2VuZXJpYyBZQU1MTWFwIG9yIFlBTUxTZXFcbiAgICAvLyBiZWZvcmUganVtcGluZyBpbnRvIHRoZSBjdXN0b20gdGFnIGxvZ2ljLlxuICAgIGlmICghdGFnVG9rZW4gfHxcbiAgICAgICAgIXRhZ05hbWUgfHxcbiAgICAgICAgdGFnTmFtZSA9PT0gJyEnIHx8XG4gICAgICAgICh0YWdOYW1lID09PSBZQU1MTWFwLnRhZ05hbWUgJiYgZXhwVHlwZSA9PT0gJ21hcCcpIHx8XG4gICAgICAgICh0YWdOYW1lID09PSBZQU1MU2VxLnRhZ05hbWUgJiYgZXhwVHlwZSA9PT0gJ3NlcScpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnTmFtZSk7XG4gICAgfVxuICAgIGxldCB0YWcgPSBjdHguc2NoZW1hLnRhZ3MuZmluZCh0ID0+IHQudGFnID09PSB0YWdOYW1lICYmIHQuY29sbGVjdGlvbiA9PT0gZXhwVHlwZSk7XG4gICAgaWYgKCF0YWcpIHtcbiAgICAgICAgY29uc3Qga3QgPSBjdHguc2NoZW1hLmtub3duVGFnc1t0YWdOYW1lXTtcbiAgICAgICAgaWYgKGt0Py5jb2xsZWN0aW9uID09PSBleHBUeXBlKSB7XG4gICAgICAgICAgICBjdHguc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSB9KSk7XG4gICAgICAgICAgICB0YWcgPSBrdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChrdCkge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodGFnVG9rZW4sICdCQURfQ09MTEVDVElPTl9UWVBFJywgYCR7a3QudGFnfSB1c2VkIGZvciAke2V4cFR5cGV9IGNvbGxlY3Rpb24sIGJ1dCBleHBlY3RzICR7a3QuY29sbGVjdGlvbiA/PyAnc2NhbGFyJ31gLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBgVW5yZXNvbHZlZCB0YWc6ICR7dGFnTmFtZX1gLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29sbCA9IHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lLCB0YWcpO1xuICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlPy4oY29sbCwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpLCBjdHgub3B0aW9ucykgPz8gY29sbDtcbiAgICBjb25zdCBub2RlID0gaXNOb2RlKHJlcylcbiAgICAgICAgPyByZXNcbiAgICAgICAgOiBuZXcgU2NhbGFyKHJlcyk7XG4gICAgbm9kZS5yYW5nZSA9IGNvbGwucmFuZ2U7XG4gICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmICh0YWc/LmZvcm1hdClcbiAgICAgICAgbm9kZS5mb3JtYXQgPSB0YWcuZm9ybWF0O1xuICAgIHJldHVybiBub2RlO1xufVxuXG5leHBvcnQgeyBjb21wb3NlQ29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja1NjYWxhcihjdHgsIHNjYWxhciwgb25FcnJvcikge1xuICAgIGNvbnN0IHN0YXJ0ID0gc2NhbGFyLm9mZnNldDtcbiAgICBjb25zdCBoZWFkZXIgPSBwYXJzZUJsb2NrU2NhbGFySGVhZGVyKHNjYWxhciwgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBpZiAoIWhlYWRlcilcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6ICcnLCB0eXBlOiBudWxsLCBjb21tZW50OiAnJywgcmFuZ2U6IFtzdGFydCwgc3RhcnQsIHN0YXJ0XSB9O1xuICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIubW9kZSA9PT0gJz4nID8gU2NhbGFyLkJMT0NLX0ZPTERFRCA6IFNjYWxhci5CTE9DS19MSVRFUkFMO1xuICAgIGNvbnN0IGxpbmVzID0gc2NhbGFyLnNvdXJjZSA/IHNwbGl0TGluZXMoc2NhbGFyLnNvdXJjZSkgOiBbXTtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGVuZCBvZiBjb250ZW50ICYgc3RhcnQgb2YgY2hvbXBpbmdcbiAgICBsZXQgY2hvbXBTdGFydCA9IGxpbmVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGxpbmVzW2ldWzFdO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJ1xccicpXG4gICAgICAgICAgICBjaG9tcFN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHNob3J0Y3V0IGZvciBlbXB0eSBjb250ZW50c1xuICAgIGlmIChjaG9tcFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLmNob21wID09PSAnKycgJiYgbGluZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyAnXFxuJy5yZXBlYXQoTWF0aC5tYXgoMSwgbGluZXMubGVuZ3RoIC0gMSkpXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoO1xuICAgICAgICBpZiAoc2NhbGFyLnNvdXJjZSlcbiAgICAgICAgICAgIGVuZCArPSBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdHJpbSBmcm9tIHN0YXJ0XG4gICAgbGV0IHRyaW1JbmRlbnQgPSBzY2FsYXIuaW5kZW50ICsgaGVhZGVyLmluZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc2NhbGFyLm9mZnNldCArIGhlYWRlci5sZW5ndGg7XG4gICAgbGV0IGNvbnRlbnRTdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgY29uc3QgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMCAmJiBpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgaW5kZW50Lmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgaWYgKHRyaW1JbmRlbnQgPT09IDAgJiYgIWN0eC5hdFJvb3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0Jsb2NrIHNjYWxhciB2YWx1ZXMgaW4gY29sbGVjdGlvbnMgbXVzdCBiZSBpbmRlbnRlZCc7XG4gICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gaW5kZW50Lmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSB0cmFpbGluZyBtb3JlLWluZGVudGVkIGVtcHR5IGxpbmVzIGluIGNvbnRlbnRcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSBjaG9tcFN0YXJ0OyAtLWkpIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldWzBdLmxlbmd0aCA+IHRyaW1JbmRlbnQpXG4gICAgICAgICAgICBjaG9tcFN0YXJ0ID0gaSArIDE7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGxldCBzZXAgPSAnJztcbiAgICBsZXQgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgIC8vIGxlYWRpbmcgd2hpdGVzcGFjZSBpcyBrZXB0IGludGFjdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudFN0YXJ0OyArK2kpXG4gICAgICAgIHZhbHVlICs9IGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpICsgJ1xcbic7XG4gICAgZm9yIChsZXQgaSA9IGNvbnRlbnRTdGFydDsgaSA8IGNob21wU3RhcnQ7ICsraSkge1xuICAgICAgICBsZXQgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGNybGYgPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXHInO1xuICAgICAgICBpZiAoY3JsZilcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIGFscmVhZHkgY2F1Z2h0IGluIGxleGVyICovXG4gICAgICAgIGlmIChjb250ZW50ICYmIGluZGVudC5sZW5ndGggPCB0cmltSW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBoZWFkZXIuaW5kZW50XG4gICAgICAgICAgICAgICAgPyAnZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgIDogJ2ZpcnN0IGxpbmUnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBCbG9jayBzY2FsYXIgbGluZXMgbXVzdCBub3QgYmUgbGVzcyBpbmRlbnRlZCB0aGFuIHRoZWlyICR7c3JjfWA7XG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoIC0gKGNybGYgPyAyIDogMSksICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudCB8fCBjb250ZW50WzBdID09PSAnXFx0Jykge1xuICAgICAgICAgICAgLy8gbW9yZS1pbmRlbnRlZCBjb250ZW50IHdpdGhpbiBhIGZvbGRlZCBibG9ja1xuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXByZXZNb3JlSW5kZW50ZWQgJiYgc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuXFxuJztcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIHByZXZNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lXG4gICAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChoZWFkZXIuY2hvbXApIHtcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY2hvbXBTdGFydDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nICsgbGluZXNbaV1bMF0uc2xpY2UodHJpbUluZGVudCk7XG4gICAgICAgICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICB9XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoICsgc2NhbGFyLnNvdXJjZS5sZW5ndGg7XG4gICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoeyBvZmZzZXQsIHByb3BzIH0sIHN0cmljdCwgb25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGlmIChwcm9wc1swXS50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpIHtcbiAgICAgICAgb25FcnJvcihwcm9wc1swXSwgJ0lNUE9TU0lCTEUnLCAnQmxvY2sgc2NhbGFyIGhlYWRlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBwcm9wc1swXTtcbiAgICBjb25zdCBtb2RlID0gc291cmNlWzBdO1xuICAgIGxldCBpbmRlbnQgPSAwO1xuICAgIGxldCBjaG9tcCA9ICcnO1xuICAgIGxldCBlcnJvciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoID0gc291cmNlW2ldO1xuICAgICAgICBpZiAoIWNob21wICYmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpKVxuICAgICAgICAgICAgY2hvbXAgPSBjaDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKGNoKTtcbiAgICAgICAgICAgIGlmICghaW5kZW50ICYmIG4pXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yID09PSAtMSlcbiAgICAgICAgICAgICAgICBlcnJvciA9IG9mZnNldCArIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yICE9PSAtMSlcbiAgICAgICAgb25FcnJvcihlcnJvciwgJ1VORVhQRUNURURfVE9LRU4nLCBgQmxvY2sgc2NhbGFyIGhlYWRlciBpbmNsdWRlcyBleHRyYSBjaGFyYWN0ZXJzOiAke3NvdXJjZX1gKTtcbiAgICBsZXQgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwcm9wc1tpXTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhaGFzU3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIHRva2VuLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFVuZXhwZWN0ZWQgdG9rZW4gaW4gYmxvY2sgc2NhbGFyIGhlYWRlcjogJHt0b2tlbi50eXBlfWA7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cyA9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAodHMgJiYgdHlwZW9mIHRzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RlLCBpbmRlbnQsIGNob21wLCBjb21tZW50LCBsZW5ndGggfTtcbn1cbi8qKiBAcmV0dXJucyBBcnJheSBvZiBsaW5lcyBzcGxpdCB1cCBhcyBgW2luZGVudCwgY29udGVudF1gICovXG5mdW5jdGlvbiBzcGxpdExpbmVzKHNvdXJjZSkge1xuICAgIGNvbnN0IHNwbGl0ID0gc291cmNlLnNwbGl0KC9cXG4oICopLyk7XG4gICAgY29uc3QgZmlyc3QgPSBzcGxpdFswXTtcbiAgICBjb25zdCBtID0gZmlyc3QubWF0Y2goL14oICopLyk7XG4gICAgY29uc3QgbGluZTAgPSBtPy5bMV1cbiAgICAgICAgPyBbbVsxXSwgZmlyc3Quc2xpY2UobVsxXS5sZW5ndGgpXVxuICAgICAgICA6IFsnJywgZmlyc3RdO1xuICAgIGNvbnN0IGxpbmVzID0gW2xpbmUwXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwbGl0Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBsaW5lcy5wdXNoKFtzcGxpdFtpXSwgc3BsaXRbaSArIDFdXSk7XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlRmxvd1NjYWxhcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCB0eXBlLCBzb3VyY2UsIGVuZCB9ID0gc2NhbGFyO1xuICAgIGxldCBfdHlwZTtcbiAgICBsZXQgdmFsdWU7XG4gICAgY29uc3QgX29uRXJyb3IgPSAocmVsLCBjb2RlLCBtc2cpID0+IG9uRXJyb3Iob2Zmc2V0ICsgcmVsLCBjb2RlLCBtc2cpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUExBSU47XG4gICAgICAgICAgICB2YWx1ZSA9IHBsYWluVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUVVPVEVfU0lOR0xFO1xuICAgICAgICAgICAgdmFsdWUgPSBzaW5nbGVRdW90ZWRWYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgICAgICAgICB2YWx1ZSA9IGRvdWJsZVF1b3RlZFZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvbkVycm9yKHNjYWxhciwgJ1VORVhQRUNURURfVE9LRU4nLCBgRXhwZWN0ZWQgYSBmbG93IHNjYWxhciB2YWx1ZSwgYnV0IGZvdW5kOiAke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6ICcnLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbb2Zmc2V0LCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoLCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoXVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVFbmQgPSBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBzdHJpY3QsIG9uRXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiBfdHlwZSxcbiAgICAgICAgY29tbWVudDogcmUuY29tbWVudCxcbiAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBsYWluVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IGJhZENoYXIgPSAnJztcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdhIHRhYiBjaGFyYWN0ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdmbG93IGluZGljYXRvciBjaGFyYWN0ZXIgLCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBiYWRDaGFyID0gJ2RpcmVjdGl2ZSBpbmRpY2F0b3IgY2hhcmFjdGVyICUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+Jzoge1xuICAgICAgICAgICAgYmFkQ2hhciA9IGBibG9jayBzY2FsYXIgaW5kaWNhdG9yICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgY2FzZSAnYCc6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgcmVzZXJ2ZWQgY2hhcmFjdGVyICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFkQ2hhcilcbiAgICAgICAgb25FcnJvcigwLCAnQkFEX1NDQUxBUl9TVEFSVCcsIGBQbGFpbiB2YWx1ZSBjYW5ub3Qgc3RhcnQgd2l0aCAke2JhZENoYXJ9YCk7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2UpO1xufVxuZnVuY3Rpb24gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09IFwiJ1wiIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIFwiTWlzc2luZyBjbG9zaW5nICdxdW90ZVwiKTtcbiAgICByZXR1cm4gZm9sZExpbmVzKHNvdXJjZS5zbGljZSgxLCAtMSkpLnJlcGxhY2UoLycnL2csIFwiJ1wiKTtcbn1cbmZ1bmN0aW9uIGZvbGRMaW5lcyhzb3VyY2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmVnYXRpdmUgbG9va2JlaGluZCBoZXJlIGFuZCBpbiB0aGUgYHJlYCBSZWdFeHAgaXMgdG9cbiAgICAgKiBwcmV2ZW50IGNhdXNpbmcgYSBwb2x5bm9taWFsIHNlYXJjaCB0aW1lIGluIGNlcnRhaW4gY2FzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHJ5LWNhdGNoIGlzIGZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHlldDpcbiAgICAgKiBodHRwczovL2Nhbml1c2UuY29tL2pzLXJlZ2V4cC1sb29rYmVoaW5kXG4gICAgICovXG4gICAgbGV0IGZpcnN0LCBsaW5lO1xuICAgIHRyeSB7XG4gICAgICAgIGZpcnN0ID0gbmV3IFJlZ0V4cCgnKC4qPykoPzwhWyBcXHRdKVsgXFx0XSpcXHI/XFxuJywgJ3N5Jyk7XG4gICAgICAgIGxpbmUgPSBuZXcgUmVnRXhwKCdbIFxcdF0qKC4qPykoPzooPzwhWyBcXHRdKVsgXFx0XSopP1xccj9cXG4nLCAnc3knKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBmaXJzdCA9IC8oLio/KVsgXFx0XSpcXHI/XFxuL3N5O1xuICAgICAgICBsaW5lID0gL1sgXFx0XSooLio/KVsgXFx0XSpcXHI/XFxuL3N5O1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSBmaXJzdC5leGVjKHNvdXJjZSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQgcmVzID0gbWF0Y2hbMV07XG4gICAgbGV0IHNlcCA9ICcgJztcbiAgICBsZXQgcG9zID0gZmlyc3QubGFzdEluZGV4O1xuICAgIGxpbmUubGFzdEluZGV4ID0gcG9zO1xuICAgIHdoaWxlICgobWF0Y2ggPSBsaW5lLmV4ZWMoc291cmNlKSkpIHtcbiAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnJykge1xuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgcmVzICs9IHNlcDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBzZXAgKyBtYXRjaFsxXTtcbiAgICAgICAgICAgIHNlcCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBsaW5lLmxhc3RJbmRleDtcbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IC9bIFxcdF0qKC4qKS9zeTtcbiAgICBsYXN0Lmxhc3RJbmRleCA9IHBvcztcbiAgICBtYXRjaCA9IGxhc3QuZXhlYyhzb3VyY2UpO1xuICAgIHJldHVybiByZXMgKyBzZXAgKyAobWF0Y2g/LlsxXSA/PyAnJyk7XG59XG5mdW5jdGlvbiBkb3VibGVRdW90ZWRWYWx1ZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoID0gc291cmNlW2ldO1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtpICsgMV0gPT09ICdcXG4nKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9sZCwgb2Zmc2V0IH0gPSBmb2xkTmV3bGluZShzb3VyY2UsIGkpO1xuICAgICAgICAgICAgcmVzICs9IGZvbGQ7XG4gICAgICAgICAgICBpID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gc291cmNlWysraV07XG4gICAgICAgICAgICBjb25zdCBjYyA9IGVzY2FwZUNvZGVzW25leHRdO1xuICAgICAgICAgICAgaWYgKGNjKVxuICAgICAgICAgICAgICAgIHJlcyArPSBjYztcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIG5ld2xpbmVzLCBidXQgc3RpbGwgdHJpbSB0aGUgZm9sbG93aW5nIGxpbmVcbiAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1xccicgJiYgc291cmNlW2kgKyAxXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGVzY2FwZWQgQ1JMRiBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ3gnIHx8IG5leHQgPT09ICd1JyB8fCBuZXh0ID09PSAnVScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSB7IHg6IDIsIHU6IDQsIFU6IDggfVtuZXh0XTtcbiAgICAgICAgICAgICAgICByZXMgKz0gcGFyc2VDaGFyQ29kZShzb3VyY2UsIGkgKyAxLCBsZW5ndGgsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGkgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3ID0gc291cmNlLnN1YnN0cihpIC0gMSwgMik7XG4gICAgICAgICAgICAgICAgb25FcnJvcihpIC0gMSwgJ0JBRF9EUV9FU0NBUEUnLCBgSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgJHtyYXd9YCk7XG4gICAgICAgICAgICAgICAgcmVzICs9IHJhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICAgICAgLy8gdHJpbSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBjb25zdCB3c1N0YXJ0ID0gaTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gc291cmNlW2kgKyAxXTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnXFxuJyAmJiAhKG5leHQgPT09ICdcXHInICYmIHNvdXJjZVtpICsgMl0gPT09ICdcXG4nKSlcbiAgICAgICAgICAgICAgICByZXMgKz0gaSA+IHdzU3RhcnQgPyBzb3VyY2Uuc2xpY2Uod3NTdGFydCwgaSArIDEpIDogY2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09ICdcIicgfHwgc291cmNlLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgb25FcnJvcihzb3VyY2UubGVuZ3RoLCAnTUlTU0lOR19DSEFSJywgJ01pc3NpbmcgY2xvc2luZyBcInF1b3RlJyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogRm9sZCBhIHNpbmdsZSBuZXdsaW5lIGludG8gYSBzcGFjZSwgbXVsdGlwbGUgbmV3bGluZXMgdG8gTiAtIDEgbmV3bGluZXMuXG4gKiBQcmVzdW1lcyBgc291cmNlW29mZnNldF0gPT09ICdcXG4nYFxuICovXG5mdW5jdGlvbiBmb2xkTmV3bGluZShzb3VyY2UsIG9mZnNldCkge1xuICAgIGxldCBmb2xkID0gJyc7XG4gICAgbGV0IGNoID0gc291cmNlW29mZnNldCArIDFdO1xuICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JyB8fCBjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHInKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW29mZnNldCArIDJdICE9PSAnXFxuJylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgZm9sZCArPSAnXFxuJztcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIGNoID0gc291cmNlW29mZnNldCArIDFdO1xuICAgIH1cbiAgICBpZiAoIWZvbGQpXG4gICAgICAgIGZvbGQgPSAnICc7XG4gICAgcmV0dXJuIHsgZm9sZCwgb2Zmc2V0IH07XG59XG5jb25zdCBlc2NhcGVDb2RlcyA9IHtcbiAgICAnMCc6ICdcXDAnLCAvLyBudWxsIGNoYXJhY3RlclxuICAgIGE6ICdcXHgwNycsIC8vIGJlbGwgY2hhcmFjdGVyXG4gICAgYjogJ1xcYicsIC8vIGJhY2tzcGFjZVxuICAgIGU6ICdcXHgxYicsIC8vIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICBmOiAnXFxmJywgLy8gZm9ybSBmZWVkXG4gICAgbjogJ1xcbicsIC8vIGxpbmUgZmVlZFxuICAgIHI6ICdcXHInLCAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICB0OiAnXFx0JywgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICB2OiAnXFx2JywgLy8gdmVydGljYWwgdGFiXG4gICAgTjogJ1xcdTAwODUnLCAvLyBVbmljb2RlIG5leHQgbGluZVxuICAgIF86ICdcXHUwMGEwJywgLy8gVW5pY29kZSBub24tYnJlYWtpbmcgc3BhY2VcbiAgICBMOiAnXFx1MjAyOCcsIC8vIFVuaWNvZGUgbGluZSBzZXBhcmF0b3JcbiAgICBQOiAnXFx1MjAyOScsIC8vIFVuaWNvZGUgcGFyYWdyYXBoIHNlcGFyYXRvclxuICAgICcgJzogJyAnLFxuICAgICdcIic6ICdcIicsXG4gICAgJy8nOiAnLycsXG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgJ1xcdCc6ICdcXHQnXG59O1xuZnVuY3Rpb24gcGFyc2VDaGFyQ29kZShzb3VyY2UsIG9mZnNldCwgbGVuZ3RoLCBvbkVycm9yKSB7XG4gICAgY29uc3QgY2MgPSBzb3VyY2Uuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICBjb25zdCBvayA9IGNjLmxlbmd0aCA9PT0gbGVuZ3RoICYmIC9eWzAtOWEtZkEtRl0rJC8udGVzdChjYyk7XG4gICAgY29uc3QgY29kZSA9IG9rID8gcGFyc2VJbnQoY2MsIDE2KSA6IE5hTjtcbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgICAgY29uc3QgcmF3ID0gc291cmNlLnN1YnN0cihvZmZzZXQgLSAyLCBsZW5ndGggKyAyKTtcbiAgICAgICAgb25FcnJvcihvZmZzZXQgLSAyLCAnQkFEX0RRX0VTQ0FQRScsIGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSAke3Jhd31gKTtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBTQ0FMQVIgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUJsb2NrU2NhbGFyIH0gZnJvbSAnLi9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9IGZyb20gJy4vcmVzb2x2ZS1mbG93LXNjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IHZhbHVlLCB0eXBlLCBjb21tZW50LCByYW5nZSB9ID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgPyByZXNvbHZlQmxvY2tTY2FsYXIoY3R4LCB0b2tlbiwgb25FcnJvcilcbiAgICAgICAgOiByZXNvbHZlRmxvd1NjYWxhcih0b2tlbiwgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBjb25zdCB0YWdOYW1lID0gdGFnVG9rZW5cbiAgICAgICAgPyBjdHguZGlyZWN0aXZlcy50YWdOYW1lKHRhZ1Rva2VuLnNvdXJjZSwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpKVxuICAgICAgICA6IG51bGw7XG4gICAgbGV0IHRhZztcbiAgICBpZiAoY3R4Lm9wdGlvbnMuc3RyaW5nS2V5cyAmJiBjdHguYXRLZXkpIHtcbiAgICAgICAgdGFnID0gY3R4LnNjaGVtYVtTQ0FMQVJdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YWdOYW1lKVxuICAgICAgICB0YWcgPSBmaW5kU2NhbGFyVGFnQnlOYW1lKGN0eC5zY2hlbWEsIHZhbHVlLCB0YWdOYW1lLCB0YWdUb2tlbiwgb25FcnJvcik7XG4gICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicpXG4gICAgICAgIHRhZyA9IGZpbmRTY2FsYXJUYWdCeVRlc3QoY3R4LCB2YWx1ZSwgdG9rZW4sIG9uRXJyb3IpO1xuICAgIGVsc2VcbiAgICAgICAgdGFnID0gY3R4LnNjaGVtYVtTQ0FMQVJdO1xuICAgIGxldCBzY2FsYXI7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gdGFnLnJlc29sdmUodmFsdWUsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuID8/IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpO1xuICAgICAgICBzY2FsYXIgPSBpc1NjYWxhcihyZXMpID8gcmVzIDogbmV3IFNjYWxhcihyZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBvbkVycm9yKHRhZ1Rva2VuID8/IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKTtcbiAgICAgICAgc2NhbGFyID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgfVxuICAgIHNjYWxhci5yYW5nZSA9IHJhbmdlO1xuICAgIHNjYWxhci5zb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgc2NhbGFyLnR5cGUgPSB0eXBlO1xuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBzY2FsYXIudGFnID0gdGFnTmFtZTtcbiAgICBpZiAodGFnLmZvcm1hdClcbiAgICAgICAgc2NhbGFyLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIHNjYWxhci5jb21tZW50ID0gY29tbWVudDtcbiAgICByZXR1cm4gc2NhbGFyO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5TmFtZShzY2hlbWEsIHZhbHVlLCB0YWdOYW1lLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGlmICh0YWdOYW1lID09PSAnIScpXG4gICAgICAgIHJldHVybiBzY2hlbWFbU0NBTEFSXTsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgIGNvbnN0IG1hdGNoV2l0aFRlc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBzY2hlbWEudGFncykge1xuICAgICAgICBpZiAoIXRhZy5jb2xsZWN0aW9uICYmIHRhZy50YWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmICh0YWcuZGVmYXVsdCAmJiB0YWcudGVzdClcbiAgICAgICAgICAgICAgICBtYXRjaFdpdGhUZXN0LnB1c2godGFnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGFnIG9mIG1hdGNoV2l0aFRlc3QpXG4gICAgICAgIGlmICh0YWcudGVzdD8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgIGNvbnN0IGt0ID0gc2NoZW1hLmtub3duVGFnc1t0YWdOYW1lXTtcbiAgICBpZiAoa3QgJiYgIWt0LmNvbGxlY3Rpb24pIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGtub3duIHRhZyBpcyBhdmFpbGFibGUgZm9yIHN0cmluZ2lmeWluZyxcbiAgICAgICAgLy8gYnV0IGRvZXMgbm90IGdldCB1c2VkIGJ5IGRlZmF1bHQuXG4gICAgICAgIHNjaGVtYS50YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHsgZGVmYXVsdDogZmFsc2UsIHRlc3Q6IHVuZGVmaW5lZCB9KSk7XG4gICAgICAgIHJldHVybiBrdDtcbiAgICB9XG4gICAgb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIGBVbnJlc29sdmVkIHRhZzogJHt0YWdOYW1lfWAsIHRhZ05hbWUgIT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInKTtcbiAgICByZXR1cm4gc2NoZW1hW1NDQUxBUl07XG59XG5mdW5jdGlvbiBmaW5kU2NhbGFyVGFnQnlUZXN0KHsgYXRLZXksIGRpcmVjdGl2ZXMsIHNjaGVtYSB9LCB2YWx1ZSwgdG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0YWcgPSBzY2hlbWEudGFncy5maW5kKHRhZyA9PiAodGFnLmRlZmF1bHQgPT09IHRydWUgfHwgKGF0S2V5ICYmIHRhZy5kZWZhdWx0ID09PSAna2V5JykpICYmXG4gICAgICAgIHRhZy50ZXN0Py50ZXN0KHZhbHVlKSkgfHwgc2NoZW1hW1NDQUxBUl07XG4gICAgaWYgKHNjaGVtYS5jb21wYXQpIHtcbiAgICAgICAgY29uc3QgY29tcGF0ID0gc2NoZW1hLmNvbXBhdC5maW5kKHRhZyA9PiB0YWcuZGVmYXVsdCAmJiB0YWcudGVzdD8udGVzdCh2YWx1ZSkpID8/XG4gICAgICAgICAgICBzY2hlbWFbU0NBTEFSXTtcbiAgICAgICAgaWYgKHRhZy50YWcgIT09IGNvbXBhdC50YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnLnRhZyk7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKGNvbXBhdC50YWcpO1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFZhbHVlIG1heSBiZSBwYXJzZWQgYXMgZWl0aGVyICR7dHN9IG9yICR7Y3N9YDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VTY2FsYXIgfTtcbiIsICJmdW5jdGlvbiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpIHtcbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIHBvcyA/PyAocG9zID0gYmVmb3JlLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3MgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgbGV0IHN0ID0gYmVmb3JlW2ldO1xuICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gc3Quc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUZWNobmljYWxseSwgYW4gZW1wdHkgc2NhbGFyIGlzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBsYXN0IG5vbi1lbXB0eVxuICAgICAgICAgICAgLy8gbm9kZSwgYnV0IGl0J3MgbW9yZSB1c2VmdWwgdG8gcGxhY2UgaXQgYWZ0ZXIgYW55IHdoaXRlc3BhY2UuXG4gICAgICAgICAgICBzdCA9IGJlZm9yZVsrK2ldO1xuICAgICAgICAgICAgd2hpbGUgKHN0Py50eXBlID09PSAnc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydCB7IGVtcHR5U2NhbGFyUG9zaXRpb24gfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvaWRlbnRpdHkuanMnO1xuaW1wb3J0IHsgY29tcG9zZUNvbGxlY3Rpb24gfSBmcm9tICcuL2NvbXBvc2UtY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBjb21wb3NlU2NhbGFyIH0gZnJvbSAnLi9jb21wb3NlLXNjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyBlbXB0eVNjYWxhclBvc2l0aW9uIH0gZnJvbSAnLi91dGlsLWVtcHR5LXNjYWxhci1wb3NpdGlvbi5qcyc7XG5cbmNvbnN0IENOID0geyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9O1xuZnVuY3Rpb24gY29tcG9zZU5vZGUoY3R4LCB0b2tlbiwgcHJvcHMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBhdEtleSA9IGN0eC5hdEtleTtcbiAgICBjb25zdCB7IHNwYWNlQmVmb3JlLCBjb21tZW50LCBhbmNob3IsIHRhZyB9ID0gcHJvcHM7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGlzU3JjVG9rZW4gPSB0cnVlO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUFsaWFzKGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0FMSUFTX1BST1BTJywgJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKVxuICAgICAgICAgICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRva2VuLnR5cGUgPT09ICdlcnJvcidcbiAgICAgICAgICAgICAgICA/IHRva2VuLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA6IGBVbnN1cHBvcnRlZCB0b2tlbiAodHlwZTogJHt0b2tlbi50eXBlfSlgO1xuICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIG5vZGUgPSBjb21wb3NlRW1wdHlOb2RlKGN0eCwgdG9rZW4ub2Zmc2V0LCB1bmRlZmluZWQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlzU3JjVG9rZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYW5jaG9yICYmIG5vZGUuYW5jaG9yID09PSAnJylcbiAgICAgICAgb25FcnJvcihhbmNob3IsICdCQURfQUxJQVMnLCAnQW5jaG9yIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgICBpZiAoYXRLZXkgJiZcbiAgICAgICAgY3R4Lm9wdGlvbnMuc3RyaW5nS2V5cyAmJlxuICAgICAgICAoIWlzU2NhbGFyKG5vZGUpIHx8XG4gICAgICAgICAgICB0eXBlb2Ygbm9kZS52YWx1ZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChub2RlLnRhZyAmJiBub2RlLnRhZyAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicpKSkge1xuICAgICAgICBjb25zdCBtc2cgPSAnV2l0aCBzdHJpbmdLZXlzLCBhbGwga2V5cyBtdXN0IGJlIHN0cmluZ3MnO1xuICAgICAgICBvbkVycm9yKHRhZyA/PyB0b2tlbiwgJ05PTl9TVFJJTkdfS0VZJywgbXNnKTtcbiAgICB9XG4gICAgaWYgKHNwYWNlQmVmb3JlKVxuICAgICAgICBub2RlLnNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicgJiYgdG9rZW4uc291cmNlID09PSAnJylcbiAgICAgICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuY29tbWVudEJlZm9yZSA9IGNvbW1lbnQ7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVHlwZSBjaGVja2luZyBtaXNzZXMgbWVhbmluZyBvZiBpc1NyY1Rva2VuXG4gICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMgJiYgaXNTcmNUb2tlbilcbiAgICAgICAgbm9kZS5zcmNUb2tlbiA9IHRva2VuO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUVtcHR5Tm9kZShjdHgsIG9mZnNldCwgYmVmb3JlLCBwb3MsIHsgc3BhY2VCZWZvcmUsIGNvbW1lbnQsIGFuY2hvciwgdGFnLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAnc2NhbGFyJyxcbiAgICAgICAgb2Zmc2V0OiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpLFxuICAgICAgICBpbmRlbnQ6IC0xLFxuICAgICAgICBzb3VyY2U6ICcnXG4gICAgfTtcbiAgICBjb25zdCBub2RlID0gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSAnJylcbiAgICAgICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChzcGFjZUJlZm9yZSlcbiAgICAgICAgbm9kZS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgbm9kZS5jb21tZW50ID0gY29tbWVudDtcbiAgICAgICAgbm9kZS5yYW5nZVsyXSA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlQWxpYXMoeyBvcHRpb25zIH0sIHsgb2Zmc2V0LCBzb3VyY2UsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3QgYWxpYXMgPSBuZXcgQWxpYXMoc291cmNlLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZSA9PT0gJycpXG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0FMSUFTJywgJ0FsaWFzIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgICBpZiAoYWxpYXMuc291cmNlLmVuZHNXaXRoKCc6JykpXG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgc291cmNlLmxlbmd0aCAtIDEsICdCQURfQUxJQVMnLCAnQWxpYXMgZW5kaW5nIGluIDogaXMgYW1iaWd1b3VzJywgdHJ1ZSk7XG4gICAgY29uc3QgdmFsdWVFbmQgPSBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBvcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgYWxpYXMucmFuZ2UgPSBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XTtcbiAgICBpZiAocmUuY29tbWVudClcbiAgICAgICAgYWxpYXMuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgcmV0dXJuIGFsaWFzO1xufVxuXG5leHBvcnQgeyBjb21wb3NlRW1wdHlOb2RlLCBjb21wb3NlTm9kZSB9O1xuIiwgImltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0gZnJvbSAnLi9jb21wb3NlLW5vZGUuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcblxuZnVuY3Rpb24gY29tcG9zZURvYyhvcHRpb25zLCBkaXJlY3RpdmVzLCB7IG9mZnNldCwgc3RhcnQsIHZhbHVlLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgX2RpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZG9jID0gbmV3IERvY3VtZW50KHVuZGVmaW5lZCwgb3B0cyk7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgICBhdEtleTogZmFsc2UsXG4gICAgICAgIGF0Um9vdDogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aXZlczogZG9jLmRpcmVjdGl2ZXMsXG4gICAgICAgIG9wdGlvbnM6IGRvYy5vcHRpb25zLFxuICAgICAgICBzY2hlbWE6IGRvYy5zY2hlbWFcbiAgICB9O1xuICAgIGNvbnN0IHByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgIGluZGljYXRvcjogJ2RvYy1zdGFydCcsXG4gICAgICAgIG5leHQ6IHZhbHVlID8/IGVuZD8uWzBdLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHBhcmVudEluZGVudDogMCxcbiAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuZm91bmQpIHtcbiAgICAgICAgZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZS50eXBlID09PSAnYmxvY2stbWFwJyB8fCB2YWx1ZS50eXBlID09PSAnYmxvY2stc2VxJykgJiZcbiAgICAgICAgICAgICFwcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgb25FcnJvcihwcm9wcy5lbmQsICdNSVNTSU5HX0NIQVInLCAnQmxvY2sgY29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgb24gc2FtZSBsaW5lIHdpdGggZGlyZWN0aXZlcy1lbmQgbWFya2VyJyk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSWYgQ29udGVudHMgaXMgc2V0LCBsZXQncyB0cnVzdCB0aGUgdXNlclxuICAgIGRvYy5jb250ZW50cyA9IHZhbHVlXG4gICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICBjb25zdCBjb250ZW50RW5kID0gZG9jLmNvbnRlbnRzLnJhbmdlWzJdO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIGNvbnRlbnRFbmQsIGZhbHNlLCBvbkVycm9yKTtcbiAgICBpZiAocmUuY29tbWVudClcbiAgICAgICAgZG9jLmNvbW1lbnQgPSByZS5jb21tZW50O1xuICAgIGRvYy5yYW5nZSA9IFtvZmZzZXQsIGNvbnRlbnRFbmQsIHJlLm9mZnNldF07XG4gICAgcmV0dXJuIGRvYztcbn1cblxuZXhwb3J0IHsgY29tcG9zZURvYyB9O1xuIiwgImltcG9ydCB7IERpcmVjdGl2ZXMgfSBmcm9tICcuLi9kb2MvZGlyZWN0aXZlcy5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4uL2RvYy9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBZQU1MV2FybmluZywgWUFNTFBhcnNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgaXNDb2xsZWN0aW9uLCBpc1BhaXIgfSBmcm9tICcuLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBjb21wb3NlRG9jIH0gZnJvbSAnLi9jb21wb3NlLWRvYy5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5cbmZ1bmN0aW9uIGdldEVycm9yUG9zKHNyYykge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIFtzcmMsIHNyYyArIDFdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgIHJldHVybiBzcmMubGVuZ3RoID09PSAyID8gc3JjIDogW3NyY1swXSwgc3JjWzFdXTtcbiAgICBjb25zdCB7IG9mZnNldCwgc291cmNlIH0gPSBzcmM7XG4gICAgcmV0dXJuIFtvZmZzZXQsIG9mZnNldCArICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/IHNvdXJjZS5sZW5ndGggOiAxKV07XG59XG5mdW5jdGlvbiBwYXJzZVByZWx1ZGUocHJlbHVkZSkge1xuICAgIGxldCBjb21tZW50ID0gJyc7XG4gICAgbGV0IGF0Q29tbWVudCA9IGZhbHNlO1xuICAgIGxldCBhZnRlckVtcHR5TGluZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlbHVkZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBwcmVsdWRlW2ldO1xuICAgICAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgY29tbWVudCArPVxuICAgICAgICAgICAgICAgICAgICAoY29tbWVudCA9PT0gJycgPyAnJyA6IGFmdGVyRW1wdHlMaW5lID8gJ1xcblxcbicgOiAnXFxuJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnKTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBpZiAocHJlbHVkZVtpICsgMV0/LlswXSAhPT0gJyMnKVxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIHdyb25nIGFmdGVyIGRvYy1lbmQsIGJ1dCBpbiB0aGF0IGNhc2UgaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICBpZiAoIWF0Q29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJFbXB0eUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbW1lbnQsIGFmdGVyRW1wdHlMaW5lIH07XG59XG4vKipcbiAqIENvbXBvc2UgYSBzdHJlYW0gb2YgQ1NUIG5vZGVzIGludG8gYSBzdHJlYW0gb2YgWUFNTCBEb2N1bWVudHMuXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvc2VyLCBQYXJzZXIgfSBmcm9tICd5YW1sJ1xuICpcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBjb25zdCB0b2tlbnMgPSBuZXcgUGFyc2VyKCkucGFyc2Uoc3JjKVxuICogY29uc3QgZG9jcyA9IG5ldyBDb21wb3NlcigpLmNvbXBvc2UodG9rZW5zKVxuICogYGBgXG4gKi9cbmNsYXNzIENvbXBvc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5kb2MgPSBudWxsO1xuICAgICAgICB0aGlzLmF0RGlyZWN0aXZlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZWx1ZGUgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSAoc291cmNlLCBjb2RlLCBtZXNzYWdlLCB3YXJuaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFcnJvclBvcyhzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHdhcm5pbmcpXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKG5ldyBZQU1MV2FybmluZyhwb3MsIGNvZGUsIG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBZQU1MUGFyc2VFcnJvcihwb3MsIGNvZGUsIG1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uIHx8ICcxLjInIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBkZWNvcmF0ZShkb2MsIGFmdGVyRG9jKSB7XG4gICAgICAgIGNvbnN0IHsgY29tbWVudCwgYWZ0ZXJFbXB0eUxpbmUgfSA9IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHsgZGM6IGRvYy5jb21tZW50LCBwcmVsdWRlLCBjb21tZW50IH0pXG4gICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkYyA9IGRvYy5jb250ZW50cztcbiAgICAgICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50ID0gZG9jLmNvbW1lbnQgPyBgJHtkb2MuY29tbWVudH1cXG4ke2NvbW1lbnR9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZnRlckVtcHR5TGluZSB8fCBkb2MuZGlyZWN0aXZlcy5kb2NTdGFydCB8fCAhZGMpIHtcbiAgICAgICAgICAgICAgICBkb2MuY29tbWVudEJlZm9yZSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb24oZGMpICYmICFkYy5mbG93ICYmIGRjLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgaXQgPSBkYy5pdGVtc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYWlyKGl0KSlcbiAgICAgICAgICAgICAgICAgICAgaXQgPSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBpdC5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGl0LmNvbW1lbnRCZWZvcmUgPSBjYiA/IGAke2NvbW1lbnR9XFxuJHtjYn1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gZGMuY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBkYy5jb21tZW50QmVmb3JlID0gY2IgPyBgJHtjb21tZW50fVxcbiR7Y2J9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyRG9jKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkb2MuZXJyb3JzLCB0aGlzLmVycm9ycyk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkb2Mud2FybmluZ3MsIHRoaXMud2FybmluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9jLmVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgICAgICAgICAgZG9jLndhcm5pbmdzID0gdGhpcy53YXJuaW5ncztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZWx1ZGUgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0cmVhbSBzdGF0dXMgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBNb3N0bHkgdXNlZnVsIGF0IHRoZSBlbmQgb2YgaW5wdXQgZm9yIGFuIGVtcHR5IHN0cmVhbS5cbiAgICAgKi9cbiAgICBzdHJlYW1JbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWVudDogcGFyc2VQcmVsdWRlKHRoaXMucHJlbHVkZSkuY29tbWVudCxcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IHRoaXMuZGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5lcnJvcnMsXG4gICAgICAgICAgICB3YXJuaW5nczogdGhpcy53YXJuaW5nc1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wb3NlIHRva2VucyBpbnRvIGRvY3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZURvYyAtIElmIHRoZSBzdHJlYW0gY29udGFpbnMgbm8gZG9jdW1lbnQsIHN0aWxsIGVtaXQgYSBmaW5hbCBkb2N1bWVudCBpbmNsdWRpbmcgYW55IGNvbW1lbnRzIGFuZCBkaXJlY3RpdmVzIHRoYXQgd291bGQgYmUgYXBwbGllZCB0byBhIHN1YnNlcXVlbnQgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIGVuZE9mZnNldCAtIFNob3VsZCBiZSBzZXQgaWYgYGZvcmNlRG9jYCBpcyBhbHNvIHNldCwgdG8gc2V0IHRoZSBkb2N1bWVudCByYW5nZSBlbmQgYW5kIHRvIGluZGljYXRlIGVycm9ycyBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgKmNvbXBvc2UodG9rZW5zLCBmb3JjZURvYyA9IGZhbHNlLCBlbmRPZmZzZXQgPSAtMSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2VucylcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLm5leHQodG9rZW4pO1xuICAgICAgICB5aWVsZCogdGhpcy5lbmQoZm9yY2VEb2MsIGVuZE9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBBZHZhbmNlIHRoZSBjb21wb3NlciBieSBvbmUgQ1NUIHRva2VuLiAqL1xuICAgICpuZXh0KHRva2VuKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0aXZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuYWRkKHRva2VuLnNvdXJjZSwgKG9mZnNldCwgbWVzc2FnZSwgd2FybmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFcnJvclBvcyh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHBvc1swXSArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihwb3MsICdCQURfRElSRUNUSVZFJywgbWVzc2FnZSwgd2FybmluZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVsdWRlLnB1c2godG9rZW4uc291cmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0RGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSBjb21wb3NlRG9jKHRoaXMub3B0aW9ucywgdGhpcy5kaXJlY3RpdmVzLCB0b2tlbiwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgJiYgIWRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZC9kb2Mtc3RhcnQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRlKGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvYylcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kb2M7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2J5dGUtb3JkZXItbWFyayc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0b2tlbi5zb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBgJHt0b2tlbi5tZXNzYWdlfTogJHtKU09OLnN0cmluZ2lmeSh0b2tlbi5zb3VyY2UpfWBcbiAgICAgICAgICAgICAgICAgICAgOiB0b2tlbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBtc2cpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0RGlyZWN0aXZlcyB8fCAhdGhpcy5kb2MpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2MuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZG9jLWVuZCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdVbmV4cGVjdGVkIGRvYy1lbmQgd2l0aG91dCBwcmVjZWRpbmcgZG9jdW1lbnQnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgbXNnKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRvYy5kaXJlY3RpdmVzLmRvY0VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcmVzb2x2ZUVuZCh0b2tlbi5lbmQsIHRva2VuLm9mZnNldCArIHRva2VuLnNvdXJjZS5sZW5ndGgsIHRoaXMuZG9jLm9wdGlvbnMuc3RyaWN0LCB0aGlzLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUodGhpcy5kb2MsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmQuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYyA9IHRoaXMuZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmNvbW1lbnQgPSBkYyA/IGAke2RjfVxcbiR7ZW5kLmNvbW1lbnR9YCA6IGVuZC5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRvYy5yYW5nZVsyXSA9IGVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5zdXBwb3J0ZWQgdG9rZW4gJHt0b2tlbi50eXBlfWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGF0IGVuZCBvZiBpbnB1dCB0byB5aWVsZCBhbnkgcmVtYWluaW5nIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqZW5kKGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGlmICh0aGlzLmRvYykge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZSh0aGlzLmRvYywgdHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRvYztcbiAgICAgICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZURvYykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBfZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQodW5kZWZpbmVkLCBvcHRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0RGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoZW5kT2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ01pc3NpbmcgZGlyZWN0aXZlcy1lbmQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICAgICAgICAgIGRvYy5yYW5nZSA9IFswLCBlbmRPZmZzZXQsIGVuZE9mZnNldF07XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlKGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgeWllbGQgZG9jO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21wb3NlciB9O1xuIiwgImNvbnN0IEJSRUFLID0gU3ltYm9sKCdicmVhayB2aXNpdCcpO1xuY29uc3QgU0tJUCA9IFN5bWJvbCgnc2tpcCBjaGlsZHJlbicpO1xuY29uc3QgUkVNT1ZFID0gU3ltYm9sKCdyZW1vdmUgaXRlbScpO1xuLyoqXG4gKiBBcHBseSBhIHZpc2l0b3IgdG8gYSBDU1QgZG9jdW1lbnQgb3IgaXRlbS5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0d28gYXJndW1lbnRzIHdoZW4gZW50ZXJpbmcgZWFjaCBpdGVtOlxuICogICAtIGBpdGVtYDogVGhlIGN1cnJlbnQgaXRlbSwgd2hpY2ggaW5jbHVkZWQgdGhlIGZvbGxvd2luZyBtZW1iZXJzOlxuICogICAgIC0gYHN0YXJ0OiBTb3VyY2VUb2tlbltdYCBcdTIwMTMgU291cmNlIHRva2VucyBiZWZvcmUgdGhlIGtleSBvciB2YWx1ZSxcbiAqICAgICAgIHBvc3NpYmx5IGluY2x1ZGluZyBpdHMgYW5jaG9yIG9yIHRhZy5cbiAqICAgICAtIGBrZXk/OiBUb2tlbiB8IG51bGxgIFx1MjAxMyBTZXQgZm9yIHBhaXIgdmFsdWVzLiBNYXkgdGhlbiBiZSBgbnVsbGAsIGlmXG4gKiAgICAgICB0aGUga2V5IGJlZm9yZSB0aGUgYDpgIHNlcGFyYXRvciBpcyBlbXB0eS5cbiAqICAgICAtIGBzZXA/OiBTb3VyY2VUb2tlbltdYCBcdTIwMTMgU291cmNlIHRva2VucyBiZXR3ZWVuIHRoZSBrZXkgYW5kIHRoZSB2YWx1ZSxcbiAqICAgICAgIHdoaWNoIHNob3VsZCBpbmNsdWRlIHRoZSBgOmAgbWFwIHZhbHVlIGluZGljYXRvciBpZiBgdmFsdWVgIGlzIHNldC5cbiAqICAgICAtIGB2YWx1ZT86IFRva2VuYCBcdTIwMTMgVGhlIHZhbHVlIG9mIGEgc2VxdWVuY2UgaXRlbSwgb3Igb2YgYSBtYXAgcGFpci5cbiAqICAgLSBgcGF0aGA6IFRoZSBzdGVwcyBmcm9tIHRoZSByb290IHRvIHRoZSBjdXJyZW50IG5vZGUsIGFzIGFuIGFycmF5IG9mXG4gKiAgICAgYFsna2V5JyB8ICd2YWx1ZScsIG51bWJlcl1gIHR1cGxlcy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgdG9rZW4sIGNvbnRpbnVlIHdpdGhcbiAqICAgICAgbmV4dCBzaWJsaW5nXG4gKiAgIC0gYHZpc2l0LkJSRUFLYDogVGVybWluYXRlIHRyYXZlcnNhbCBjb21wbGV0ZWx5XG4gKiAgIC0gYHZpc2l0LlJFTU9WRWA6IFJlbW92ZSB0aGUgY3VycmVudCBpdGVtLCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgb25lXG4gKiAgIC0gYG51bWJlcmA6IFNldCB0aGUgaW5kZXggb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZlxuICogICAgIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCB0b2tlbiBoYXMgY2hhbmdlZC5cbiAqICAgLSBgZnVuY3Rpb25gOiBEZWZpbmUgdGhlIG5leHQgdmlzaXRvciBmb3IgdGhpcyBpdGVtLiBBZnRlciB0aGUgb3JpZ2luYWxcbiAqICAgICB2aXNpdG9yIGlzIGNhbGxlZCBvbiBpdGVtIGVudHJ5LCBuZXh0IHZpc2l0b3JzIGFyZSBjYWxsZWQgYWZ0ZXIgaGFuZGxpbmdcbiAqICAgICBhIG5vbi1lbXB0eSBga2V5YCBhbmQgd2hlbiBleGl0aW5nIHRoZSBpdGVtLlxuICovXG5mdW5jdGlvbiB2aXNpdChjc3QsIHZpc2l0b3IpIHtcbiAgICBpZiAoJ3R5cGUnIGluIGNzdCAmJiBjc3QudHlwZSA9PT0gJ2RvY3VtZW50JylcbiAgICAgICAgY3N0ID0geyBzdGFydDogY3N0LnN0YXJ0LCB2YWx1ZTogY3N0LnZhbHVlIH07XG4gICAgX3Zpc2l0KE9iamVjdC5mcmVlemUoW10pLCBjc3QsIHZpc2l0b3IpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgaXRlbSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IGl0ZW0gKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbi8qKiBGaW5kIHRoZSBpdGVtIGF0IGBwYXRoYCBmcm9tIGBjc3RgIGFzIHRoZSByb290ICovXG52aXNpdC5pdGVtQXRQYXRoID0gKGNzdCwgcGF0aCkgPT4ge1xuICAgIGxldCBpdGVtID0gY3N0O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkLCBpbmRleF0gb2YgcGF0aCkge1xuICAgICAgICBjb25zdCB0b2sgPSBpdGVtPy5bZmllbGRdO1xuICAgICAgICBpZiAodG9rICYmICdpdGVtcycgaW4gdG9rKSB7XG4gICAgICAgICAgICBpdGVtID0gdG9rLml0ZW1zW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn07XG4vKipcbiAqIEdldCB0aGUgaW1tZWRpYXRlIHBhcmVudCBjb2xsZWN0aW9uIG9mIHRoZSBpdGVtIGF0IGBwYXRoYCBmcm9tIGBjc3RgIGFzIHRoZSByb290LlxuICpcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgY29sbGVjdGlvbiBpcyBub3QgZm91bmQsIHdoaWNoIHNob3VsZCBuZXZlciBoYXBwZW4gaWYgdGhlIGl0ZW0gaXRzZWxmIGV4aXN0cy5cbiAqL1xudmlzaXQucGFyZW50Q29sbGVjdGlvbiA9IChjc3QsIHBhdGgpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSB2aXNpdC5pdGVtQXRQYXRoKGNzdCwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdWzBdO1xuICAgIGNvbnN0IGNvbGwgPSBwYXJlbnQ/LltmaWVsZF07XG4gICAgaWYgKGNvbGwgJiYgJ2l0ZW1zJyBpbiBjb2xsKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBjb2xsZWN0aW9uIG5vdCBmb3VuZCcpO1xufTtcbmZ1bmN0aW9uIF92aXNpdChwYXRoLCBpdGVtLCB2aXNpdG9yKSB7XG4gICAgbGV0IGN0cmwgPSB2aXNpdG9yKGl0ZW0sIHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgIHJldHVybiBjdHJsO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgWydrZXknLCAndmFsdWUnXSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGl0ZW1bZmllbGRdO1xuICAgICAgICBpZiAodG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbi5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQoW1tmaWVsZCwgaV1dKSksIHRva2VuLml0ZW1zW2ldLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWVsZCA9PT0gJ2tleScpXG4gICAgICAgICAgICAgICAgY3RybCA9IGN0cmwoaXRlbSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nID8gY3RybChpdGVtLCBwYXRoKSA6IGN0cmw7XG59XG5cbmV4cG9ydCB7IHZpc2l0IH07XG4iLCAiZXhwb3J0IHsgY3JlYXRlU2NhbGFyVG9rZW4sIHJlc29sdmVBc1NjYWxhciwgc2V0U2NhbGFyVmFsdWUgfSBmcm9tICcuL2NzdC1zY2FsYXIuanMnO1xuZXhwb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9jc3Qtc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IHZpc2l0IH0gZnJvbSAnLi9jc3QtdmlzaXQuanMnO1xuXG4vKiogVGhlIGJ5dGUgb3JkZXIgbWFyayAqL1xuY29uc3QgQk9NID0gJ1xcdXtGRUZGfSc7XG4vKiogU3RhcnQgb2YgZG9jLW1vZGUgKi9cbmNvbnN0IERPQ1VNRU5UID0gJ1xceDAyJzsgLy8gQzA6IFN0YXJ0IG9mIFRleHRcbi8qKiBVbmV4cGVjdGVkIGVuZCBvZiBmbG93LW1vZGUgKi9cbmNvbnN0IEZMT1dfRU5EID0gJ1xceDE4JzsgLy8gQzA6IENhbmNlbFxuLyoqIE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbmNvbnN0IFNDQUxBUiA9ICdcXHgxZic7IC8vIEMwOiBVbml0IFNlcGFyYXRvclxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBjb2xsZWN0aW9uICovXG5jb25zdCBpc0NvbGxlY3Rpb24gPSAodG9rZW4pID0+ICEhdG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbjtcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgc2NhbGFyOyBub3QgYW4gYWxpYXMgKi9cbmNvbnN0IGlzU2NhbGFyID0gKHRva2VuKSA9PiAhIXRva2VuICYmXG4gICAgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdzaW5nbGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJyk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqIEdldCBhIHByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIGxleGVyIHRva2VuICovXG5mdW5jdGlvbiBwcmV0dHlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJzxCT00+JztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnPERPQz4nO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICc8RkxPV19FTkQ+JztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJzxTQ0FMQVI+JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b2tlbik7XG4gICAgfVxufVxuLyoqIElkZW50aWZ5IHRoZSB0eXBlIG9mIGEgbGV4ZXIgdG9rZW4uIE1heSByZXR1cm4gYG51bGxgIGZvciB1bmtub3duIHRva2Vucy4gKi9cbmZ1bmN0aW9uIHRva2VuVHlwZShzb3VyY2UpIHtcbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnYnl0ZS1vcmRlci1tYXJrJztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLW1vZGUnO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LWVycm9yLWVuZCc7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICdzY2FsYXInO1xuICAgICAgICBjYXNlICctLS0nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2Mtc3RhcnQnO1xuICAgICAgICBjYXNlICcuLi4nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtZW5kJztcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFxyXFxuJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV3bGluZSc7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcmV0dXJuICdzZXEtaXRlbS1pbmQnO1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdtYXAtdmFsdWUtaW5kJztcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLWVuZCc7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1zdGFydCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1lbmQnO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWEnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHJldHVybiAnc3BhY2UnO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUtbGluZSc7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgcmV0dXJuICdhbGlhcyc7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdhbmNob3InO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIHJldHVybiAndGFnJztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jay1zY2FsYXItaGVhZGVyJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IEJPTSwgRE9DVU1FTlQsIEZMT1dfRU5ELCBTQ0FMQVIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIsIHByZXR0eVRva2VuLCB0b2tlblR5cGUgfTtcbiIsICJpbXBvcnQgeyBCT00sIERPQ1VNRU5ULCBGTE9XX0VORCwgU0NBTEFSIH0gZnJvbSAnLi9jc3QuanMnO1xuXG4vKlxuU1RBUlQgLT4gc3RyZWFtXG5cbnN0cmVhbVxuICBkaXJlY3RpdmUgLT4gbGluZS1lbmQgLT4gc3RyZWFtXG4gIGluZGVudCArIGxpbmUtZW5kIC0+IHN0cmVhbVxuICBbZWxzZV0gLT4gbGluZS1zdGFydFxuXG5saW5lLWVuZFxuICBjb21tZW50IC0+IGxpbmUtZW5kXG4gIG5ld2xpbmUgLT4gLlxuICBpbnB1dC1lbmQgLT4gRU5EXG5cbmxpbmUtc3RhcnRcbiAgZG9jLXN0YXJ0IC0+IGRvY1xuICBkb2MtZW5kIC0+IHN0cmVhbVxuICBbZWxzZV0gLT4gaW5kZW50IC0+IGJsb2NrLXN0YXJ0XG5cbmJsb2NrLXN0YXJ0XG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBibG9jay1zdGFydFxuICBtYXAtdmFsdWUtc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgW2Vsc2VdIC0+IGRvY1xuXG5kb2NcbiAgbGluZS1lbmQgLT4gbGluZS1zdGFydFxuICBzcGFjZXMgLT4gZG9jXG4gIGFuY2hvciAtPiBkb2NcbiAgdGFnIC0+IGRvY1xuICBmbG93LXN0YXJ0IC0+IGZsb3cgLT4gZG9jXG4gIGZsb3ctZW5kIC0+IGVycm9yIC0+IGRvY1xuICBzZXEtaXRlbS1zdGFydCAtPiBlcnJvciAtPiBkb2NcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGVycm9yIC0+IGRvY1xuICBtYXAtdmFsdWUtc3RhcnQgLT4gZG9jXG4gIGFsaWFzIC0+IGRvY1xuICBxdW90ZS1zdGFydCAtPiBxdW90ZWQtc2NhbGFyIC0+IGRvY1xuICBibG9jay1zY2FsYXItaGVhZGVyIC0+IGxpbmUtZW5kIC0+IGJsb2NrLXNjYWxhcihtaW4pIC0+IGxpbmUtc3RhcnRcbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcihmYWxzZSwgbWluKSAtPiBkb2NcblxuZmxvd1xuICBsaW5lLWVuZCAtPiBmbG93XG4gIHNwYWNlcyAtPiBmbG93XG4gIGFuY2hvciAtPiBmbG93XG4gIHRhZyAtPiBmbG93XG4gIGZsb3ctc3RhcnQgLT4gZmxvdyAtPiBmbG93XG4gIGZsb3ctZW5kIC0+IC5cbiAgc2VxLWl0ZW0tc3RhcnQgLT4gZXJyb3IgLT4gZmxvd1xuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gZmxvd1xuICBtYXAtdmFsdWUtc3RhcnQgLT4gZmxvd1xuICBhbGlhcyAtPiBmbG93XG4gIHF1b3RlLXN0YXJ0IC0+IHF1b3RlZC1zY2FsYXIgLT4gZmxvd1xuICBjb21tYSAtPiBmbG93XG4gIFtlbHNlXSAtPiBwbGFpbi1zY2FsYXIodHJ1ZSwgMCkgLT4gZmxvd1xuXG5xdW90ZWQtc2NhbGFyXG4gIHF1b3RlLWVuZCAtPiAuXG4gIFtlbHNlXSAtPiBxdW90ZWQtc2NhbGFyXG5cbmJsb2NrLXNjYWxhcihtaW4pXG4gIG5ld2xpbmUgKyBwZWVrKGluZGVudCA8IG1pbikgLT4gLlxuICBbZWxzZV0gLT4gYmxvY2stc2NhbGFyKG1pbilcblxucGxhaW4tc2NhbGFyKGlzLWZsb3csIG1pbilcbiAgc2NhbGFyLWVuZChpcy1mbG93KSAtPiAuXG4gIHBlZWsobmV3bGluZSArIChpbmRlbnQgPCBtaW4pKSAtPiAuXG4gIFtlbHNlXSAtPiBwbGFpbi1zY2FsYXIobWluKVxuKi9cbmZ1bmN0aW9uIGlzRW1wdHkoY2gpIHtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGhleERpZ2l0cyA9IG5ldyBTZXQoJzAxMjM0NTY3ODlBQkNERUZhYmNkZWYnKTtcbmNvbnN0IHRhZ0NoYXJzID0gbmV3IFNldChcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LSM7Lz86QCY9KyRfLiF+KicoKVwiKTtcbmNvbnN0IGZsb3dJbmRpY2F0b3JDaGFycyA9IG5ldyBTZXQoJyxbXXt9Jyk7XG5jb25zdCBpbnZhbGlkQW5jaG9yQ2hhcnMgPSBuZXcgU2V0KCcgLFtde31cXG5cXHJcXHQnKTtcbmNvbnN0IGlzTm90QW5jaG9yQ2hhciA9IChjaCkgPT4gIWNoIHx8IGludmFsaWRBbmNob3JDaGFycy5oYXMoY2gpO1xuLyoqXG4gKiBTcGxpdHMgYW4gaW5wdXQgc3RyaW5nIGludG8gbGV4aWNhbCB0b2tlbnMsIGkuZS4gc21hbGxlciBzdHJpbmdzIHRoYXQgYXJlXG4gKiBlYXNpbHkgaWRlbnRpZmlhYmxlIGJ5IGB0b2tlbnMudG9rZW5UeXBlKClgLlxuICpcbiAqIExleGluZyBzdGFydHMgYWx3YXlzIGluIGEgXCJzdHJlYW1cIiBjb250ZXh0LiBJbmNvbXBsZXRlIGlucHV0IG1heSBiZSBidWZmZXJlZFxuICogdW50aWwgYSBjb21wbGV0ZSB0b2tlbiBjYW4gYmUgZW1pdHRlZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBzbGljZXMgb2YgdGhlIG9yaWdpbmFsIGlucHV0LCB0aGUgZm9sbG93aW5nIGNvbnRyb2wgY2hhcmFjdGVyc1xuICogbWF5IGFsc28gYmUgZW1pdHRlZDpcbiAqXG4gKiAtIGBcXHgwMmAgKFN0YXJ0IG9mIFRleHQpOiBBIGRvY3VtZW50IHN0YXJ0cyB3aXRoIHRoZSBuZXh0IHRva2VuXG4gKiAtIGBcXHgxOGAgKENhbmNlbCk6IFVuZXhwZWN0ZWQgZW5kIG9mIGZsb3ctbW9kZSAoaW5kaWNhdGVzIGFuIGVycm9yKVxuICogLSBgXFx4MWZgIChVbml0IFNlcGFyYXRvcik6IE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWVcbiAqIC0gYFxcdXtGRUZGfWAgKEJ5dGUgb3JkZXIgbWFyayk6IEVtaXR0ZWQgc2VwYXJhdGVseSBvdXRzaWRlIGRvY3VtZW50c1xuICovXG5jbGFzcyBMZXhlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBtYXJrcyB0aGUgZW5kIG9mXG4gICAgICAgICAqIGFsbCBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdEVuZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwbGljaXQgaW5kZW50IHNldCBpbiBibG9jayBzY2FsYXIgaGVhZGVyLCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgY3VycmVudFxuICAgICAgICAgKiBtaW5pbXVtIGluZGVudCwgc28gZS5nLiBzZXQgdG8gMSBmcm9tIGEgaGVhZGVyIGB8MitgLiBTZXQgdG8gLTEgaWYgbm90XG4gICAgICAgICAqIGV4cGxpY2l0bHkgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmxvY2sgc2NhbGFycyB0aGF0IGluY2x1ZGUgYSArIChrZWVwKSBjaG9tcGluZyBpbmRpY2F0b3IgaW4gdGhlaXIgaGVhZGVyXG4gICAgICAgICAqIGluY2x1ZGUgdHJhaWxpbmcgZW1wdHkgbGluZXMsIHdoaWNoIGFyZSBvdGhlcndpc2UgZXhjbHVkZWQgZnJvbSB0aGVcbiAgICAgICAgICogc2NhbGFyJ3MgY29udGVudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudCBpbnB1dCAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBub3Rpbmcgd2hldGhlciB0aGUgbWFwIHZhbHVlIGluZGljYXRvciA6IGNhbiBpbW1lZGlhdGVseSBmb2xsb3cgdGhpc1xuICAgICAgICAgKiBub2RlIHdpdGhpbiBhIGZsb3cgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAvKiogQ291bnQgb2Ygc3Vycm91bmRpbmcgZmxvdyBjb2xsZWN0aW9uIGxldmVscy4gKi9cbiAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWluaW11bSBsZXZlbCBvZiBpbmRlbnRhdGlvbiByZXF1aXJlZCBmb3IgbmV4dCBsaW5lcyB0byBiZSBwYXJzZWQgYXMgYVxuICAgICAgICAgKiBwYXJ0IG9mIHRoZSBjdXJyZW50IHNjYWxhciB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IDA7XG4gICAgICAgIC8qKiBJbmRlbnRhdGlvbiBsZXZlbCBvZiB0aGUgY3VycmVudCBsaW5lLiAqL1xuICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBuZXh0IFxcbiBjaGFyYWN0ZXIuICovXG4gICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIC8qKiBTdG9yZXMgdGhlIHN0YXRlIG9mIHRoZSBsZXhlciBpZiByZWFjaGluZyB0aGUgZW5kIG9mIGluY3BvbXBsZXRlIGlucHV0ICovXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8qKiBBIHBvaW50ZXIgdG8gYGJ1ZmZlcmA7IHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBsZXhlci4gKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBZQU1MIHRva2VucyBmcm9tIHRoZSBgc291cmNlYCBzdHJpbmcuIElmIGBpbmNvbXBsZXRlYCxcbiAgICAgKiBhIHBhcnQgb2YgdGhlIGxhc3QgbGluZSBtYXkgYmUgbGVmdCBhcyBhIGJ1ZmZlciBmb3IgdGhlIG5leHQgY2FsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIGxleGljYWwgdG9rZW5zXG4gICAgICovXG4gICAgKmxleChzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdzb3VyY2UgaXMgbm90IGEgc3RyaW5nJyk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIgKyBzb3VyY2UgOiBzb3VyY2U7XG4gICAgICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXRFbmQgPSAhaW5jb21wbGV0ZTtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHQgPz8gJ3N0cmVhbSc7XG4gICAgICAgIHdoaWxlIChuZXh0ICYmIChpbmNvbXBsZXRlIHx8IHRoaXMuaGFzQ2hhcnMoMSkpKVxuICAgICAgICAgICAgbmV4dCA9IHlpZWxkKiB0aGlzLnBhcnNlTmV4dChuZXh0KTtcbiAgICB9XG4gICAgYXRMaW5lRW5kKCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnIycgfHwgY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbaSArIDFdID09PSAnXFxuJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjaGFyQXQobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3MgKyBuXTtcbiAgICB9XG4gICAgY29udGludWVTY2FsYXIob2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW29mZnNldF07XG4gICAgICAgIGlmICh0aGlzLmluZGVudE5leHQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpbmRlbnQgKyBvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmJ1ZmZlcltpbmRlbnQgKyBvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicgfHwgKCFuZXh0ICYmICF0aGlzLmF0RW5kKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIGluZGVudCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2ggPT09ICdcXG4nIHx8IGluZGVudCA+PSB0aGlzLmluZGVudE5leHQgfHwgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICA/IG9mZnNldCArIGluZGVudFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLmJ1ZmZlci5zdWJzdHIob2Zmc2V0LCAzKTtcbiAgICAgICAgICAgIGlmICgoZHQgPT09ICctLS0nIHx8IGR0ID09PSAnLi4uJykgJiYgaXNFbXB0eSh0aGlzLmJ1ZmZlcltvZmZzZXQgKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmxpbmVFbmRQb3M7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCAoZW5kICE9PSAtMSAmJiBlbmQgPCB0aGlzLnBvcykpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0RW5kID8gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKSA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcltlbmQgLSAxXSA9PT0gJ1xccicpXG4gICAgICAgICAgICBlbmQgLT0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvcywgZW5kKTtcbiAgICB9XG4gICAgaGFzQ2hhcnMobikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKyBuIDw9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgc2V0TmV4dChzdGF0ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gc3RhdGU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZWVrKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgfVxuICAgICpwYXJzZU5leHQobmV4dCkge1xuICAgICAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmVhbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlU3RyZWFtKCk7XG4gICAgICAgICAgICBjYXNlICdsaW5lLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICdkb2MnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZURvY3VtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VGbG93Q29sbGVjdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAncXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICdwbGFpbi1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlU3RyZWFtKCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICBpZiAobGluZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3N0cmVhbScpO1xuICAgICAgICBpZiAobGluZVswXSA9PT0gQk9NKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVbMF0gPT09ICclJykge1xuICAgICAgICAgICAgbGV0IGRpckVuZCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNzID0gbGluZS5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICB3aGlsZSAoY3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSBsaW5lW2NzIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpckVuZCA9IGNzIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcyA9IGxpbmUuaW5kZXhPZignIycsIGNzICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbZGlyRW5kIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBkaXJFbmQgLT0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbiA9ICh5aWVsZCogdGhpcy5wdXNoQ291bnQoZGlyRW5kKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTsgLy8gcG9zc2libGUgY29tbWVudFxuICAgICAgICAgICAgdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0TGluZUVuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBzcCk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIERPQ1VNRU5UO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlTGluZVN0YXJ0KCkge1xuICAgICAgICBjb25zdCBjaCA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQgJiYgIXRoaXMuaGFzQ2hhcnMoNCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMucGVlaygzKTtcbiAgICAgICAgICAgIGlmICgocyA9PT0gJy0tLScgfHwgcyA9PT0gJy4uLicpICYmIGlzRW1wdHkodGhpcy5jaGFyQXQoMykpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDMpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMgPT09ICctLS0nID8gJ2RvYycgOiAnc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGVudFZhbHVlID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyhmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmluZGVudE5leHQgPiB0aGlzLmluZGVudFZhbHVlICYmICFpc0VtcHR5KHRoaXMuY2hhckF0KDEpKSlcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWU7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTdGFydCgpIHtcbiAgICAgICAgY29uc3QgW2NoMCwgY2gxXSA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgaWYgKCFjaDEgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zdGFydCcpO1xuICAgICAgICBpZiAoKGNoMCA9PT0gJy0nIHx8IGNoMCA9PT0gJz8nIHx8IGNoMCA9PT0gJzonKSAmJiBpc0VtcHR5KGNoMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSAoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSArPSBuO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlRG9jdW1lbnQoKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdkb2MnKTtcbiAgICAgICAgbGV0IG4gPSB5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpO1xuICAgICAgICBzd2l0Y2ggKGxpbmVbbl0pIHtcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1NjYWxhcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VQbGFpblNjYWxhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpwYXJzZUZsb3dDb2xsZWN0aW9uKCkge1xuICAgICAgICBsZXQgbmwsIHNwO1xuICAgICAgICBsZXQgaW5kZW50ID0gLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5sID0geWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIGlmIChubCA+IDApIHtcbiAgICAgICAgICAgICAgICBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXMoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSBpbmRlbnQgPSBzcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgIH0gd2hpbGUgKG5sICsgc3AgPiAwKTtcbiAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICBpZiAobGluZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Zsb3cnKTtcbiAgICAgICAgaWYgKChpbmRlbnQgIT09IC0xICYmIGluZGVudCA8IHRoaXMuaW5kZW50TmV4dCAmJiBsaW5lWzBdICE9PSAnIycpIHx8XG4gICAgICAgICAgICAoaW5kZW50ID09PSAwICYmXG4gICAgICAgICAgICAgICAgKGxpbmUuc3RhcnRzV2l0aCgnLS0tJykgfHwgbGluZS5zdGFydHNXaXRoKCcuLi4nKSkgJiZcbiAgICAgICAgICAgICAgICBpc0VtcHR5KGxpbmVbM10pKSkge1xuICAgICAgICAgICAgLy8gQWxsb3dpbmcgZm9yIHRoZSB0ZXJtaW5hbCBdIG9yIH0gYXQgdGhlIHNhbWUgKHJhdGhlciB0aGFuIGdyZWF0ZXIpXG4gICAgICAgICAgICAvLyBpbmRlbnQgbGV2ZWwgYXMgdGhlIGluaXRpYWwgWyBvciB7IGlzIHRlY2huaWNhbGx5IGludmFsaWQsIGJ1dFxuICAgICAgICAgICAgLy8gZmFpbGluZyBoZXJlIHdvdWxkIGJlIHN1cnByaXNpbmcgdG8gdXNlcnMuXG4gICAgICAgICAgICBjb25zdCBhdEZsb3dFbmRNYXJrZXIgPSBpbmRlbnQgPT09IHRoaXMuaW5kZW50TmV4dCAtIDEgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIChsaW5lWzBdID09PSAnXScgfHwgbGluZVswXSA9PT0gJ30nKTtcbiAgICAgICAgICAgIGlmICghYXRGbG93RW5kTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsID0gMDtcbiAgICAgICAgICAgICAgICB5aWVsZCBGTE9XX0VORDtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIHdoaWxlIChsaW5lW25dID09PSAnLCcpIHtcbiAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpO1xuICAgICAgICBzd2l0Y2ggKGxpbmVbbl0pIHtcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCAtPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dMZXZlbCA/ICdmbG93JyA6ICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJzonOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuY2hhckF0KDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dLZXkgfHwgaXNFbXB0eShuZXh0KSB8fCBuZXh0ID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VQbGFpblNjYWxhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpwYXJzZVF1b3RlZFNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgcXVvdGUgPSB0aGlzLmNoYXJBdCgwKTtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YocXVvdGUsIHRoaXMucG9zICsgMSk7XG4gICAgICAgIGlmIChxdW90ZSA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbmQgIT09IC0xICYmIHRoaXMuYnVmZmVyW2VuZCArIDFdID09PSBcIidcIilcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKFwiJ1wiLCBlbmQgKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZVxuICAgICAgICAgICAgd2hpbGUgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuYnVmZmVyW2VuZCAtIDEgLSBuXSA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgICAgICAgICBuICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAyID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKCdcIicsIGVuZCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgbG9va2luZyBmb3IgbmV3bGluZXMgd2l0aGluIHRoZSBxdW90ZXNcbiAgICAgICAgY29uc3QgcWIgPSB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgICAgICAgbGV0IG5sID0gcWIuaW5kZXhPZignXFxuJywgdGhpcy5wb3MpO1xuICAgICAgICBpZiAobmwgIT09IC0xKSB7XG4gICAgICAgICAgICB3aGlsZSAobmwgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKG5sICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbmwgPSBxYi5pbmRleE9mKCdcXG4nLCBjcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmwgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlcnJvciBjYXVzZWQgYnkgYW4gdW5leHBlY3RlZCB1bmluZGVudFxuICAgICAgICAgICAgICAgIGVuZCA9IG5sIC0gKHFiW25sIC0gMV0gPT09ICdcXHInID8gMiA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgncXVvdGVkLXNjYWxhcicpO1xuICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGVuZCArIDEsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0xldmVsID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU2NhbGFySGVhZGVyKCkge1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gLTE7XG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gZmFsc2U7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcrJylcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA+ICcwJyAmJiBjaCA8PSAnOScpXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IE51bWJlcihjaCkgLSAxO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggIT09ICctJylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFVudGlsKGNoID0+IGlzRW1wdHkoY2gpIHx8IGNoID09PSAnIycpO1xuICAgIH1cbiAgICAqcGFyc2VCbG9ja1NjYWxhcigpIHtcbiAgICAgICAgbGV0IG5sID0gdGhpcy5wb3MgLSAxOyAvLyBtYXkgYmUgLTEgaWYgdGhpcy5wb3MgPT09IDBcbiAgICAgICAgbGV0IGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgbG9vcDogZm9yIChsZXQgaSA9IHRoaXMucG9zOyAoY2ggPSB0aGlzLmJ1ZmZlcltpXSk7ICsraSkge1xuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgICAgICAgICAgbmwgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXHInOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc2NhbGFyJyk7XG4gICAgICAgIGlmIChpbmRlbnQgPj0gdGhpcy5pbmRlbnROZXh0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ibG9ja1NjYWxhckluZGVudCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gaW5kZW50O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCArICh0aGlzLmluZGVudE5leHQgPT09IDAgPyAxIDogdGhpcy5pbmRlbnROZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG5sICE9PSAtMSk7XG4gICAgICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUcmFpbGluZyBpbnN1ZmZpY2llbnRseSBpbmRlbnRlZCB0YWJzIGFyZSBpbnZhbGlkLlxuICAgICAgICAvLyBUbyBjYXRjaCB0aGF0IGR1cmluZyBwYXJzaW5nLCB3ZSBpbmNsdWRlIHRoZW0gaW4gdGhlIGJsb2NrIHNjYWxhciB2YWx1ZS5cbiAgICAgICAgbGV0IGkgPSBubCArIDE7XG4gICAgICAgIGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgIHdoaWxlIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICBpZiAoY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2ggPT09ICdcXHQnIHx8IGNoID09PSAnICcgfHwgY2ggPT09ICdcXHInIHx8IGNoID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICBubCA9IGkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmJsb2NrU2NhbGFyS2VlcCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBpID0gbmwgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbLS1pXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhciA9IGk7IC8vIERyb3AgdGhlIGxpbmUgaWYgbGFzdCBjaGFyIG5vdCBtb3JlIGluZGVudGVkXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbLS1pXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nICYmIGkgPj0gdGhpcy5wb3MgJiYgaSArIDEgKyBpbmRlbnQgPiBsYXN0Q2hhcilcbiAgICAgICAgICAgICAgICAgICAgbmwgPSBpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBTQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KG5sICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VQbGFpblNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGhpcy5idWZmZXJbKytpXSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXh0KSB8fCAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMobmV4dCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFbXB0eShjaCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICcjJyB8fCAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMobmV4dCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaSA9IE1hdGgubWF4KGksIGNzIC0gMik7IC8vIHRvIGFkdmFuY2UsIGJ1dCBzdGlsbCBhY2NvdW50IGZvciAnICMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluRmxvdyAmJiBmbG93SW5kaWNhdG9yQ2hhcnMuaGFzKGNoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgncGxhaW4tc2NhbGFyJyk7XG4gICAgICAgIHlpZWxkIFNDQUxBUjtcbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFRvSW5kZXgoZW5kICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpbkZsb3cgPyAnZmxvdycgOiAnZG9jJztcbiAgICB9XG4gICAgKnB1c2hDb3VudChuKSB7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IG47XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hUb0luZGV4KGksIGFsbG93RW1wdHkpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMucG9zLCBpKTtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHlpZWxkIHM7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd0VtcHR5KVxuICAgICAgICAgICAgeWllbGQgJyc7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaEluZGljYXRvcnMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hUYWcoKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcikpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgIGNhc2UgJy0nOiAvLyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICBjYXNlICc/JzogLy8gdGhpcyBpcyBhbiBlcnJvciBvdXRzaWRlIGZsb3cgY29sbGVjdGlvbnNcbiAgICAgICAgICAgIGNhc2UgJzonOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoMSA9IHRoaXMuY2hhckF0KDEpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGNoMSkgfHwgKGluRmxvdyAmJiBmbG93SW5kaWNhdG9yQ2hhcnMuaGFzKGNoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5GbG93KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gdGhpcy5pbmRlbnRWYWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZmxvd0tleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoQ291bnQoMSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hUYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXJBdCgxKSA9PT0gJzwnKSB7XG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMucG9zICsgMjtcbiAgICAgICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICAgICAgd2hpbGUgKCFpc0VtcHR5KGNoKSAmJiBjaCAhPT0gJz4nKVxuICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChjaCA9PT0gJz4nID8gaSArIDEgOiBpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ0NoYXJzLmhhcyhjaCkpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyUnICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5oYXModGhpcy5idWZmZXJbaSArIDFdKSAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaGFzKHRoaXMuYnVmZmVyW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsoaSArPSAzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoaSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpwdXNoTmV3bGluZSgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLmJ1ZmZlclt0aGlzLnBvc107XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xccicgJiYgdGhpcy5jaGFyQXQoMSkgPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoU3BhY2VzKGFsbG93VGFicykge1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIH0gd2hpbGUgKGNoID09PSAnICcgfHwgKGFsbG93VGFicyAmJiBjaCA9PT0gJ1xcdCcpKTtcbiAgICAgICAgY29uc3QgbiA9IGkgLSB0aGlzLnBvcztcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5wb3MsIG4pO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICAqcHVzaFVudGlsKHRlc3QpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgIHdoaWxlICghdGVzdChjaCkpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChpLCBmYWxzZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBMZXhlciB9O1xuIiwgIi8qKlxuICogVHJhY2tzIG5ld2xpbmVzIGR1cmluZyBwYXJzaW5nIGluIG9yZGVyIHRvIHByb3ZpZGUgYW4gZWZmaWNpZW50IEFQSSBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBvbmUtaW5kZXhlZCBgeyBsaW5lLCBjb2wgfWAgcG9zaXRpb24gZm9yIGFueSBvZmZzZXRcbiAqIHdpdGhpbiB0aGUgaW5wdXQuXG4gKi9cbmNsYXNzIExpbmVDb3VudGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saW5lU3RhcnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBjYWxsXG4gICAgICAgICAqIGBsaW5lQ291bnRlci5saW5lU3RhcnRzLnNvcnQoKWAgYmVmb3JlIGNhbGxpbmcgYGxpbmVQb3MoKWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZE5ld0xpbmUgPSAob2Zmc2V0KSA9PiB0aGlzLmxpbmVTdGFydHMucHVzaChvZmZzZXQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGFuZCByZXR1cm5zIHRoZSAxLWluZGV4ZWQgeyBsaW5lLCBjb2wgfVxuICAgICAgICAgKiBwb3NpdGlvbiBvZiBgb2Zmc2V0YC4gSWYgYGxpbmUgPT09IDBgLCBgYWRkTmV3TGluZWAgaGFzIG5ldmVyIGJlZW5cbiAgICAgICAgICogY2FsbGVkIG9yIGBvZmZzZXRgIGlzIGJlZm9yZSB0aGUgZmlyc3Qga25vd24gbmV3bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZVBvcyA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGxldCBsb3cgPSAwO1xuICAgICAgICAgICAgbGV0IGhpZ2ggPSB0aGlzLmxpbmVTdGFydHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTsgLy8gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTdGFydHNbbWlkXSA8IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU3RhcnRzW2xvd10gPT09IG9mZnNldClcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5lOiBsb3cgKyAxLCBjb2w6IDEgfTtcbiAgICAgICAgICAgIGlmIChsb3cgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogMCwgY29sOiBvZmZzZXQgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5saW5lU3RhcnRzW2xvdyAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbG93LCBjb2w6IG9mZnNldCAtIHN0YXJ0ICsgMSB9O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTGluZUNvdW50ZXIgfTtcbiIsICJpbXBvcnQgeyB0b2tlblR5cGUgfSBmcm9tICcuL2NzdC5qcyc7XG5pbXBvcnQgeyBMZXhlciB9IGZyb20gJy4vbGV4ZXIuanMnO1xuXG5mdW5jdGlvbiBpbmNsdWRlc1Rva2VuKGxpc3QsIHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChsaXN0W2ldLnR5cGUgPT09IHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmaW5kTm9uRW1wdHlJbmRleChsaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3aXRjaCAobGlzdFtpXS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBpc0Zsb3dUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4/LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFByZXZQcm9wcyhwYXJlbnQpIHtcbiAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuc3RhcnQ7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ID0gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiBpdC5zZXAgPz8gaXQuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaXRlbXNbcGFyZW50Lml0ZW1zLmxlbmd0aCAtIDFdLnN0YXJ0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbi8qKiBOb3RlOiBNYXkgbW9kaWZ5IGlucHV0IGFycmF5ICovXG5mdW5jdGlvbiBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldikge1xuICAgIGlmIChwcmV2Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBpID0gcHJldi5sZW5ndGg7XG4gICAgbG9vcDogd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgIHN3aXRjaCAocHJldltpXS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChwcmV2WysraV0/LnR5cGUgPT09ICdzcGFjZScpIHtcbiAgICAgICAgLyogbG9vcCAqL1xuICAgIH1cbiAgICByZXR1cm4gcHJldi5zcGxpY2UoaSwgcHJldi5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZml4Rmxvd1NlcUl0ZW1zKGZjKSB7XG4gICAgaWYgKGZjLnN0YXJ0LnR5cGUgPT09ICdmbG93LXNlcS1zdGFydCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdCBvZiBmYy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0LnNlcCAmJlxuICAgICAgICAgICAgICAgICFpdC52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpICYmXG4gICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbWFwLXZhbHVlLWluZCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0LmtleSlcbiAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0LmtleTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGbG93VG9rZW4oaXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZS5lbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpdC52YWx1ZS5lbmQsIGl0LnNlcCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlLmVuZCA9IGl0LnNlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpdC5zdGFydCwgaXQuc2VwKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXQuc2VwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIFlBTUwgY29uY3JldGUgc3ludGF4IHRyZWUgKENTVCkgcGFyc2VyXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBmb3IgKGNvbnN0IHRva2VuIG9mIG5ldyBQYXJzZXIoKS5wYXJzZShzcmMpKSB7XG4gKiAgIC8vIHRva2VuOiBUb2tlblxuICogfVxuICogYGBgXG4gKlxuICogVG8gdXNlIHRoZSBwYXJzZXIgd2l0aCBhIHVzZXItcHJvdmlkZWQgbGV4ZXI6XG4gKlxuICogYGBgdHNcbiAqIGZ1bmN0aW9uKiBwYXJzZShzb3VyY2U6IHN0cmluZywgbGV4ZXI6IExleGVyKSB7XG4gKiAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICogICBmb3IgKGNvbnN0IGxleGVtZSBvZiBsZXhlci5sZXgoc291cmNlKSlcbiAqICAgICB5aWVsZCogcGFyc2VyLm5leHQobGV4ZW1lKVxuICogICB5aWVsZCogcGFyc2VyLmVuZCgpXG4gKiB9XG4gKlxuICogY29uc3Qgc3JjOiBzdHJpbmcgPSAuLi5cbiAqIGNvbnN0IGxleGVyID0gbmV3IExleGVyKClcbiAqIGZvciAoY29uc3QgdG9rZW4gb2YgcGFyc2Uoc3JjLCBsZXhlcikpIHtcbiAqICAgLy8gdG9rZW46IFRva2VuXG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgUGFyc2VyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25OZXdMaW5lIC0gSWYgZGVmaW5lZCwgY2FsbGVkIHNlcGFyYXRlbHkgd2l0aCB0aGUgc3RhcnQgcG9zaXRpb24gb2ZcbiAgICAgKiAgIGVhY2ggbmV3IGxpbmUgKGluIGBwYXJzZSgpYCwgaW5jbHVkaW5nIHRoZSBzdGFydCBvZiBpbnB1dCkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob25OZXdMaW5lKSB7XG4gICAgICAgIC8qKiBJZiB0cnVlLCBzcGFjZSBhbmQgc2VxdWVuY2UgaW5kaWNhdG9ycyBjb3VudCBhcyBpbmRlbnRhdGlvbiAqL1xuICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgIC8qKiBJZiB0cnVlLCBuZXh0IHRva2VuIGlzIGEgc2NhbGFyIHZhbHVlICovXG4gICAgICAgIHRoaXMuYXRTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgLyoqIEN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgKi9cbiAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAvKiogQ3VycmVudCBvZmZzZXQgc2luY2UgdGhlIHN0YXJ0IG9mIHBhcnNpbmcgKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICAvKiogT24gdGhlIHNhbWUgbGluZSB3aXRoIGEgYmxvY2sgbWFwIGtleSAqL1xuICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAvKiogVG9wIGluZGljYXRlcyB0aGUgbm9kZSB0aGF0J3MgY3VycmVudGx5IGJlaW5nIGJ1aWx0ICovXG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgLyoqIFRoZSBzb3VyY2Ugb2YgdGhlIGN1cnJlbnQgdG9rZW4sIHNldCBpbiBwYXJzZSgpICovXG4gICAgICAgIHRoaXMuc291cmNlID0gJyc7XG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGUgY3VycmVudCB0b2tlbiwgc2V0IGluIHBhcnNlKCkgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJyc7XG4gICAgICAgIC8vIE11c3QgYmUgZGVmaW5lZCBhZnRlciBgbmV4dCgpYFxuICAgICAgICB0aGlzLmxleGVyID0gbmV3IExleGVyKCk7XG4gICAgICAgIHRoaXMub25OZXdMaW5lID0gb25OZXdMaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBgc291cmNlYCBhcyBhIFlBTUwgc3RyZWFtLlxuICAgICAqIElmIGBpbmNvbXBsZXRlYCwgYSBwYXJ0IG9mIHRoZSBsYXN0IGxpbmUgbWF5IGJlIGxlZnQgYXMgYSBidWZmZXIgZm9yIHRoZSBuZXh0IGNhbGwuXG4gICAgICpcbiAgICAgKiBFcnJvcnMgYXJlIG5vdCB0aHJvd24sIGJ1dCB5aWVsZGVkIGFzIGB7IHR5cGU6ICdlcnJvcicsIG1lc3NhZ2UgfWAgdG9rZW5zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBnZW5lcmF0b3Igb2YgdG9rZW5zIHJlcHJlc2VudGluZyBlYWNoIGRpcmVjdGl2ZSwgZG9jdW1lbnQsIGFuZCBvdGhlciBzdHJ1Y3R1cmUuXG4gICAgICovXG4gICAgKnBhcnNlKHNvdXJjZSwgaW5jb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSAmJiB0aGlzLm9mZnNldCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKDApO1xuICAgICAgICBmb3IgKGNvbnN0IGxleGVtZSBvZiB0aGlzLmxleGVyLmxleChzb3VyY2UsIGluY29tcGxldGUpKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMubmV4dChsZXhlbWUpO1xuICAgICAgICBpZiAoIWluY29tcGxldGUpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5lbmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2YW5jZSB0aGUgcGFyc2VyIGJ5IHRoZSBgc291cmNlYCBvZiBvbmUgbGV4aWNhbCB0b2tlbi5cbiAgICAgKi9cbiAgICAqbmV4dChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIGlmICh0aGlzLmF0U2NhbGFyKSB7XG4gICAgICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0b2tlblR5cGUoc291cmNlKTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYE5vdCBhIFlBTUwgdG9rZW46ICR7c291cmNlfWA7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoeyB0eXBlOiAnZXJyb3InLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBtZXNzYWdlLCBzb3VyY2UgfSk7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzY2FsYXInKSB7XG4gICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hdFNjYWxhciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSAnc2NhbGFyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgc291cmNlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXROZXdMaW5lICYmIHNvdXJjZVswXSA9PT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXROZXdMaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZG9jLW1vZGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctZXJyb3ItZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBDYWxsIGF0IGVuZCBvZiBpbnB1dCB0byBwdXNoIG91dCBhbnkgcmVtYWluaW5nIGNvbnN0cnVjdGlvbnMgKi9cbiAgICAqZW5kKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgfVxuICAgIGdldCBzb3VyY2VUb2tlbigpIHtcbiAgICAgICAgY29uc3Qgc3QgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0O1xuICAgIH1cbiAgICAqc3RlcCgpIHtcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZG9jLWVuZCcgJiYgdG9wPy50eXBlICE9PSAnZG9jLWVuZCcpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkb2MtZW5kJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9wKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnN0cmVhbSgpO1xuICAgICAgICBzd2l0Y2ggKHRvcC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmRvY3VtZW50KHRvcCk7XG4gICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5zY2FsYXIodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrU2NhbGFyKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja01hcCh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2VxJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tTZXF1ZW5jZSh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZmxvd0NvbGxlY3Rpb24odG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5kb2N1bWVudEVuZCh0b3ApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgIH1cbiAgICBwZWVrKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSBuXTtcbiAgICB9XG4gICAgKnBvcChlcnJvcikge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGVycm9yID8/IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ1RyaWVkIHRvIHBvcCBhbiBlbXB0eSBzdGFjayc7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6ICdlcnJvcicsIG9mZnNldDogdGhpcy5vZmZzZXQsIHNvdXJjZTogJycsIG1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgeWllbGQgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcicpIHtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayBzY2FsYXJzIHVzZSB0aGVpciBwYXJlbnQgcmF0aGVyIHRoYW4gaGVhZGVyIGluZGVudFxuICAgICAgICAgICAgICAgIHRva2VuLmluZGVudCA9ICdpbmRlbnQnIGluIHRvcCA/IHRvcC5pbmRlbnQgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicgJiYgdG9wLnR5cGUgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYWxsIGluZGVudCBmb3IgdG9wLWxldmVsIGZsb3cgY29sbGVjdGlvbnNcbiAgICAgICAgICAgICAgICB0b2tlbi5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nKVxuICAgICAgICAgICAgICAgIGZpeEZsb3dTZXFJdGVtcyh0b2tlbik7XG4gICAgICAgICAgICBzd2l0Y2ggKHRvcC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICB0b3AudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICAgICAgdG9wLnByb3BzLnB1c2godG9rZW4pOyAvLyBlcnJvclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gdG9wLml0ZW1zW3RvcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9ICFpdC5leHBsaWNpdEtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCB2YWx1ZTogdG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gdG9wLml0ZW1zW3RvcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodG9wLnR5cGUgPT09ICdkb2N1bWVudCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0b2tlbi5pdGVtc1t0b2tlbi5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgICAgICAhbGFzdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3QudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZpbmROb25FbXB0eUluZGV4KGxhc3Quc3RhcnQpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4uaW5kZW50ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0LnN0YXJ0LmV2ZXJ5KHN0ID0+IHN0LnR5cGUgIT09ICdjb21tZW50JyB8fCBzdC5pbmRlbnQgPCB0b2tlbi5pbmRlbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wLnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuZW5kID0gbGFzdC5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogbGFzdC5zdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaXRlbXMuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnN0cmVhbSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZS1saW5lJzpcbiAgICAgICAgICAgICAgICB5aWVsZCB7IHR5cGU6ICdkaXJlY3RpdmUnLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6IHRoaXMuc291cmNlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnYnl0ZS1vcmRlci1tYXJrJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zb3VyY2VUb2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdkb2MtbW9kZSc6XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZG9jdW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdkb2Mtc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZG9jKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBtZXNzYWdlOiBgVW5leHBlY3RlZCAke3RoaXMudHlwZX0gdG9rZW4gaW4gWUFNTCBzdHJlYW1gLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAqZG9jdW1lbnQoZG9jKSB7XG4gICAgICAgIGlmIChkb2MudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMubGluZUVuZChkb2MpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIGlmIChmaW5kTm9uRW1wdHlJbmRleChkb2Muc3RhcnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShkb2MpO1xuICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgZG9jdW1lbnRgLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHRoaXMucGVlaygyKSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgIGxldCBzZXA7XG4gICAgICAgICAgICBpZiAoc2NhbGFyLmVuZCkge1xuICAgICAgICAgICAgICAgIHNlcCA9IHNjYWxhci5lbmQ7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjYWxhci5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogc2NhbGFyLm9mZnNldCxcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IHNjYWxhci5pbmRlbnQsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IHNjYWxhciwgc2VwIH1dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoc2NhbGFyKTtcbiAgICB9XG4gICAgKmJsb2NrU2NhbGFyKHNjYWxhcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIucHJvcHMucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIHNjYWxhci5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAvLyBibG9jay1zY2FsYXIgc291cmNlIGluY2x1ZGVzIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicsIG5sKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmJsb2NrTWFwKG1hcCkge1xuICAgICAgICBjb25zdCBpdCA9IG1hcC5pdGVtc1ttYXAuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIGl0LnNlcCBpcyB0cnVlLWlzaCBpZiBwYWlyIGFscmVhZHkgaGFzIGtleSBvciA6IHNlcGFyYXRvclxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gaXQudmFsdWUgPyBpdC52YWx1ZS5lbmQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmRbZW5kLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdD8udHlwZSA9PT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kPy5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0SW5kZW50ZWRDb21tZW50KGl0LnN0YXJ0LCBtYXAuaW5kZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG1hcC5pdGVtc1ttYXAuaXRlbXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBwcmV2Py52YWx1ZT8uZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+PSBtYXAuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBhdE1hcEluZGVudCA9ICF0aGlzLm9uS2V5TGluZSAmJiB0aGlzLmluZGVudCA9PT0gbWFwLmluZGVudDtcbiAgICAgICAgICAgIGNvbnN0IGF0TmV4dEl0ZW0gPSBhdE1hcEluZGVudCAmJlxuICAgICAgICAgICAgICAgIChpdC5zZXAgfHwgaXQuZXhwbGljaXRLZXkpICYmXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlICE9PSAnc2VxLWl0ZW0taW5kJztcbiAgICAgICAgICAgIC8vIEZvciBlbXB0eSBub2RlcywgYXNzaWduIG5ld2xpbmUtc2VwYXJhdGVkIG5vdCBpbmRlbnRlZCBlbXB0eSB0b2tlbnMgdG8gZm9sbG93aW5nIG5vZGVcbiAgICAgICAgICAgIGxldCBzdGFydCA9IFtdO1xuICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gJiYgaXQuc2VwICYmICFpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5sID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdC5zZXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3QgPSBpdC5zZXBbaV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdC5pbmRlbnQgPiBtYXAuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBubC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBubC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChubC5sZW5ndGggPj0gMilcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpdC5zZXAuc3BsaWNlKG5sWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LnNlcCAmJiAhaXQuZXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5leHBsaWNpdEtleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQsIGV4cGxpY2l0S2V5OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0sIGV4cGxpY2l0S2V5OiB0cnVlIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LmV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnbmV3bGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbWFwLXZhbHVlLWluZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGbG93VG9rZW4oaXQua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ25ld2xpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdHlwZSBndWFyZCBpcyB3cm9uZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0LmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGUgZ3VhcmQgaXMgd3JvbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5LCBzZXAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWN0dWFsbHkgYXQgbmV4dCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwID0gaXQuc2VwLmNvbmNhdChzdGFydCwgdGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQudmFsdWUgfHwgYXROZXh0SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZzID0gdGhpcy5mbG93U2NhbGFyKHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdE5leHRJdGVtIHx8IGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0LCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShtYXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidi50eXBlID09PSAnYmxvY2stc2VxJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXQuZXhwbGljaXRLZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ25ld2xpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3Aoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVW5leHBlY3RlZCBibG9jay1zZXEtaW5kIG9uIHNhbWUgbGluZSB3aXRoIGtleScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXRNYXBJbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqYmxvY2tTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgY29uc3QgaXQgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9ICdlbmQnIGluIGl0LnZhbHVlID8gaXQudmFsdWUuZW5kIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kW2VuZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3Q/LnR5cGUgPT09ICdjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZD8ucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0SW5kZW50ZWRDb21tZW50KGl0LnN0YXJ0LCBzZXEuaW5kZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHNlcS5pdGVtc1tzZXEuaXRlbXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBwcmV2Py52YWx1ZT8uZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlIHx8IHRoaXMuaW5kZW50IDw9IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRlbnQgIT09IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnc2VxLWl0ZW0taW5kJykpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+IHNlcS5pbmRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoc2VxKTtcbiAgICAgICAgICAgIGlmIChidikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgfVxuICAgICpmbG93Q29sbGVjdGlvbihmYykge1xuICAgICAgICBjb25zdCBpdCA9IGZjLml0ZW1zW2ZjLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZmxvdy1lcnJvci1lbmQnKSB7XG4gICAgICAgICAgICBsZXQgdG9wO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRvcD8udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZjLmVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LW1hcC1lbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIGZjLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKGZjKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgJiZcbiAgICAgICAgICAgICAgICAoKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnICYmIHBhcmVudC5pbmRlbnQgPT09IGZjLmluZGVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zZXApKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnICYmXG4gICAgICAgICAgICAgICAgcGFyZW50LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIGZpeEZsb3dTZXFJdGVtcyhmYyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gZmMuZW5kLnNwbGljZSgxLCBmYy5lbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGZjLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiBmYy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBmYywgc2VwIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMubGluZUVuZChmYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmxvd1NjYWxhcih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0QmxvY2tWYWx1ZShwYXJlbnQpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNjYWxhcicsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBbdGhpcy5zb3VyY2VUb2tlbl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbG93LWNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zb3VyY2VUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNlcScsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGV4cGxpY2l0S2V5OiB0cnVlIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXRJbmRlbnRlZENvbW1lbnQoc3RhcnQsIGluZGVudCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnY29tbWVudCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA8PSBpbmRlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdGFydC5ldmVyeShzdCA9PiBzdC50eXBlID09PSAnbmV3bGluZScgfHwgc3QudHlwZSA9PT0gJ3NwYWNlJyk7XG4gICAgfVxuICAgICpkb2N1bWVudEVuZChkb2NFbmQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RvYy1tb2RlJykge1xuICAgICAgICAgICAgaWYgKGRvY0VuZC5lbmQpXG4gICAgICAgICAgICAgICAgZG9jRW5kLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvY0VuZC5lbmQgPSBbdGhpcy5zb3VyY2VUb2tlbl07XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmxpbmVFbmQodG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdmbG93LW1hcC1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gYWxsIG90aGVyIHZhbHVlcyBhcmUgZXJyb3JzXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5lbmQgPSBbdGhpcy5zb3VyY2VUb2tlbl07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgUGFyc2VyIH07XG4iLCAiaW1wb3J0IHsgQ29tcG9zZXIgfSBmcm9tICcuL2NvbXBvc2UvY29tcG9zZXIuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuL2RvYy9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBwcmV0dGlmeUVycm9yLCBZQU1MUGFyc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuL2xvZy5qcyc7XG5pbXBvcnQgeyBpc0RvY3VtZW50IH0gZnJvbSAnLi9ub2Rlcy9pZGVudGl0eS5qcyc7XG5pbXBvcnQgeyBMaW5lQ291bnRlciB9IGZyb20gJy4vcGFyc2UvbGluZS1jb3VudGVyLmpzJztcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gJy4vcGFyc2UvcGFyc2VyLmpzJztcblxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmV0dHlFcnJvcnMgPSBvcHRpb25zLnByZXR0eUVycm9ycyAhPT0gZmFsc2U7XG4gICAgY29uc3QgbGluZUNvdW50ZXIgPSBvcHRpb25zLmxpbmVDb3VudGVyIHx8IChwcmV0dHlFcnJvcnMgJiYgbmV3IExpbmVDb3VudGVyKCkpIHx8IG51bGw7XG4gICAgcmV0dXJuIHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9O1xufVxuLyoqXG4gKiBQYXJzZSB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2YgWUFNTCBkb2N1bWVudHMuXG4gKlxuICogRG9jdW1lbnRzIHNob3VsZCBiZSBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyIGJ5IGAuLi5gIG9yIGAtLS1gIG1hcmtlciBsaW5lcy5cbiAqXG4gKiBAcmV0dXJucyBJZiBhbiBlbXB0eSBgZG9jc2AgYXJyYXkgaXMgcmV0dXJuZWQsIGl0IHdpbGwgYmUgb2YgdHlwZVxuICogICBFbXB0eVN0cmVhbSBhbmQgY29udGFpbiBhZGRpdGlvbmFsIHN0cmVhbSBpbmZvcm1hdGlvbi4gSW5cbiAqICAgVHlwZVNjcmlwdCwgeW91IHNob3VsZCB1c2UgYCdlbXB0eScgaW4gZG9jc2AgYXMgYSB0eXBlIGd1YXJkIGZvciBpdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBbGxEb2N1bWVudHMoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxpbmVDb3VudGVyLCBwcmV0dHlFcnJvcnMgfSA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGxpbmVDb3VudGVyPy5hZGROZXdMaW5lKTtcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBDb21wb3NlcihvcHRpb25zKTtcbiAgICBjb25zdCBkb2NzID0gQXJyYXkuZnJvbShjb21wb3Nlci5jb21wb3NlKHBhcnNlci5wYXJzZShzb3VyY2UpKSk7XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcilcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgICAgICAgZG9jLmVycm9ycy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgICAgICAgICAgZG9jLndhcm5pbmdzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgIH1cbiAgICBpZiAoZG9jcy5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gZG9jcztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgeyBlbXB0eTogdHJ1ZSB9LCBjb21wb3Nlci5zdHJlYW1JbmZvKCkpO1xufVxuLyoqIFBhcnNlIGFuIGlucHV0IHN0cmluZyBpbnRvIGEgc2luZ2xlIFlBTUwuRG9jdW1lbnQgKi9cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxpbmVDb3VudGVyLCBwcmV0dHlFcnJvcnMgfSA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGxpbmVDb3VudGVyPy5hZGROZXdMaW5lKTtcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBDb21wb3NlcihvcHRpb25zKTtcbiAgICAvLyBgZG9jYCBpcyBhbHdheXMgc2V0IGJ5IGNvbXBvc2UuZW5kKHRydWUpIGF0IHRoZSB2ZXJ5IGxhdGVzdFxuICAgIGxldCBkb2MgPSBudWxsO1xuICAgIGZvciAoY29uc3QgX2RvYyBvZiBjb21wb3Nlci5jb21wb3NlKHBhcnNlci5wYXJzZShzb3VyY2UpLCB0cnVlLCBzb3VyY2UubGVuZ3RoKSkge1xuICAgICAgICBpZiAoIWRvYylcbiAgICAgICAgICAgIGRvYyA9IF9kb2M7XG4gICAgICAgIGVsc2UgaWYgKGRvYy5vcHRpb25zLmxvZ0xldmVsICE9PSAnc2lsZW50Jykge1xuICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MUGFyc2VFcnJvcihfZG9jLnJhbmdlLnNsaWNlKDAsIDIpLCAnTVVMVElQTEVfRE9DUycsICdTb3VyY2UgY29udGFpbnMgbXVsdGlwbGUgZG9jdW1lbnRzOyBwbGVhc2UgdXNlIFlBTUwucGFyc2VBbGxEb2N1bWVudHMoKScpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV0dHlFcnJvcnMgJiYgbGluZUNvdW50ZXIpIHtcbiAgICAgICAgZG9jLmVycm9ycy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYztcbn1cbmZ1bmN0aW9uIHBhcnNlKHNyYywgcmV2aXZlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmV2aXZlciA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgX3Jldml2ZXIgPSByZXZpdmVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmV2aXZlciAmJiB0eXBlb2YgcmV2aXZlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJldml2ZXI7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IHBhcnNlRG9jdW1lbnQoc3JjLCBvcHRpb25zKTtcbiAgICBpZiAoIWRvYylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgZG9jLndhcm5pbmdzLmZvckVhY2god2FybmluZyA9PiB3YXJuKGRvYy5vcHRpb25zLmxvZ0xldmVsLCB3YXJuaW5nKSk7XG4gICAgaWYgKGRvYy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZG9jLm9wdGlvbnMubG9nTGV2ZWwgIT09ICdzaWxlbnQnKVxuICAgICAgICAgICAgdGhyb3cgZG9jLmVycm9yc1swXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9jLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gZG9jLnRvSlMoT2JqZWN0LmFzc2lnbih7IHJldml2ZXI6IF9yZXZpdmVyIH0sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgX3JlcGxhY2VyID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBpbmRlbnQgPSBNYXRoLnJvdW5kKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gaW5kZW50IDwgMSA/IHVuZGVmaW5lZCA6IGluZGVudCA+IDggPyB7IGluZGVudDogOCB9IDogeyBpbmRlbnQgfTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBrZWVwVW5kZWZpbmVkIH0gPSBvcHRpb25zID8/IHJlcGxhY2VyID8/IHt9O1xuICAgICAgICBpZiAoIWtlZXBVbmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNEb2N1bWVudCh2YWx1ZSkgJiYgIV9yZXBsYWNlcilcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucykudG9TdHJpbmcob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IHBhcnNlLCBwYXJzZUFsbERvY3VtZW50cywgcGFyc2VEb2N1bWVudCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgQmFzZVdpemFyZFN0ZXAgfSBmcm9tICcuL0Jhc2VXaXphcmRTdGVwJztcclxuXHJcbmV4cG9ydCBjbGFzcyBXWVNJV1lHUHJlZmVyZW5jZVN0ZXAgZXh0ZW5kcyBCYXNlV2l6YXJkU3RlcCB7XHJcblx0ZGlzcGxheSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XHJcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xyXG5cclxuXHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIldZU0lXWUdcIiBpcyBhbiBhY3JvbnltIGFuZCBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2VcclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1dZU0lXWUcgZWRpdGluZyB0b29sYmFyJyB9KTtcclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiV1lTSVdZR1wiIGlzIGFuIGFjcm9ueW0gYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRcdHRleHQ6ICdEbyB5b3Ugd2FudCB0byB1c2UgdGhlIFdZU0lXWUcgZWRpdGluZyB0b29sYmFyPycgXHJcblx0XHR9KTtcclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0dGV4dDogJ1RoaXMgZW5hYmxlcyBhIHZpc3VhbCBlZGl0aW5nIHRvb2xiYXIgZm9yIGZvcm1hdHRpbmcgdGV4dC4gVGhlIHRvb2xiYXIgY2FuIGJlIHRvZ2dsZWQgb24vb2ZmIHZpYSBjb21tYW5kLicgXHJcblx0XHR9KTtcclxuXHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiV1lTSVdZR1wiIGlzIGFuIGFjcm9ueW0gYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRcdC5zZXROYW1lKCdFbmFibGUgV1lTSVdZRyB0b29sYmFyJylcclxuXHRcdFx0LnNldERlc2MoJ1Nob3cgdGhlIGVkaXRpbmcgdG9vbGJhciBjb21tYW5kIGluIHRoZSBwYWdlIGhlYWRlcicpXHJcblx0XHRcdC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxyXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnN0YXRlLmVuYWJsZVdZU0lXWUcpXHJcblx0XHRcdFx0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlV1lTSVdZRyA9IHZhbHVlO1xyXG5cdFx0XHRcdH0pKTtcclxuXHR9XHJcblxyXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdXWVNJV1lHIHByZWZlcmVuY2UnO1xyXG5cdH1cclxuXHJcblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiAnQ29uZmlndXJlIGVkaXRpbmcgdG9vbGJhciBwcmVmZXJlbmNlJztcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2VzQ01TQ29uZmlnU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcclxuXHRkaXNwbGF5KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG5cdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiQmFzZXMgQ01TXCIgaXMgYSBwcm9wZXIgbm91biAocHJvZHVjdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdCYXNlcyBDTVMgY29uZmlndXJhdGlvbicgfSk7XHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIkJhc2VzIENNU1wiIGlzIGEgcHJvcGVyIG5vdW4gKHByb2R1Y3QgbmFtZSkgYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRcdHRleHQ6ICdCYXNlcyBDTVMgdmlld3Mgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgZm9yIGVhY2ggZW5hYmxlZCBjb250ZW50IHR5cGUgdXNpbmcgeW91ciBtYXBwZWQgZnJvbnRtYXR0ZXIgcHJvcGVydGllcy4nIFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgZW5hYmxlZFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xyXG5cdFx0XHJcblx0XHRpZiAoZW5hYmxlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdFx0dGV4dDogJ05vIGNvbnRlbnQgdHlwZXMgZW5hYmxlZC4gUGxlYXNlIGdvIGJhY2sgYW5kIGVuYWJsZSBhdCBsZWFzdCBvbmUgY29udGVudCB0eXBlLicgXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnVmlld3MgdG8gYmUgY3JlYXRlZDonIH0pO1xyXG5cdFx0Y29uc3QgbGlzdCA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCd1bCcpO1xyXG5cdFx0XHJcblx0XHRmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIGVuYWJsZWRUeXBlcykge1xyXG5cdFx0XHRjb25zdCBwcm9wcyA9IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXTtcclxuXHRcdFx0aWYgKHByb3BzKSB7XHJcblx0XHRcdFx0Y29uc3QgcHJvcGVydGllczogc3RyaW5nW10gPSBbXTtcclxuXHRcdFx0XHRpZiAocHJvcHMudGl0bGVQcm9wZXJ0eSkgcHJvcGVydGllcy5wdXNoKGB0aXRsZTogJHtwcm9wcy50aXRsZVByb3BlcnR5fWApO1xyXG5cdFx0XHRcdGlmIChwcm9wcy5kYXRlUHJvcGVydHkpIHByb3BlcnRpZXMucHVzaChgZGF0ZTogJHtwcm9wcy5kYXRlUHJvcGVydHl9YCk7XHJcblx0XHRcdFx0aWYgKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpIHByb3BlcnRpZXMucHVzaChgZGVzY3JpcHRpb246ICR7cHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eX1gKTtcclxuXHRcdFx0XHRpZiAocHJvcHMudGFnc1Byb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2goYHRhZ3M6ICR7cHJvcHMudGFnc1Byb3BlcnR5fWApO1xyXG5cdFx0XHRcdGlmIChwcm9wcy5pbWFnZVByb3BlcnR5KSBwcm9wZXJ0aWVzLnB1c2goYGltYWdlOiAke3Byb3BzLmltYWdlUHJvcGVydHl9YCk7XHJcblx0XHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHByb3BlcnRpZXMucHVzaChgZHJhZnQ6ICR7cHJvcHMuZHJhZnRQcm9wZXJ0eX1gKTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHRjb25zdCBwcm9wZXJ0aWVzVGV4dCA9IHByb3BlcnRpZXMubGVuZ3RoID4gMCA/IHByb3BlcnRpZXMuam9pbignLCAnKSA6ICdkZWZhdWx0IHByb3BlcnRpZXMnO1xyXG5cdFx0XHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyBcclxuXHRcdFx0XHRcdHRleHQ6IGAke2NvbnRlbnRUeXBlLm5hbWV9OiAke3Byb3BlcnRpZXNUZXh0fWAgXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIkJhc2VzIENNU1wiIGlzIGEgcHJvcGVyIG5vdW4gKHByb2R1Y3QgbmFtZSkgYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRcdHRleHQ6ICdZb3UgY2FuIGN1c3RvbWl6ZSB0aGVzZSB2aWV3cyBsYXRlciBpbiB0aGUgQmFzZXMgQ01TIHNldHRpbmdzLicgXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhdGUuY29udGVudFR5cGVzLnNvbWUoY3QgPT4gY3QuZW5hYmxlZCk7XHJcblx0fVxyXG5cclxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdCYXNlcyBDTVMgY29uZmlndXJhdGlvbic7XHJcblx0fVxyXG5cclxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdDb25maWd1cmUgQmFzZXMgQ01TIHZpZXdzJztcclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBCYXNlV2l6YXJkU3RlcCB9IGZyb20gJy4vQmFzZVdpemFyZFN0ZXAnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFzdHJvQ29tcG9zZXJTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xyXG5cdGRpc3BsYXkoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xyXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcclxuXHJcblx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJBc3RybyBDb21wb3NlclwiIGlzIGEgcHJvcGVyIG5vdW4gKHByb2R1Y3QgbmFtZSkgYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxyXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnQXN0cm8gQ29tcG9zZXIgY29uZmlndXJhdGlvbicgfSk7XHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIkFzdHJvIENvbXBvc2VyXCIgaXMgYSBwcm9wZXIgbm91biAocHJvZHVjdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2VcclxuXHRcdFx0dGV4dDogJ0FzdHJvIENvbXBvc2VyIHdpbGwgYmUgY29uZmlndXJlZCB3aXRoIHlvdXIgY29udGVudCB0eXBlcyBhbmQgZnJvbnRtYXR0ZXIgcHJvcGVydGllcy4nIFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgZW5hYmxlZFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xyXG5cdFx0XHJcblx0XHRpZiAoZW5hYmxlZFR5cGVzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXHJcblx0XHRcdFx0dGV4dDogJ05vIGNvbnRlbnQgdHlwZXMgZW5hYmxlZC4nIFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogJ0NvbnRlbnQgdHlwZXMgdG8gY29uZmlndXJlOicgfSk7XHJcblx0XHRjb25zdCBsaXN0ID0gY29udGFpbmVyRWwuY3JlYXRlRWwoJ3VsJyk7XHJcblx0XHRcclxuXHRcdGZvciAoY29uc3QgY29udGVudFR5cGUgb2YgZW5hYmxlZFR5cGVzKSB7XHJcblx0XHRcdGNvbnN0IHByb3BzID0gdGhpcy5zdGF0ZS5mcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdO1xyXG5cdFx0XHRpZiAocHJvcHMpIHtcclxuXHRcdFx0XHRjb25zdCBtb2RlTGFiZWwgPSBjb250ZW50VHlwZS5maWxlT3JnYW5pemF0aW9uID09PSAnZm9sZGVyJyA/ICdmb2xkZXItYmFzZWQnIDogJ2ZpbGUtYmFzZWQnO1xyXG5cdFx0XHRcdGxpc3QuY3JlYXRlRWwoJ2xpJywgeyBcclxuXHRcdFx0XHRcdHRleHQ6IGAke2NvbnRlbnRUeXBlLm5hbWV9ICgke2NvbnRlbnRUeXBlLmZvbGRlcn0pOiAke21vZGVMYWJlbH1gIFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbikge1xyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLnByb2plY3RSb290KSB7XHJcblx0XHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxyXG5cdFx0XHRcdFx0dGV4dDogYFByb2plY3Qgcm9vdDogJHt0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3R9YCBcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoKSB7XHJcblx0XHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxyXG5cdFx0XHRcdFx0dGV4dDogYENvbmZpZyBmaWxlOiAke3RoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aH1gIFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHJcblx0Z2V0VGl0bGUoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiAnQXN0cm8gQ29tcG9zZXIgY29uZmlndXJhdGlvbic7XHJcblx0fVxyXG5cclxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdDb25maWd1cmUgQXN0cm8gQ29tcG9zZXInO1xyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzIChtYXkgbm90IGJlIGluIHR5cGVzIHlldClcclxuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XHJcblx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XHJcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XHJcblx0fVxyXG59XHJcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XHJcbmltcG9ydCB7IFBhdGhSZXNvbHZlciB9IGZyb20gJy4uLy4uL3V0aWxzL1BhdGhSZXNvbHZlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgU0VPQ29uZmlnU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcclxuXHRkaXNwbGF5KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcclxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XHJcblxyXG5cdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiU0VPXCIgaXMgYW4gYWNyb255bSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdTRU8gcGx1Z2luIGNvbmZpZ3VyYXRpb24nIH0pO1xyXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxyXG5cdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJTRU9cIiBpcyBhbiBhY3JvbnltIGFuZCBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxyXG5cdFx0XHR0ZXh0OiAnU0VPIHBsdWdpbiB3aWxsIGJlIGNvbmZpZ3VyZWQgdXNpbmcgeW91ciBtYXBwZWQgZnJvbnRtYXR0ZXIgcHJvcGVydGllcy4nIFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgZW5hYmxlZFR5cGVzID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xyXG5cdFx0Y29uc3QgZmlyc3RUeXBlID0gZW5hYmxlZFR5cGVzWzBdO1xyXG5cdFx0Y29uc3QgZmlyc3RQcm9wcyA9IGZpcnN0VHlwZSA/IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2ZpcnN0VHlwZS5pZF0gOiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgZGlmZmVyZW50IGNvbnRlbnQgdHlwZXMgdXNlIGRpZmZlcmVudCBwcm9wZXJ0aWVzXHJcblx0XHRjb25zdCB0aXRsZVByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuXHRcdGNvbnN0IGRlc2NyaXB0aW9uUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG5cdFx0XHJcblx0XHRmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIGVuYWJsZWRUeXBlcykge1xyXG5cdFx0XHRjb25zdCBwcm9wcyA9IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXTtcclxuXHRcdFx0aWYgKHByb3BzKSB7XHJcblx0XHRcdFx0aWYgKHByb3BzLnRpdGxlUHJvcGVydHkpIHtcclxuXHRcdFx0XHRcdHRpdGxlUHJvcGVydGllcy5hZGQocHJvcHMudGl0bGVQcm9wZXJ0eSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChwcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XHJcblx0XHRcdFx0XHRkZXNjcmlwdGlvblByb3BlcnRpZXMuYWRkKHByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNob3cgd2FybmluZyBpZiBwcm9wZXJ0aWVzIGRpZmZlciBhY3Jvc3MgY29udGVudCB0eXBlc1xyXG5cdFx0aWYgKHRpdGxlUHJvcGVydGllcy5zaXplID4gMSB8fCBkZXNjcmlwdGlvblByb3BlcnRpZXMuc2l6ZSA+IDEpIHtcclxuXHRcdFx0Y29uc3Qgd2FybmluZ0RpdiA9IGNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy13YXJuaW5nJyB9KTtcclxuXHRcdFx0c2V0Q3NzUHJvcHMod2FybmluZ0Rpdiwge1xyXG5cdFx0XHRcdHBhZGRpbmc6ICcxMHB4JyxcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICd2YXIoLS1iYWNrZ3JvdW5kLW1vZGlmaWVyLWJvcmRlciknLFxyXG5cdFx0XHRcdGJvcmRlckxlZnQ6ICczcHggc29saWQgdmFyKC0tdGV4dC13YXJuaW5nKScsXHJcblx0XHRcdFx0bWFyZ2luQm90dG9tOiAnMTVweCdcclxuXHRcdFx0fSk7XHJcblx0XHRcdFxyXG5cdFx0XHR3YXJuaW5nRGl2LmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXHJcblx0XHRcdFx0dGV4dDogJ1x1MjZBMFx1RkUwRiBXYXJuaW5nOiBEaWZmZXJlbnQgY29udGVudCB0eXBlcyB1c2UgZGlmZmVyZW50IHByb3BlcnRpZXMgZm9yIHRpdGxlIG9yIGRlc2NyaXB0aW9uLicsXHJcblx0XHRcdFx0YXR0cjogeyBzdHlsZTogJ21hcmdpbjogMCAwIDVweCAwOyBmb250LXdlaWdodDogYm9sZDsnIH1cclxuXHRcdFx0fSk7XHJcblx0XHRcdHdhcm5pbmdEaXYuY3JlYXRlRWwoJ3AnLCB7IFxyXG5cdFx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIlNFT1wiIGlzIGFuIGFjcm9ueW0gYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxyXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2VcclxuXHRcdFx0XHR0ZXh0OiAnVGhlIFNFTyBwbHVnaW4gd2lsbCB1c2UgdGhlIGZpcnN0IGNvbnRlbnQgdHlwZVxcJ3MgcHJvcGVydGllcy4gWW91IG1heSBuZWVkIHRvIG1hbnVhbGx5IGNvbmZpZ3VyZSBTRU8gc2V0dGluZ3MgZm9yIG90aGVyIGNvbnRlbnQgdHlwZXMuJyxcclxuXHRcdFx0XHRhdHRyOiB7IHN0eWxlOiAnbWFyZ2luOiAwOycgfVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZmlyc3RQcm9wcykge1xyXG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDMnLCB7IHRleHQ6ICdDb25maWd1cmF0aW9uOicgfSk7XHJcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0XHR0ZXh0OiBgVGl0bGUgcHJvcGVydHk6ICR7Zmlyc3RQcm9wcy50aXRsZVByb3BlcnR5IHx8ICcodXNpbmcgZmlsZW5hbWUpJ31gIFxyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKGZpcnN0UHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSkge1xyXG5cdFx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0XHRcdHRleHQ6IGBEZXNjcmlwdGlvbiBwcm9wZXJ0eTogJHtmaXJzdFByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9YCBcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3Qgc2NhbkRpcnMgPSBlbmFibGVkVHlwZXNcclxuXHRcdFx0XHQubWFwKGN0ID0+IGN0LmZvbGRlcilcclxuXHRcdFx0XHQuam9pbignLCAnKTtcclxuXHJcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcclxuXHRcdFx0XHR0ZXh0OiBgU2NhbiBkaXJlY3RvcmllczogJHtzY2FuRGlyc31gIFxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2Ugc2F2ZWQgc2NhbkRpcmVjdG9yaWVzIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gZW5hYmxlZCBjb250ZW50IHR5cGUgZm9sZGVyc1xyXG5cdFx0Ly8gVXNlIFBhdGhSZXNvbHZlciB0byBnZXQgdGhlIGNvcnJlY3QgZm9sZGVyIHBhdGhzIChlLmcuLCBcImNvbnRlbnQvZG9jc1wiIGluc3RlYWQgb2YgXCJkb2NzXCIpXHJcblx0XHRjb25zdCBwYXRoUmVzb2x2ZXIgPSBuZXcgUGF0aFJlc29sdmVyKHRoaXMuYXBwKTtcclxuXHRcdGNvbnN0IGRlZmF1bHRTY2FuRGlycyA9IHRoaXMuc3RhdGUuY29udGVudFR5cGVzXHJcblx0XHRcdC5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZClcclxuXHRcdFx0Lm1hcChjdCA9PiBwYXRoUmVzb2x2ZXIuZ2V0Rm9sZGVyUGF0aEZyb21WYXVsdFJvb3QoY3QuZm9sZGVyLCB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pKVxyXG5cdFx0XHQuam9pbignLCcpO1xyXG5cdFx0Y29uc3Qgc2F2ZWRTY2FuRGlycyA9IHRoaXMuc3RhdGUuc2VvQ29uZmlnPy5zY2FuRGlyZWN0b3JpZXM7XHJcblx0XHRjb25zdCBpbml0aWFsU2NhbkRpcnMgPSBzYXZlZFNjYW5EaXJzICYmIHNhdmVkU2NhbkRpcnMudHJpbSgpID8gc2F2ZWRTY2FuRGlycyA6IGRlZmF1bHRTY2FuRGlycztcclxuXHRcdFxyXG5cdFx0Ly8gSW5pdGlhbGl6ZSBzY2FuRGlyZWN0b3JpZXMgaWYgbm90IHNldFxyXG5cdFx0aWYgKCF0aGlzLnN0YXRlLnNlb0NvbmZpZy5zY2FuRGlyZWN0b3JpZXMgfHwgIXRoaXMuc3RhdGUuc2VvQ29uZmlnLnNjYW5EaXJlY3Rvcmllcy50cmltKCkpIHtcclxuXHRcdFx0dGhpcy5zdGF0ZS5zZW9Db25maWcuc2NhbkRpcmVjdG9yaWVzID0gaW5pdGlhbFNjYW5EaXJzO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcclxuXHRcdFx0LnNldE5hbWUoJ1NjYW4gZGlyZWN0b3JpZXMnKVxyXG5cdFx0XHQuc2V0RGVzYygnQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0b3JpZXMgdG8gc2NhbiAoeW91IGNhbiBjdXN0b21pemUgdGhpcyknKVxyXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcclxuXHRcdFx0XHQuc2V0VmFsdWUoaW5pdGlhbFNjYW5EaXJzKVxyXG5cdFx0XHRcdC5vbkNoYW5nZSh2YWx1ZSA9PiB7XHJcblx0XHRcdFx0XHQvLyBTdG9yZSBjdXN0b20gc2NhbiBkaXJlY3RvcmllcyBpZiB1c2VyIGNoYW5nZXMgdGhlbVxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3RhdGUuc2VvQ29uZmlnKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuc2VvQ29uZmlnLnNjYW5EaXJlY3RvcmllcyA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pKTtcclxuXHR9XHJcblxyXG5cdHZhbGlkYXRlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdTRU8gY29uZmlndXJhdGlvbic7XHJcblx0fVxyXG5cclxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuICdDb25maWd1cmUgU0VPIHBsdWdpbic7XHJcblx0fVxyXG59XHJcblxyXG4iLCAiaW1wb3J0IHsgQXBwLCBTZXR0aW5nLCBzZXRJY29uIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzIChtYXkgbm90IGJlIGluIHR5cGVzIHlldClcbmZ1bmN0aW9uIHNldENzc1Byb3BzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwcm9wczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQge1xuXHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wcykpIHtcblx0XHRlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG5cdH1cbn1cbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9QbHVnaW5NYW5hZ2VyJztcblxuaW50ZXJmYWNlIFBsdWdpbkluZm8ge1xuXHRpZDogc3RyaW5nO1xuXHRuYW1lOiBzdHJpbmc7XG5cdGNhdGVnb3J5OiAnZXNzZW50aWFsJyB8ICduaWNlLXRvLWhhdmUnO1xufVxuXG5leHBvcnQgY2xhc3MgT3B0aW9uYWxQbHVnaW5zU3RlcCBleHRlbmRzIEJhc2VXaXphcmRTdGVwIHtcblx0cHJpdmF0ZSBwbHVnaW5NYW5hZ2VyOiBQbHVnaW5NYW5hZ2VyO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjb250YWluZXJFbDogSFRNTEVsZW1lbnQsIHN0YXRlOiBXaXphcmRTdGF0ZSwgb25OZXh0OiAoKSA9PiB2b2lkLCBvbkJhY2s6ICgpID0+IHZvaWQsIG9uQ2FuY2VsOiAoKSA9PiB2b2lkKSB7XG5cdFx0c3VwZXIoYXBwLCBjb250YWluZXJFbCwgc3RhdGUsIG9uTmV4dCwgb25CYWNrLCBvbkNhbmNlbCk7XG5cdFx0dGhpcy5wbHVnaW5NYW5hZ2VyID0gbmV3IFBsdWdpbk1hbmFnZXIoYXBwKTtcblx0fVxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3QgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywgeyB0ZXh0OiAnUGx1Z2luIGNvbmZpZ3VyYXRpb24nIH0pO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdC8vIEZhbHNlIHBvc2l0aXZlOiBcIlZhdWx0IENNU1wiIGlzIGEgcHJvcGVyIG5vdW4gKHByb2R1Y3QgbmFtZSkgYW5kIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxuXHRcdFx0dGV4dDogJ1JldmlldyBhbmQgY29uZmlndXJlIHlvdXIgaW5zdGFsbGVkIHBsdWdpbnMuIEVzc2VudGlhbCBwbHVnaW5zIGFyZSByZWNvbW1lbmRlZCBmb3IgdGhlIGNvcmUgVmF1bHQgQ01TIGV4cGVyaWVuY2UuJyBcblx0XHR9KTtcblxuXHRcdC8vIERlZmluZSBhbGwgcGx1Z2lucyB3aXRoIHRoZWlyIGNhdGVnb3JpZXNcblx0XHRjb25zdCBhbGxQbHVnaW5zOiBQbHVnaW5JbmZvW10gPSBbXG5cdFx0XHQvLyBFc3NlbnRpYWwgcGx1Z2lucyAoYWxwaGFiZXRpY2FsbHkgb3JkZXJlZClcblx0XHRcdHsgaWQ6ICdhc3Ryby1jb21wb3NlcicsIG5hbWU6ICdBc3RybyBDb21wb3NlcicsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ2Jhc2VzLWNtcycsIG5hbWU6ICdCYXNlcyBDTVMnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdjbWRyJywgbmFtZTogJ0NvbW1hbmRlcicsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ25ldy10YWItZGVmYXVsdC1wYWdlJywgbmFtZTogJ0RlZmF1bHQgTmV3IFRhYiBQYWdlJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnZWRpdGluZy10b29sYmFyJywgbmFtZTogJ0VkaXRpbmcgVG9vbGJhcicsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ2hvbWUtYmFzZScsIG5hbWU6ICdIb21lIEJhc2UnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdob21lcGFnZScsIG5hbWU6ICdIb21lcGFnZScsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ2ltYWdlLW1hbmFnZXInLCBuYW1lOiAnSW1hZ2UgTWFuYWdlcicsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ29ic2lkaWFuLXBhc3RlLWltYWdlLXJlbmFtZScsIG5hbWU6ICdQYXN0ZSBJbWFnZSBSZW5hbWUnLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdwcm9wZXJ0eS1vdmVyLWZpbGUtbmFtZScsIG5hbWU6ICdQcm9wZXJ0eSBPdmVyIEZpbGUgTmFtZScsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0eyBpZDogJ3NlbycsIG5hbWU6ICdTRU8nLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICd1aS10d2Vha2VyJywgbmFtZTogJ1VJIFR3ZWFrZXInLCBjYXRlZ29yeTogJ2Vzc2VudGlhbCcgfSxcblx0XHRcdHsgaWQ6ICdzaW1wbGUtZm9jdXMnLCBuYW1lOiAnU2ltcGxlIEZvY3VzJywgY2F0ZWdvcnk6ICdlc3NlbnRpYWwnIH0sXG5cdFx0XHR7IGlkOiAnc3RhdHVzYmFyLW9yZ2FuaXplcicsIG5hbWU6ICdTdGF0dXMgQmFyIE9yZ2FuaXplcicsIGNhdGVnb3J5OiAnZXNzZW50aWFsJyB9LFxuXHRcdFx0Ly8gTmljZSB0byBoYXZlIHBsdWdpbnMgKGFscGhhYmV0aWNhbGx5IG9yZGVyZWQpXG5cdFx0XHR7IGlkOiAnYWxpYXMtZmlsZS1uYW1lLWhpc3RvcnknLCBuYW1lOiAnQWxpYXMgRmlsZSBOYW1lIEhpc3RvcnknLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICdpY29uaWMnLCBuYW1lOiAnSWNvbmljJywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAnaW5zZXJ0LXVuc3BsYXNoLWltYWdlJywgbmFtZTogJ0ltYWdlIEluc2VydGVyJywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAncGFzdGUtaW1hZ2UtaW50by1wcm9wZXJ0eScsIG5hbWU6ICdQYXN0ZSBJbWFnZSBJbnRvIFByb3BlcnR5JywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAnc2V0dGluZ3Mtc2VhcmNoJywgbmFtZTogJ1NldHRpbmdzIFNlYXJjaCcsIGNhdGVnb3J5OiAnbmljZS10by1oYXZlJyB9LFxuXHRcdFx0eyBpZDogJ3NpbXBsZS1iYW5uZXInLCBuYW1lOiAnU2ltcGxlIEJhbm5lcicsIGNhdGVnb3J5OiAnbmljZS10by1oYXZlJyB9LFxuXHRcdFx0eyBpZDogJ3RhZy13cmFuZ2xlcicsIG5hbWU6ICdUYWcgV3JhbmdsZXInLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfSxcblx0XHRcdHsgaWQ6ICd6ZW5tb2RlJywgbmFtZTogJ1plbiBNb2RlJywgY2F0ZWdvcnk6ICduaWNlLXRvLWhhdmUnIH0sXG5cdFx0XHR7IGlkOiAnZXhwbG9yZXItZm9jdXMnLCBuYW1lOiAnRXhwbG9yZXIgRm9jdXMnLCBjYXRlZ29yeTogJ25pY2UtdG8taGF2ZScgfVxuXHRcdF07XG5cblx0XHQvLyBHZXQgaW5zdGFsbGVkIHBsdWdpbnNcblx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+OyBlbmFibGVkUGx1Z2lucz86IFNldDxzdHJpbmc+IH0gfSkucGx1Z2lucztcblx0XHRjb25zdCBpbnN0YWxsZWRQbHVnaW5JZHMgPSBwbHVnaW5zPy5wbHVnaW5zID8gT2JqZWN0LmtleXMocGx1Z2lucy5wbHVnaW5zKSA6IFtdO1xuXG5cdFx0Ly8gRmlsdGVyIHRvIG9ubHkgc2hvdyBpbnN0YWxsZWQgcGx1Z2lucyAoZXhjbHVkaW5nIGlnbm9yZWQgb25lcylcblx0XHRjb25zdCBpZ25vcmVkUGx1Z2lucyA9IFtcblx0XHRcdCdvYnNpZGlhbjQyLWJyYXQnLFxuXHRcdFx0J2FzdHJvLW1vZHVsYXItc2V0dGluZ3MnLFxuXHRcdFx0J2ZvbGRlci1ub3RlcycsXG5cdFx0XHQnZGlzYWJsZS10YWJzJyxcblx0XHRcdCd2YXVsdC1jbXMnIC8vIERvbid0IHNob3cgVmF1bHQgQ01TIHBsdWdpbiBpdHNlbGZcblx0XHRdO1xuXG5cdFx0Y29uc3QgZXNzZW50aWFsUGx1Z2lucyA9IGFsbFBsdWdpbnMuZmlsdGVyKHAgPT4gXG5cdFx0XHRwLmNhdGVnb3J5ID09PSAnZXNzZW50aWFsJyAmJiBcblx0XHRcdGluc3RhbGxlZFBsdWdpbklkcy5pbmNsdWRlcyhwLmlkKSAmJiBcblx0XHRcdCFpZ25vcmVkUGx1Z2lucy5pbmNsdWRlcyhwLmlkKVxuXHRcdCk7XG5cdFx0Ly8gRmlsdGVyIG5pY2UtdG8taGF2ZSBwbHVnaW5zIGFuZCBzb3J0IGFscGhhYmV0aWNhbGx5IGJ5IG5hbWVcblx0XHRjb25zdCBuaWNlVG9IYXZlUGx1Z2lucyA9IGFsbFBsdWdpbnNcblx0XHRcdC5maWx0ZXIocCA9PiBcblx0XHRcdFx0cC5jYXRlZ29yeSA9PT0gJ25pY2UtdG8taGF2ZScgJiYgXG5cdFx0XHRcdGluc3RhbGxlZFBsdWdpbklkcy5pbmNsdWRlcyhwLmlkKSAmJiBcblx0XHRcdFx0IWlnbm9yZWRQbHVnaW5zLmluY2x1ZGVzKHAuaWQpXG5cdFx0XHQpXG5cdFx0XHQuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XG5cblx0XHQvLyBFc3NlbnRpYWwgcGx1Z2lucyBzZWN0aW9uXG5cdFx0aWYgKGVzc2VudGlhbFBsdWdpbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnRXNzZW50aWFsIHBsdWdpbnMnLCBjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1oZWFkZXInIH0pO1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxuXHRcdFx0XHQvLyBGYWxzZSBwb3NpdGl2ZTogXCJWYXVsdCBDTVNcIiBpcyBhIHByb3BlciBub3VuIChwcm9kdWN0IG5hbWUpIGFuZCBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9ic2lkaWFubWQvdWkvc2VudGVuY2UtY2FzZVxuXHRcdFx0XHR0ZXh0OiAnVGhlc2UgcGx1Z2lucyBhcmUgcmVjb21tZW5kZWQgZm9yIHRoZSBjb3JlIFZhdWx0IENNUyBleHBlcmllbmNlLicsXG5cdFx0XHRcdGNsczogJ3ZhdWx0LWNtcy1zZWN0aW9uLWRlc2MnXG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yIChjb25zdCBwbHVnaW4gb2YgZXNzZW50aWFsUGx1Z2lucykge1xuXHRcdFx0XHRjb25zdCBwbHVnaW5JbnN0YW5jZSA9IHBsdWdpbnM/LnBsdWdpbnM/LltwbHVnaW4uaWRdO1xuXHRcdFx0XHRjb25zdCBpc0luc3RhbGxlZCA9ICEhcGx1Z2luSW5zdGFuY2U7XG5cdFx0XHRcdC8vIENoZWNrIGlmIHBsdWdpbiBpcyBlbmFibGVkIC0gdXNlIGVuYWJsZWRQbHVnaW5zIFNldCAobW9yZSByZWxpYWJsZSlcblx0XHRcdFx0Y29uc3QgcGx1Z2luSW5zdGFuY2VUeXBlZCA9IHBsdWdpbkluc3RhbmNlIGFzIHsgZW5hYmxlZD86IGJvb2xlYW4gfSB8IHVuZGVmaW5lZDtcblx0XHRcdFx0Y29uc3QgaXNDdXJyZW50bHlFbmFibGVkID0gcGx1Z2lucz8uZW5hYmxlZFBsdWdpbnM/Lmhhcz8uKHBsdWdpbi5pZCkgPz8gcGx1Z2luSW5zdGFuY2VUeXBlZD8uZW5hYmxlZCA/PyBmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoYFBsdWdpbiAke3BsdWdpbi5pZH06IGluc3RhbGxlZD0ke2lzSW5zdGFsbGVkfSwgZW5hYmxlZD0ke2lzQ3VycmVudGx5RW5hYmxlZH1gKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFN5bmMgc3RhdGUgd2l0aCBhY3R1YWwgcGx1Z2luIHN0YXRlXG5cdFx0XHRcdGlmIChpc0luc3RhbGxlZCAmJiBpc0N1cnJlbnRseUVuYWJsZWQpIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmlkKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5wdXNoKHBsdWdpbi5pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zID0gdGhpcy5zdGF0ZS5kaXNhYmxlZFBsdWdpbnMuZmlsdGVyKHAgPT4gcCAhPT0gcGx1Z2luLmlkKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0luc3RhbGxlZCAmJiAhaXNDdXJyZW50bHlFbmFibGVkKSB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucyA9IHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMuZmlsdGVyKHAgPT4gcCAhPT0gcGx1Z2luLmlkKTtcblx0XHRcdFx0XHRpZiAoIXRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zLmluY2x1ZGVzKHBsdWdpbi5pZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuZGlzYWJsZWRQbHVnaW5zLnB1c2gocGx1Z2luLmlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdFx0XHQuc2V0TmFtZShwbHVnaW4ubmFtZSlcblx0XHRcdFx0XHQuc2V0RGVzYyhpc0luc3RhbGxlZCA/IFxuXHRcdFx0XHRcdFx0KGlzQ3VycmVudGx5RW5hYmxlZCA/ICdJbnN0YWxsZWQgYW5kIGVuYWJsZWQnIDogJ0luc3RhbGxlZCBidXQgZGlzYWJsZWQnKSA6IFxuXHRcdFx0XHRcdFx0J05vdCBpbnN0YWxsZWQnKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFkZCBpY29uIGluc3RlYWQgb2YgdG9nZ2xlXG5cdFx0XHRcdGNvbnN0IGljb25Db250YWluZXIgPSBzZXR0aW5nLmNvbnRyb2xFbC5jcmVhdGVEaXYoeyBjbHM6ICd2YXVsdC1jbXMtcGx1Z2luLXN0YXR1cycgfSk7XG5cdFx0XHRcdGlmIChpc0luc3RhbGxlZCAmJiBpc0N1cnJlbnRseUVuYWJsZWQpIHtcblx0XHRcdFx0XHRzZXRJY29uKGljb25Db250YWluZXIsICdsdWNpZGUtY2hlY2stY2lyY2xlLTInKTtcblx0XHRcdFx0XHRzZXRDc3NQcm9wcyhpY29uQ29udGFpbmVyLCB7IGNvbG9yOiAndmFyKC0tdGV4dC1zdWNjZXNzKScgfSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2V0SWNvbihpY29uQ29udGFpbmVyLCAnbHVjaWRlLXgtY2lyY2xlJyk7XG5cdFx0XHRcdFx0c2V0Q3NzUHJvcHMoaWNvbkNvbnRhaW5lciwgeyBjb2xvcjogJ3ZhcigtLXRleHQtZXJyb3IpJyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE5pY2UgdG8gaGF2ZSBwbHVnaW5zIHNlY3Rpb25cblx0XHRpZiAobmljZVRvSGF2ZVBsdWdpbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnTmljZSB0byBoYXZlIHBsdWdpbnMnLCBjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1oZWFkZXInIH0pO1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ3AnLCB7IFxuXHRcdFx0XHR0ZXh0OiAnVGhlc2UgcGx1Z2lucyBjYW4gYmUgaGVscGZ1bCBkZXBlbmRpbmcgb24geW91ciB0aGVtZVxcJ3MgY2FwYWJpbGl0aWVzIGFuZCB3b3JrZmxvdyBuZWVkcy4nLFxuXHRcdFx0XHRjbHM6ICd2YXVsdC1jbXMtc2VjdGlvbi1kZXNjJ1xuXHRcdFx0fSk7XG5cblx0XHRcdGZvciAoY29uc3QgcGx1Z2luIG9mIG5pY2VUb0hhdmVQbHVnaW5zKSB7XG5cdFx0XHRcdGNvbnN0IHBsdWdpbkluc3RhbmNlID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbi5pZF07XG5cdFx0XHRcdGNvbnN0IGlzSW5zdGFsbGVkID0gISFwbHVnaW5JbnN0YW5jZTtcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgcGx1Z2luIGlzIGVuYWJsZWQgLSB1c2UgZW5hYmxlZFBsdWdpbnMgU2V0IChtb3JlIHJlbGlhYmxlKVxuXHRcdFx0XHRjb25zdCBwbHVnaW5JbnN0YW5jZVR5cGVkID0gcGx1Z2luSW5zdGFuY2UgYXMgeyBlbmFibGVkPzogYm9vbGVhbiB9IHwgdW5kZWZpbmVkO1xuXHRcdFx0XHRjb25zdCBpc0N1cnJlbnRseUVuYWJsZWQgPSBwbHVnaW5zPy5lbmFibGVkUGx1Z2lucz8uaGFzPy4ocGx1Z2luLmlkKSA/PyBwbHVnaW5JbnN0YW5jZVR5cGVkPy5lbmFibGVkID8/IGZhbHNlO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgUGx1Z2luICR7cGx1Z2luLmlkfTogaW5zdGFsbGVkPSR7aXNJbnN0YWxsZWR9LCBlbmFibGVkPSR7aXNDdXJyZW50bHlFbmFibGVkfWApO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gU3luYyBzdGF0ZSB3aXRoIGFjdHVhbCBwbHVnaW4gc3RhdGVcblx0XHRcdFx0aWYgKGlzSW5zdGFsbGVkICYmIGlzQ3VycmVudGx5RW5hYmxlZCkge1xuXHRcdFx0XHRcdGlmICghdGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4uaWQpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLnB1c2gocGx1Z2luLmlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5kaXNhYmxlZFBsdWdpbnMgPSB0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucy5maWx0ZXIocCA9PiBwICE9PSBwbHVnaW4uaWQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzSW5zdGFsbGVkICYmICFpc0N1cnJlbnRseUVuYWJsZWQpIHtcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zID0gdGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5maWx0ZXIocCA9PiBwICE9PSBwbHVnaW4uaWQpO1xuXHRcdFx0XHRcdGlmICghdGhpcy5zdGF0ZS5kaXNhYmxlZFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luLmlkKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5kaXNhYmxlZFBsdWdpbnMucHVzaChwbHVnaW4uaWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgc2V0dGluZyA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0XHRcdC5zZXROYW1lKHBsdWdpbi5uYW1lKVxuXHRcdFx0XHRcdC5zZXREZXNjKGlzSW5zdGFsbGVkID8gXG5cdFx0XHRcdFx0XHQoaXNDdXJyZW50bHlFbmFibGVkID8gJ0luc3RhbGxlZCBhbmQgZW5hYmxlZCcgOiAnSW5zdGFsbGVkIGJ1dCBkaXNhYmxlZCcpIDogXG5cdFx0XHRcdFx0XHQnTm90IGluc3RhbGxlZCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQWRkIGljb24gaW5zdGVhZCBvZiB0b2dnbGVcblx0XHRcdFx0Y29uc3QgaWNvbkNvbnRhaW5lciA9IHNldHRpbmcuY29udHJvbEVsLmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy1wbHVnaW4tc3RhdHVzJyB9KTtcblx0XHRcdFx0aWYgKGlzSW5zdGFsbGVkICYmIGlzQ3VycmVudGx5RW5hYmxlZCkge1xuXHRcdFx0XHRcdHNldEljb24oaWNvbkNvbnRhaW5lciwgJ2x1Y2lkZS1jaGVjay1jaXJjbGUtMicpO1xuXHRcdFx0XHRcdHNldENzc1Byb3BzKGljb25Db250YWluZXIsIHsgY29sb3I6ICd2YXIoLS10ZXh0LXN1Y2Nlc3MpJyB9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXRJY29uKGljb25Db250YWluZXIsICdsdWNpZGUteC1jaXJjbGUnKTtcblx0XHRcdFx0XHRzZXRDc3NQcm9wcyhpY29uQ29udGFpbmVyLCB7IGNvbG9yOiAndmFyKC0tdGV4dC1lcnJvciknIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gcGx1Z2lucyBmb3VuZFxuXHRcdGlmIChlc3NlbnRpYWxQbHVnaW5zLmxlbmd0aCA9PT0gMCAmJiBuaWNlVG9IYXZlUGx1Z2lucy5sZW5ndGggPT09IDApIHtcblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywgeyBcblx0XHRcdFx0Ly8gRmFsc2UgcG9zaXRpdmU6IFwiVmF1bHQgQ01TXCIgaXMgYSBwcm9wZXIgbm91biAocHJvZHVjdCBuYW1lKSBhbmQgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvYnNpZGlhbm1kL3VpL3NlbnRlbmNlLWNhc2Vcblx0XHRcdFx0dGV4dDogJ05vIFZhdWx0IENNUyBwbHVnaW5zIGRldGVjdGVkLiBNYWtlIHN1cmUgeW91IGhhdmUgaW5zdGFsbGVkIHRoZSByZWNvbW1lbmRlZCBwbHVnaW5zLicgXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGdldFRpdGxlKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdPcHRpb25hbCBQbHVnaW5zJztcblx0fVxuXG5cdGdldERlc2NyaXB0aW9uKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuICdDb25maWd1cmUgb3B0aW9uYWwgcGx1Z2lucyc7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbmV4cG9ydCBjbGFzcyBQbHVnaW5NYW5hZ2VyIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRhc3luYyBlbmFibGVQbHVnaW4ocGx1Z2luSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiB7IHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCB7IGVuYWJsZWQ/OiBib29sZWFuIH0+OyBlbmFibGVQbHVnaW4/OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB9IH0pLnBsdWdpbnM7XHJcblx0XHRpZiAoIXBsdWdpbnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnMucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdGlmIChwbHVnaW4gJiYgIXBsdWdpbi5lbmFibGVkKSB7XHJcblx0XHRcdGF3YWl0IHBsdWdpbnMuZW5hYmxlUGx1Z2luPy4ocGx1Z2luSWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgZGlzYWJsZVBsdWdpbihwbHVnaW5JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IHsgcGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIHsgZW5hYmxlZD86IGJvb2xlYW4gfT47IGRpc2FibGVQbHVnaW4/OiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB9IH0pLnBsdWdpbnM7XHJcblx0XHRpZiAoIXBsdWdpbnMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnMucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdGlmIChwbHVnaW4gJiYgcGx1Z2luLmVuYWJsZWQpIHtcclxuXHRcdFx0YXdhaXQgcGx1Z2lucy5kaXNhYmxlUGx1Z2luPy4ocGx1Z2luSWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0YXN5bmMgc2V0UGx1Z2luU3RhdGVzKGVuYWJsZWQ6IHN0cmluZ1tdLCBkaXNhYmxlZDogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdC8vIEZpbHRlciBvdXQgY29yZSBwbHVnaW5zIGZyb20gZGlzYWJsZWQgbGlzdCBqdXN0IGluIGNhc2VcclxuXHRcdGNvbnN0IGNvcmVQbHVnaW5zID0gWydiYXNlcy1jbXMnLCAnYXN0cm8tY29tcG9zZXInLCAndmF1bHQtY21zJ107XHJcblx0XHRjb25zdCBzYWZlRGlzYWJsZWQgPSBkaXNhYmxlZC5maWx0ZXIocCA9PiAhY29yZVBsdWdpbnMuaW5jbHVkZXMocCkpO1xyXG5cclxuXHRcdC8vIERpc2FibGUgcGx1Z2lucyBmaXJzdFxyXG5cdFx0Zm9yIChjb25zdCBwbHVnaW5JZCBvZiBzYWZlRGlzYWJsZWQpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5kaXNhYmxlUGx1Z2luKHBsdWdpbklkKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUaGVuIGVuYWJsZSBwbHVnaW5zXHJcblx0XHRmb3IgKGNvbnN0IHBsdWdpbklkIG9mIGVuYWJsZWQpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5lbmFibGVQbHVnaW4ocGx1Z2luSWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0UHJlc2V0UGx1Z2lucyhwcmVzZXQ6ICd2YW5pbGxhJyB8ICdvcGluaW9uYXRlZCcgfCAnY3VzdG9tJyk6IHsgZW5hYmxlZDogc3RyaW5nW107IGRpc2FibGVkOiBzdHJpbmdbXSB9IHtcclxuXHRcdC8vIENvcmUgcGx1Z2lucyB0aGF0IHNob3VsZCBhbHdheXMgYmUgZW5hYmxlZCAobm90IG9wdGlvbmFsKVxyXG5cdFx0Y29uc3QgY29yZVBsdWdpbnMgPSBbXHJcblx0XHRcdCdhc3Ryby1jb21wb3NlcicsXHJcblx0XHRcdCdiYXNlcy1jbXMnLFxyXG5cdFx0XHQnaG9tZXBhZ2UnLFxyXG5cdFx0XHQnbmV3LXRhYi1kZWZhdWx0LXBhZ2UnLFxyXG5cdFx0XHQncHJvcGVydHktb3Zlci1maWxlLW5hbWUnLFxyXG5cdFx0XHQnc2V0dGluZ3Mtc2VhcmNoJyxcclxuXHRcdFx0J3N0YXR1c2Jhci1vcmdhbml6ZXInLFxyXG5cdFx0XHQnc2VvJyxcclxuXHRcdFx0J3VpLXR3ZWFrZXInLFxyXG5cdFx0XHQnemVubW9kZScsXHJcblx0XHRcdCdjbWRyJyxcclxuXHRcdFx0J3NpbXBsZS1mb2N1cycsXHJcblx0XHRcdCd0YWctd3JhbmdsZXInXHJcblx0XHRdO1xyXG5cclxuXHRcdC8vIE9wdGlvbmFsIHBsdWdpbnMgdGhhdCBjYW4gYmUgZW5hYmxlZC9kaXNhYmxlZFxyXG5cdFx0Y29uc3Qgb3B0aW9uYWxQbHVnaW5zID0gW1xyXG5cdFx0XHQnZWRpdGluZy10b29sYmFyJyxcclxuXHRcdFx0J2luc2VydC11bnNwbGFzaC1pbWFnZScsXHJcblx0XHRcdCdjdXN0b20tc2F2ZScsXHJcblx0XHRcdCd0aXRsZS1vbmx5LXRhYicsXHJcblx0XHRcdCdvYnNpZGlhbi1wYXN0ZS1pbWFnZS1yZW5hbWUnLFxyXG5cdFx0XHQnb2JzaWRpYW40Mi1icmF0JyxcclxuXHRcdFx0J29ic2lkaWFuLWhpZGVyJyxcclxuXHRcdFx0J2Rpc2FibGUtdGFicycsXHJcblx0XHRcdCdvYnNpZGlhbi1zdHlsZS1zZXR0aW5ncycsXHJcblx0XHRcdCdtZHgtYXMtbWQtb2JzaWRpYW4nLFxyXG5cdFx0XHQnZXhwbG9yZXItZm9jdXMnXHJcblx0XHRdO1xyXG5cclxuXHRcdC8vIE9waW5pb25hdGVkLXNwZWNpZmljIHBsdWdpbnNcclxuXHRcdGNvbnN0IG9waW5pb25hdGVkUGx1Z2lucyA9IFtcclxuXHRcdFx0J29ic2lkaWFuLW94eWdlbicsXHJcblx0XHRcdCdvYnNpZGlhbi1zdHlsZS1zZXR0aW5ncydcclxuXHRcdF07XHJcblxyXG5cdFx0aWYgKHByZXNldCA9PT0gJ3ZhbmlsbGEnKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZW5hYmxlZDogWy4uLmNvcmVQbHVnaW5zLCAuLi5vcHRpb25hbFBsdWdpbnMuZmlsdGVyKHAgPT4gIW9waW5pb25hdGVkUGx1Z2lucy5pbmNsdWRlcyhwKSldLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBvcGluaW9uYXRlZFBsdWdpbnNcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiAocHJlc2V0ID09PSAnb3BpbmlvbmF0ZWQnKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0ZW5hYmxlZDogWy4uLmNvcmVQbHVnaW5zLCAuLi5vcHRpb25hbFBsdWdpbnNdLFxyXG5cdFx0XHRcdGRpc2FibGVkOiBbXVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gQ3VzdG9tIC0gcmV0dXJuIGFsbCBhcyBhdmFpbGFibGVcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRlbmFibGVkOiBbXSxcclxuXHRcdFx0XHRkaXNhYmxlZDogW11cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIFNldHRpbmcsIE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFByb2plY3RPcHRpbWl6ZXIgfSBmcm9tICcuLi8uLi91dGlscy9Qcm9qZWN0T3B0aW1pemVyJztcblxuZXhwb3J0IGNsYXNzIElnbm9yZVN0ZXAgZXh0ZW5kcyBCYXNlV2l6YXJkU3RlcCB7XG5cdHByaXZhdGUgb3B0aW1pemVyOiBQcm9qZWN0T3B0aW1pemVyO1xuXHRwcml2YXRlIGdpdFNldHRpbmc6IFNldHRpbmc7XG5cdHByaXZhdGUgdml0ZVNldHRpbmc6IFNldHRpbmc7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHAsIGNvbnRhaW5lckVsLCBzdGF0ZSwgb25OZXh0LCBvbkJhY2ssIG9uQ2FuY2VsKTtcblx0XHR0aGlzLm9wdGltaXplciA9IG5ldyBQcm9qZWN0T3B0aW1pemVyKGFwcCwgc3RhdGUpO1xuXHR9XG5cblx0YXN5bmMgZGlzcGxheSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLm9wdGltaXplci5nZXRTdGF0dXMoKTtcblx0XHR0aGlzLnN0YXRlLmlnbm9yZUNvbmZpZy5naXRJZ25vcmVDb25maWd1cmVkID0gc3RhdHVzLmdpdElnbm9yZVN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnO1xuXHRcdHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnLnZpdGVJZ25vcmVDb25maWd1cmVkID0gc3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMgPT09ICdjb25maWd1cmVkJztcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHsgdGV4dDogJ1Byb2plY3Qgb3B0aW1pemF0aW9uIChvcHRpb25hbCknIH0pO1xuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdwJywge1xuXHRcdFx0dGV4dDogJ09wdGltaXplIHlvdXIgcHJvamVjdCBieSBpZ25vcmluZyBPYnNpZGlhbi1zcGVjaWZpYyBmaWxlcyBpbiBHaXQgYW5kIFZpdGUuJ1xuXHRcdH0pO1xuXG5cdFx0Ly8gR2l0IElnbm9yZSBTZXR0aW5nXG5cdFx0dGhpcy5naXRTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpO1xuXHRcdHRoaXMudXBkYXRlR2l0U2V0dGluZyhzdGF0dXMuZ2l0SWdub3JlU3RhdHVzKTtcblxuXHRcdC8vIFZpdGUgSWdub3JlIFNldHRpbmdcblx0XHR0aGlzLnZpdGVTZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpO1xuXHRcdHRoaXMudXBkYXRlVml0ZVNldHRpbmcoc3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMpO1xuXHRcdFxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlR2l0U2V0dGluZyhzdGF0dXM6ICdjb25maWd1cmVkJyB8ICdub3QtY29uZmlndXJlZCcpIHtcblx0XHR0aGlzLmdpdFNldHRpbmcuc2V0TmFtZSgnSWdub3JlIGluIEdpdCcpXG5cdFx0XHQuc2V0RGVzYygnQWRkIE9ic2lkaWFuIHdvcmtzcGFjZSBmaWxlcyB0byAuZ2l0aWdub3JlIHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlaW5nIHRyYWNrZWQuJylcblx0XHRcdC5jbGVhcigpOyAvLyBDbGVhciBleGlzdGluZyBidXR0b25zIGFuZCBzdGF0dXNcblx0XHRcdFxuXHRcdHRoaXMuZ2l0U2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLm9wdGltaXplci5jb25maWd1cmVHaXRJZ25vcmUoKTtcblx0XHRcdFx0XHRcdHRoaXMuc3RhdGUuaWdub3JlQ29uZmlnLmdpdElnbm9yZUNvbmZpZ3VyZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSgnLmdpdGlnbm9yZSB1cGRhdGVkJyk7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXdTdGF0dXMgPSBhd2FpdCB0aGlzLm9wdGltaXplci5nZXRTdGF0dXMoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlR2l0U2V0dGluZyhuZXdTdGF0dXMuZ2l0SWdub3JlU3RhdHVzKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgRmFpbGVkIHRvIHVwZGF0ZSAuZ2l0aWdub3JlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5vcHRpbWl6ZXIucmVuZGVyU3RhdHVzKHRoaXMuZ2l0U2V0dGluZy5jb250cm9sRWwsIHN0YXR1cyk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVZpdGVTZXR0aW5nKHN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJykge1xuXHRcdHRoaXMudml0ZVNldHRpbmcuc2V0TmFtZSgnSWdub3JlIGluIFZpdGUnKVxuXHRcdFx0LnNldERlc2MoJ0NvbmZpZ3VyZSBWaXRlIHRvIGlnbm9yZSBPYnNpZGlhbiBhbmQgYmFzZXMgZm9sZGVycy4nKVxuXHRcdFx0LmNsZWFyKCk7IC8vIENsZWFyIGV4aXN0aW5nIGJ1dHRvbnMgYW5kIHN0YXR1c1xuXHRcdFx0XG5cdFx0dGhpcy52aXRlU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcblx0XHRcdGJ1dHRvbi5zZXRCdXR0b25UZXh0KHN0YXR1cyA9PT0gJ2NvbmZpZ3VyZWQnID8gJ1JlLWNvbmZpZ3VyZScgOiAnQ29uZmlndXJlJylcblx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLm9wdGltaXplci5jb25maWd1cmVWaXRlSWdub3JlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnN0YXRlLmlnbm9yZUNvbmZpZy52aXRlSWdub3JlQ29uZmlndXJlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdWaXRlIG9wdGltaXphdGlvbiBhcHBsaWVkJyk7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXdTdGF0dXMgPSBhd2FpdCB0aGlzLm9wdGltaXplci5nZXRTdGF0dXMoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlVml0ZVNldHRpbmcobmV3U3RhdHVzLnZpdGVJZ25vcmVTdGF0dXMpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gdXBkYXRlIFZpdGUgY29uZmlnOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5vcHRpbWl6ZXIucmVuZGVyU3RhdHVzKHRoaXMudml0ZVNldHRpbmcuY29udHJvbEVsLCBzdGF0dXMpO1xuXHR9XG5cblx0dmFsaWRhdGUoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnUHJvamVjdCBvcHRpbWl6YXRpb24gKG9wdGlvbmFsKSc7XG5cdH1cblxuXHRnZXREZXNjcmlwdGlvbigpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnQ29uZmlndXJlIHByb2plY3QtbGV2ZWwgaWdub3Jlcyc7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIHNldEljb24gfSBmcm9tICdvYnNpZGlhbic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgV2l6YXJkU3RhdGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW1pemF0aW9uU3RhdHVzIHtcblx0Z2l0SWdub3JlU3RhdHVzOiAnY29uZmlndXJlZCcgfCAnbm90LWNvbmZpZ3VyZWQnO1xuXHR2aXRlSWdub3JlU3RhdHVzOiAnY29uZmlndXJlZCcgfCAnbm90LWNvbmZpZ3VyZWQnO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3Igc2V0Q3NzUHJvcHNcbiAqL1xuZnVuY3Rpb24gc2V0Q3NzUHJvcHMoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogdm9pZCB7XG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BzKSkge1xuXHRcdGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LnJlcGxhY2UoLyhbQS1aXSkvZywgJy0kMScpLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgUHJvamVjdE9wdGltaXplciB7XG5cdHByaXZhdGUgYXBwOiBBcHA7XG5cdHByaXZhdGUgc3RhdGU6IFdpemFyZFN0YXRlO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBzdGF0ZTogV2l6YXJkU3RhdGUpIHtcblx0XHR0aGlzLmFwcCA9IGFwcDtcblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgZ2V0U3RhdHVzKCk6IFByb21pc2U8T3B0aW1pemF0aW9uU3RhdHVzPiB7XG5cdFx0Y29uc3Qgc3RhdHVzOiBPcHRpbWl6YXRpb25TdGF0dXMgPSB7XG5cdFx0XHRnaXRJZ25vcmVTdGF0dXM6ICdub3QtY29uZmlndXJlZCcsXG5cdFx0XHR2aXRlSWdub3JlU3RhdHVzOiAnbm90LWNvbmZpZ3VyZWQnXG5cdFx0fTtcblxuXHRcdGNvbnN0IHByb2plY3RSb290ID0gdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5wcm9qZWN0Um9vdDtcblx0XHRpZiAoIXByb2plY3RSb290KSByZXR1cm4gc3RhdHVzO1xuXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXG5cdFx0Ly8gQ2hlY2sgLmdpdGlnbm9yZVxuXHRcdGNvbnN0IGdpdElnbm9yZVBhdGggPSBwYXRoLmpvaW4ocHJvamVjdFJvb3QsICcuZ2l0aWdub3JlJykucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXHRcdGlmIChhd2FpdCBhZGFwdGVyLmV4aXN0cyhnaXRJZ25vcmVQYXRoKSkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IGFkYXB0ZXIucmVhZChnaXRJZ25vcmVQYXRoKTtcblx0XHRcdGlmIChjb250ZW50LmluY2x1ZGVzKGAke2NvbmZpZ0Rpcn0vd29ya3NwYWNlLmpzb25gKSkge1xuXHRcdFx0XHRzdGF0dXMuZ2l0SWdub3JlU3RhdHVzID0gJ2NvbmZpZ3VyZWQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIFZpdGUgY29uZmlnXG5cdFx0Y29uc3QgYXN0cm9Db25maWdOYW1lcyA9IFsnYXN0cm8uY29uZmlnLnRzJywgJ2FzdHJvLmNvbmZpZy5tanMnLCAnYXN0cm8uY29uZmlnLmpzJywgJ2FzdHJvLmNvbmZpZy5tdHMnLCAnYXN0cm8uY29uZmlnLmNqcyddO1xuXHRcdGxldCByZXNvbHZlZFZpdGVDb25maWdQYXRoID0gJyc7XG5cblx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgYXN0cm9Db25maWdOYW1lcykge1xuXHRcdFx0Y29uc3QgcCA9IHBhdGguam9pbihwcm9qZWN0Um9vdCwgbmFtZSkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXHRcdFx0aWYgKGF3YWl0IGFkYXB0ZXIuZXhpc3RzKHApKSB7XG5cdFx0XHRcdHJlc29sdmVkVml0ZUNvbmZpZ1BhdGggPSBwO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlc29sdmVkVml0ZUNvbmZpZ1BhdGggJiYgdGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uPy5jb25maWdGaWxlUGF0aCkge1xuXHRcdFx0cmVzb2x2ZWRWaXRlQ29uZmlnUGF0aCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbi5jb25maWdGaWxlUGF0aDtcblx0XHR9XG5cblx0XHRpZiAocmVzb2x2ZWRWaXRlQ29uZmlnUGF0aCAmJiBhd2FpdCBhZGFwdGVyLmV4aXN0cyhyZXNvbHZlZFZpdGVDb25maWdQYXRoKSkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IGFkYXB0ZXIucmVhZChyZXNvbHZlZFZpdGVDb25maWdQYXRoKTtcblx0XHRcdGlmIChjb250ZW50LmluY2x1ZGVzKCdzZXJ2ZXIud2F0Y2guaWdub3JlZCcpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ2lnbm9yZWQ6JykpIHtcblx0XHRcdFx0aWYgKGNvbnRlbnQuaW5jbHVkZXMoY29uZmlnRGlyKSkge1xuXHRcdFx0XHRcdHN0YXR1cy52aXRlSWdub3JlU3RhdHVzID0gJ2NvbmZpZ3VyZWQnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YXR1cztcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBjb25maWd1cmVHaXRJZ25vcmUoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgcHJvamVjdFJvb3QgPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LnByb2plY3RSb290O1xuXHRcdGlmICghcHJvamVjdFJvb3QpIHJldHVybjtcblxuXHRcdGNvbnN0IGNvbmZpZ0RpciA9IHRoaXMuYXBwLnZhdWx0LmNvbmZpZ0Rpcjtcblx0XHRjb25zdCBnaXRJZ25vcmVQYXRoID0gcGF0aC5qb2luKHByb2plY3RSb290LCAnLmdpdGlnbm9yZScpLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblx0XHRjb25zdCBydWxlcyA9IGBcXG4jIE9ic2lkaWFuIHdvcmtzcGFjZSBmaWxlc1xcbioqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UuanNvblxcbioqLyR7Y29uZmlnRGlyfS93b3Jrc3BhY2UtbW9iaWxlLmpzb25cXG5gO1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlmIChhd2FpdCBhZGFwdGVyLmV4aXN0cyhnaXRJZ25vcmVQYXRoKSkge1xuXHRcdFx0XHRsZXQgY29udGVudCA9IGF3YWl0IGFkYXB0ZXIucmVhZChnaXRJZ25vcmVQYXRoKTtcblx0XHRcdFx0aWYgKCFjb250ZW50LmluY2x1ZGVzKGAke2NvbmZpZ0Rpcn0vd29ya3NwYWNlLmpzb25gKSkge1xuXHRcdFx0XHRcdGNvbnRlbnQgKz0gcnVsZXM7XG5cdFx0XHRcdFx0YXdhaXQgYWRhcHRlci53cml0ZShnaXRJZ25vcmVQYXRoLCBjb250ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXdhaXQgYWRhcHRlci53cml0ZShnaXRJZ25vcmVQYXRoLCBydWxlcyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgLmdpdGlnbm9yZTonLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgYXN5bmMgY29uZmlndXJlVml0ZUlnbm9yZSgpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBwcm9qZWN0Um9vdCA9IHRoaXMuc3RhdGUucHJvamVjdERldGVjdGlvbj8ucHJvamVjdFJvb3Q7XG5cdFx0aWYgKCFwcm9qZWN0Um9vdCkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXG5cdFx0Y29uc3QgYXN0cm9Db25maWdOYW1lcyA9IFsnYXN0cm8uY29uZmlnLnRzJywgJ2FzdHJvLmNvbmZpZy5tanMnLCAnYXN0cm8uY29uZmlnLmpzJywgJ2FzdHJvLmNvbmZpZy5tdHMnLCAnYXN0cm8uY29uZmlnLmNqcyddO1xuXHRcdGxldCByZXNvbHZlZENvbmZpZ1BhdGggPSAnJztcblx0XHRsZXQgY29uZmlnRmlsZU5hbWUgPSAnJztcblxuXHRcdGZvciAoY29uc3QgbmFtZSBvZiBhc3Ryb0NvbmZpZ05hbWVzKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aC5qb2luKHByb2plY3RSb290LCBuYW1lKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cdFx0XHRpZiAoYXdhaXQgYWRhcHRlci5leGlzdHMocCkpIHtcblx0XHRcdFx0cmVzb2x2ZWRDb25maWdQYXRoID0gcDtcblx0XHRcdFx0Y29uZmlnRmlsZU5hbWUgPSBuYW1lO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlc29sdmVkQ29uZmlnUGF0aCAmJiB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24/LmNvbmZpZ0ZpbGVQYXRoKSB7XG5cdFx0XHRyZXNvbHZlZENvbmZpZ1BhdGggPSB0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24uY29uZmlnRmlsZVBhdGg7XG5cdFx0XHRjb25maWdGaWxlTmFtZSA9IHBhdGguYmFzZW5hbWUocmVzb2x2ZWRDb25maWdQYXRoKTtcblx0XHR9XG5cblx0XHRpZiAoIXJlc29sdmVkQ29uZmlnUGF0aCB8fCAhKGF3YWl0IGFkYXB0ZXIuZXhpc3RzKHJlc29sdmVkQ29uZmlnUGF0aCkpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEFzdHJvIGNvbmZpZyBmaWxlIG5vdCBmb3VuZCBpbjogJHtwcm9qZWN0Um9vdH1gKTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IGFkYXB0ZXIucmVhZChyZXNvbHZlZENvbmZpZ1BhdGgpO1xuXHRcdFx0XG5cdFx0XHRpZiAoY29udGVudC5pbmNsdWRlcygnc2VydmVyLndhdGNoLmlnbm9yZWQnKSAmJiBjb250ZW50LmluY2x1ZGVzKGNvbmZpZ0RpcikpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBleHBvcnRJZHggPSBjb250ZW50Lmxhc3RJbmRleE9mKCdleHBvcnQgZGVmYXVsdCcpO1xuXHRcdFx0bGV0IHN0YXJ0SW5kZXggPSAtMTtcblx0XHRcdGxldCBlbmRJbmRleCA9IC0xO1xuXHRcdFx0bGV0IGNvbmZpZ0JvZHkgPSAnJztcblx0XHRcdGxldCBpc1dob2xlRmlsZSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoZXhwb3J0SWR4ICE9PSAtMSkge1xuXHRcdFx0XHRzdGFydEluZGV4ID0gY29udGVudC5pbmRleE9mKCd7JywgZXhwb3J0SWR4KTtcblx0XHRcdFx0aWYgKHN0YXJ0SW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0bGV0IGJyYWNlQ291bnQgPSAwO1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGNvbnRlbnRbaV0gPT09ICd7JykgYnJhY2VDb3VudCsrO1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoY29udGVudFtpXSA9PT0gJ30nKSBicmFjZUNvdW50LS07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmIChicmFjZUNvdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGVuZEluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChlbmRJbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdGNvbmZpZ0JvZHkgPSBjb250ZW50LnN1YnN0cmluZyhzdGFydEluZGV4ICsgMSwgZW5kSW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWNvbmZpZ0JvZHkgJiYgKGNvbnRlbnQuaW5jbHVkZXMoJ3ZpdGU6JykgfHwgY29udGVudC5pbmNsdWRlcygnc2VydmVyOicpKSkge1xuXHRcdFx0XHRjb25maWdCb2R5ID0gY29udGVudDtcblx0XHRcdFx0aXNXaG9sZUZpbGUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY29uZmlnQm9keSkge1xuXHRcdFx0XHRpZiAoY29uZmlnQm9keS5pbmNsdWRlcygndml0ZTonKSkge1xuXHRcdFx0XHRcdGlmIChjb25maWdCb2R5LmluY2x1ZGVzKCdzZXJ2ZXI6JykpIHtcblx0XHRcdFx0XHRcdGlmIChjb25maWdCb2R5LmluY2x1ZGVzKCd3YXRjaDonKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY29uZmlnQm9keS5pbmNsdWRlcygnaWdub3JlZDonKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICghY29uZmlnQm9keS5pbmNsdWRlcyhjb25maWdEaXIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gY29uZmlnQm9keS5yZXBsYWNlKC9pZ25vcmVkOlxccypcXFsoW15cXF1dKilcXF0vLCAoX20sIHAxOiBzdHJpbmcpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZXhpc3RpbmcgPSBwMS50cmltKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNlcGFyYXRvciA9IGV4aXN0aW5nID8gJywgJyA6ICcnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYGlnbm9yZWQ6IFske2V4aXN0aW5nfSR7c2VwYXJhdG9yfScqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11gO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbmZpZ0JvZHkgPSBjb25maWdCb2R5LnJlcGxhY2UoL3dhdGNoOlxccypcXHsvLCBgd2F0Y2g6IHtcXG4gICAgICBpZ25vcmVkOiBbJyoqLyR7Y29uZmlnRGlyfS8qKicsICcqKi9fYmFzZXMvKionLCAnKiovYmFzZXMvKionXSxgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uZmlnQm9keSA9IGNvbmZpZ0JvZHkucmVwbGFjZSgvc2VydmVyOlxccypcXHsvLCBgc2VydmVyOiB7XFxuICAgIHdhdGNoOiB7XFxuICAgICAgaWdub3JlZDogWycqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11cXG4gICAgfSxgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uZmlnQm9keSA9IGNvbmZpZ0JvZHkucmVwbGFjZSgvdml0ZTpcXHMqXFx7LywgYHZpdGU6IHtcXG4gICAgc2VydmVyOiB7XFxuICAgICAgd2F0Y2g6IHtcXG4gICAgICAgIGlnbm9yZWQ6IFsnKiovJHtjb25maWdEaXJ9LyoqJywgJyoqL19iYXNlcy8qKicsICcqKi9iYXNlcy8qKiddXFxuICAgICAgfVxcbiAgICB9LGApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaXNXaG9sZUZpbGUpIHtcblx0XHRcdFx0XHRcdGlmIChjb250ZW50LmluY2x1ZGVzKCdkZWZpbmVDb25maWcnKSkge1xuXHRcdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gY29uZmlnQm9keS5yZXBsYWNlKC9kZWZpbmVDb25maWdcXHMqXFwoXFxzKlxcey8sIGBkZWZpbmVDb25maWcoe1xcbiAgdml0ZToge1xcbiAgICBzZXJ2ZXI6IHtcXG4gICAgICB3YXRjaDoge1xcbiAgICAgICAgaWdub3JlZDogWycqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sYCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgY2xlYXIgcGxhY2UgdG8gaW5zZXJ0IFZpdGUgY29uZmlnIGluICR7Y29uZmlnRmlsZU5hbWV9LmApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25maWdCb2R5ID0gYFxcbiAgdml0ZToge1xcbiAgICBzZXJ2ZXI6IHtcXG4gICAgICB3YXRjaDoge1xcbiAgICAgICAgaWdub3JlZDogWycqKi8ke2NvbmZpZ0Rpcn0vKionLCAnKiovX2Jhc2VzLyoqJywgJyoqL2Jhc2VzLyoqJ11cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sYCArIGNvbmZpZ0JvZHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdXBkYXRlZENvbnRlbnQgPSBpc1dob2xlRmlsZSA/IGNvbmZpZ0JvZHkgOiAoY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpICsgY29uZmlnQm9keSArIGNvbnRlbnQuc3Vic3RyaW5nKGVuZEluZGV4KSk7XG5cdFx0XHRcdGF3YWl0IGFkYXB0ZXIud3JpdGUocmVzb2x2ZWRDb25maWdQYXRoLCB1cGRhdGVkQ29udGVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBjb25maWd1cmF0aW9uIGluICR7Y29uZmlnRmlsZU5hbWV9LmApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBQcm9qZWN0T3B0aW1pemVyOiBFcnJvciB1cGRhdGluZyAke2NvbmZpZ0ZpbGVOYW1lfTpgLCBlcnJvcik7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgcmVuZGVyU3RhdHVzKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHN0YXR1czogJ2NvbmZpZ3VyZWQnIHwgJ25vdC1jb25maWd1cmVkJykge1xuXHRcdGNvbnN0IHN0YXR1c0VsID0gY29udGFpbmVyLmNyZWF0ZURpdih7IGNsczogJ3ZhdWx0LWNtcy1wbHVnaW4tc3RhdHVzJyB9KTtcblx0XHRpZiAoc3RhdHVzID09PSAnY29uZmlndXJlZCcpIHtcblx0XHRcdHNldEljb24oc3RhdHVzRWwsICdsdWNpZGUtY2hlY2stY2lyY2xlLTInKTtcblx0XHRcdHNldENzc1Byb3BzKHN0YXR1c0VsLCB7IGNvbG9yOiAndmFyKC0tdGV4dC1zdWNjZXNzKScgfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNldEljb24oc3RhdHVzRWwsICdsdWNpZGUtYWxlcnQtY2lyY2xlJyk7XG5cdFx0XHRzZXRDc3NQcm9wcyhzdGF0dXNFbCwgeyBjb2xvcjogJ3ZhcigtLXRleHQtd2FybmluZyknIH0pO1xuXHRcdH1cblx0fVxufVxuIiwgImltcG9ydCB7IEFwcCwgTm90aWNlLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHNldENzc1Byb3BzIChtYXkgbm90IGJlIGluIHR5cGVzIHlldClcbmltcG9ydCB7IEJhc2VXaXphcmRTdGVwIH0gZnJvbSAnLi9CYXNlV2l6YXJkU3RlcCc7XG5pbXBvcnQgeyBXaXphcmRTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IFBsdWdpbk1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9QbHVnaW5NYW5hZ2VyJztcbmltcG9ydCB7IEJhc2VzQ01TQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvQmFzZXNDTVNDb25maWcnO1xuaW1wb3J0IHsgQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0FzdHJvQ29tcG9zZXJDb25maWcnO1xuaW1wb3J0IHsgU0VPQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvU0VPQ29uZmlnJztcbmltcG9ydCB7IENvbW1hbmRlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0NvbW1hbmRlckNvbmZpZyc7XG5pbXBvcnQgeyBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnJztcbmltcG9ydCB7IFVJVHdlYWtlckNvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL1VJVHdlYWtlckNvbmZpZyc7XG5pbXBvcnQgeyBJbWFnZUluc2VydGVyQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvSW1hZ2VJbnNlcnRlckNvbmZpZyc7XG5pbXBvcnQgeyBTaW1wbGVCYW5uZXJDb25maWd1cmF0b3IgfSBmcm9tICcuLi8uLi91dGlscy9TaW1wbGVCYW5uZXJDb25maWcnO1xuaW1wb3J0IHsgSW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvSW1hZ2VNYW5hZ2VyQ29uZmlnJztcbmltcG9ydCB7IEhvbWVCYXNlQ29uZmlndXJhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbHMvSG9tZUJhc2VDb25maWcnO1xuaW1wb3J0IHsgRXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvciB9IGZyb20gJy4uLy4uL3V0aWxzL0V4cGxvcmVyRm9jdXNDb25maWcnO1xuXG5leHBvcnQgY2xhc3MgRmluYWxpemVTdGVwIGV4dGVuZHMgQmFzZVdpemFyZFN0ZXAge1xuXHRwcml2YXRlIHBsdWdpbk1hbmFnZXI6IFBsdWdpbk1hbmFnZXI7XG5cdHByaXZhdGUgYmFzZXNDTVNDb25maWd1cmF0b3I6IEJhc2VzQ01TQ29uZmlndXJhdG9yO1xuXHRwcml2YXRlIGFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3I6IEFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3I7XG5cdHByaXZhdGUgc2VvQ29uZmlndXJhdG9yOiBTRU9Db25maWd1cmF0b3I7XG5cdHByaXZhdGUgY29tbWFuZGVyQ29uZmlndXJhdG9yOiBDb21tYW5kZXJDb25maWd1cmF0b3I7XG5cdHByaXZhdGUgcHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3I6IFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlndXJhdG9yO1xuXHRwcml2YXRlIHVpVHdlYWtlckNvbmZpZ3VyYXRvcjogVUlUd2Vha2VyQ29uZmlndXJhdG9yO1xuXHRwcml2YXRlIGltYWdlSW5zZXJ0ZXJDb25maWd1cmF0b3I6IEltYWdlSW5zZXJ0ZXJDb25maWd1cmF0b3I7XG5cdHByaXZhdGUgc2ltcGxlQmFubmVyQ29uZmlndXJhdG9yOiBTaW1wbGVCYW5uZXJDb25maWd1cmF0b3I7XG5cdHByaXZhdGUgaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yOiBJbWFnZU1hbmFnZXJDb25maWd1cmF0b3I7XG5cdHByaXZhdGUgaG9tZUJhc2VDb25maWd1cmF0b3I6IEhvbWVCYXNlQ29uZmlndXJhdG9yO1xuXHRwcml2YXRlIGV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3I6IEV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3I7XG5cdHByaXZhdGUgYXBwbGllZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cdGlzQXBwbGllZCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBsaWVkO1xuXHR9XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgc3RhdGU6IFdpemFyZFN0YXRlLCBvbk5leHQ6ICgpID0+IHZvaWQsIG9uQmFjazogKCkgPT4gdm9pZCwgb25DYW5jZWw6ICgpID0+IHZvaWQpIHtcblx0XHRzdXBlcihhcHAsIGNvbnRhaW5lckVsLCBzdGF0ZSwgb25OZXh0LCBvbkJhY2ssIG9uQ2FuY2VsKTtcblx0XHR0aGlzLnBsdWdpbk1hbmFnZXIgPSBuZXcgUGx1Z2luTWFuYWdlcihhcHApO1xuXHRcdHRoaXMuYmFzZXNDTVNDb25maWd1cmF0b3IgPSBuZXcgQmFzZXNDTVNDb25maWd1cmF0b3IoYXBwKTtcblx0XHR0aGlzLmFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IgPSBuZXcgQXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvcihhcHApO1xuXHRcdHRoaXMuc2VvQ29uZmlndXJhdG9yID0gbmV3IFNFT0NvbmZpZ3VyYXRvcihhcHApO1xuXHRcdHRoaXMuY29tbWFuZGVyQ29uZmlndXJhdG9yID0gbmV3IENvbW1hbmRlckNvbmZpZ3VyYXRvcihhcHApO1xuXHRcdHRoaXMucHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3IgPSBuZXcgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3IoYXBwKTtcblx0XHR0aGlzLnVpVHdlYWtlckNvbmZpZ3VyYXRvciA9IG5ldyBVSVR3ZWFrZXJDb25maWd1cmF0b3IoYXBwKTtcblx0XHR0aGlzLmltYWdlSW5zZXJ0ZXJDb25maWd1cmF0b3IgPSBuZXcgSW1hZ2VJbnNlcnRlckNvbmZpZ3VyYXRvcihhcHApO1xuXHRcdHRoaXMuc2ltcGxlQmFubmVyQ29uZmlndXJhdG9yID0gbmV3IFNpbXBsZUJhbm5lckNvbmZpZ3VyYXRvcihhcHApO1xuXHRcdHRoaXMuaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yID0gbmV3IEltYWdlTWFuYWdlckNvbmZpZ3VyYXRvcihhcHApO1xuXHRcdHRoaXMuaG9tZUJhc2VDb25maWd1cmF0b3IgPSBuZXcgSG9tZUJhc2VDb25maWd1cmF0b3IoYXBwKTtcblx0XHR0aGlzLmV4cGxvcmVyRm9jdXNDb25maWd1cmF0b3IgPSBuZXcgRXhwbG9yZXJGb2N1c0NvbmZpZ3VyYXRvcihhcHApO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdGaW5hbGl6ZSBjb25maWd1cmF0aW9uJyB9KTtcblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgncCcsIHsgXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgb2JzaWRpYW5tZC91aS9zZW50ZW5jZS1jYXNlXG5cdFx0XHR0ZXh0OiAnUmV2aWV3IHlvdXIgY29uZmlndXJhdGlvbiBhbmQgY2xpY2sgXCJBcHBseSBhbmQgcmVzdGFydFwiIGJlbG93IHRvIHNhdmUgYW5kIGFwcGx5IGFsbCBzZXR0aW5ncy4nIFxuXHRcdH0pO1xuXG5cdFx0Y29uc3Qgc3VtbWFyeSA9IGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2ZpbmFsaXplLXN1bW1hcnknIH0pO1xuXHRcdFxuXHRcdHN1bW1hcnkuY3JlYXRlRWwoJ2gzJywgeyB0ZXh0OiAnU3VtbWFyeScgfSk7XG5cdFx0XG5cdFx0Ly8gQ29udGVudCBUeXBlc1xuXHRcdGNvbnN0IGVuYWJsZWRDb250ZW50VHlwZXMgPSB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZCk7XG5cdFx0c3VtbWFyeS5jcmVhdGVFbCgncCcsIHsgdGV4dDogYENvbnRlbnQgVHlwZXM6ICR7ZW5hYmxlZENvbnRlbnRUeXBlcy5sZW5ndGh9YCB9KTtcblx0XHRcblx0XHQvLyBXWVNJV1lHIFRvb2xiYXJcblx0XHRzdW1tYXJ5LmNyZWF0ZUVsKCdwJywgeyB0ZXh0OiBgV1lTSVdZRyBUb29sYmFyOiAke3RoaXMuc3RhdGUuZW5hYmxlV1lTSVdZRyA/ICdFbmFibGVkJyA6ICdEaXNhYmxlZCd9YCB9KTtcblx0XHRcblx0XHQvLyBCYXNlcyBDTVMgVmlld3MgKGNvdW50IGVuYWJsZWQgY29udGVudCB0eXBlcyBhcyB2aWV3cyB0byBiZSBjcmVhdGVkKVxuXHRcdGNvbnN0IGJhc2VzVmlld3NDb3VudCA9IGVuYWJsZWRDb250ZW50VHlwZXMubGVuZ3RoO1xuXHRcdHN1bW1hcnkuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBCYXNlcyBDTVMgVmlld3M6ICR7YmFzZXNWaWV3c0NvdW50fSBuZXcgdmlldyR7YmFzZXNWaWV3c0NvdW50ICE9PSAxID8gJ3MnIDogJyd9IHRvIGJlIGNyZWF0ZWRgIH0pO1xuXHRcdFxuXHRcdC8vIFNFTyBTY2FuIERpcmVjdG9yaWVzXG5cdFx0Y29uc3Qgc2VvRGlyZWN0b3JpZXMgPSBlbmFibGVkQ29udGVudFR5cGVzLm1hcChjdCA9PiBjdC5mb2xkZXIpO1xuXHRcdGNvbnN0IHNlb0RpcmVjdG9yaWVzQ291bnQgPSBzZW9EaXJlY3Rvcmllcy5sZW5ndGg7XG5cdFx0c3VtbWFyeS5jcmVhdGVFbCgncCcsIHsgdGV4dDogYFNFTyBTY2FuIERpcmVjdG9yaWVzOiAke3Nlb0RpcmVjdG9yaWVzQ291bnR9IGRpcmVjdG9yJHtzZW9EaXJlY3Rvcmllc0NvdW50ICE9PSAxID8gJ2llcycgOiAneSd9ICgke3Nlb0RpcmVjdG9yaWVzLmpvaW4oJywgJyl9KWAgfSk7XG5cdH1cblxuXHRhc3luYyBhcHBseUNvbmZpZ3VyYXRpb24oc2hvdWxkUmVzdGFydDogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlDb25maWd1cmF0aW9uSW50ZXJuYWwoc2hvdWxkUmVzdGFydCk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGFwcGx5Q29uZmlndXJhdGlvbkludGVybmFsKHNob3VsZFJlc3RhcnQ6IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmICh0aGlzLmFwcGxpZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBTdGFydGluZyBjb25maWd1cmF0aW9uIGFwcGxpY2F0aW9uJyk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IEVuYWJsZWQgY29udGVudCB0eXBlczonLCB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZCkubWFwKGN0ID0+IGN0Lm5hbWUpKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29uZmlndXJlIHBsdWdpbnNcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQ29uZmlndXJpbmcgcGx1Z2luIHN0YXRlcycpO1xuXHRcdFx0YXdhaXQgdGhpcy5wbHVnaW5NYW5hZ2VyLnNldFBsdWdpblN0YXRlcyh0aGlzLnN0YXRlLmVuYWJsZWRQbHVnaW5zLCB0aGlzLnN0YXRlLmRpc2FibGVkUGx1Z2lucyk7XG5cblx0XHRcdC8vIENvbmZpZ3VyZSBCYXNlcyBDTVNcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQ29uZmlndXJpbmcgQmFzZXMgQ01TJyk7XG5cdFx0XHRhd2FpdCB0aGlzLmJhc2VzQ01TQ29uZmlndXJhdG9yLmNyZWF0ZU9yVXBkYXRlQmFzZUZpbGUoXG5cdFx0XHRcdHRoaXMuc3RhdGUuY29udGVudFR5cGVzLFxuXHRcdFx0XHR0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyxcblx0XHRcdFx0dGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCxcblx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLFxuXHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPT09IHRydWVcblx0XHRcdCk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IEJhc2VzIENNUyBjb25maWd1cmF0aW9uIGNvbXBsZXRlJyk7XG5cblx0XHRcdC8vIFN3aXRjaCBhY3RpdmUgQmFzZXMgdmlld3MgdG8gdGhlIG5ldyBkZWZhdWx0IHZpZXdcblx0XHRcdGlmICh0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkKSB7XG5cdFx0XHRcdGNvbnN0IGRlZmF1bHRUeXBlID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmluZChjdCA9PiBjdC5pZCA9PT0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCk7XG5cdFx0XHRcdGlmIChkZWZhdWx0VHlwZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogVXBkYXRpbmcgYWN0aXZlIEJhc2VzIHZpZXdzIHRvOicsIGRlZmF1bHRUeXBlLm5hbWUpO1xuXHRcdFx0XHRcdGF3YWl0IHRoaXMudXBkYXRlQWN0aXZlQmFzZXNWaWV3cyhkZWZhdWx0VHlwZS5uYW1lLCBzaG91bGRSZXN0YXJ0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb25maWd1cmUgQXN0cm8gQ29tcG9zZXJcblx0XHRcdGlmICh0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24pIHtcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBDb25maWd1cmluZyBBc3RybyBDb21wb3NlciwgZW5hYmxlTWR4U3VwcG9ydCA9JywgdGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0KTtcblx0XHRcdFx0Y29uc3QgYXN0cm9Db25maWcgPSBhd2FpdCB0aGlzLmFzdHJvQ29tcG9zZXJDb25maWd1cmF0b3IuY29uZmlndXJlQXN0cm9Db21wb3Nlcihcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcyxcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyxcblx0XHRcdFx0XHR0aGlzLnN0YXRlLnByb2plY3REZXRlY3Rpb24ucHJvamVjdFJvb3QsXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLmNvbmZpZ0ZpbGVQYXRoLFxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZGVmYXVsdENvbnRlbnRUeXBlSWQsXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLFxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IEFzdHJvIENvbXBvc2VyIGNvbmZpZy5zaG93TWR4RmlsZXNJbkV4cGxvcmVyID0nLCBhc3Ryb0NvbmZpZy5zaG93TWR4RmlsZXNJbkV4cGxvcmVyKTtcblx0XHRcdFx0dGhpcy5zdGF0ZS5hc3Ryb0NvbXBvc2VyQ29uZmlnID0gYXN0cm9Db25maWc7XG5cdFx0XHRcdGF3YWl0IHRoaXMuYXN0cm9Db21wb3NlckNvbmZpZ3VyYXRvci5zYXZlQ29uZmlnKGFzdHJvQ29uZmlnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29uZmlndXJlIFNFT1xuXHRcdFx0Y29uc3Qgc2VvQ29uZmlnID0gdGhpcy5zZW9Db25maWd1cmF0b3IuZ2VuZXJhdGVTRU9Db25maWcoXG5cdFx0XHRcdHRoaXMuc3RhdGUuY29udGVudFR5cGVzLFxuXHRcdFx0XHR0aGlzLnN0YXRlLmZyb250bWF0dGVyUHJvcGVydGllcyxcblx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9qZWN0RGV0ZWN0aW9uLFxuXHRcdFx0XHR0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnRcblx0XHRcdCk7XG5cdFx0XHR0aGlzLnN0YXRlLnNlb0NvbmZpZyA9IHNlb0NvbmZpZztcblx0XHRcdGF3YWl0IHRoaXMuc2VvQ29uZmlndXJhdG9yLnNhdmVDb25maWcoc2VvQ29uZmlnKTtcblxuXHRcdFx0Ly8gQ29uZmlndXJlIFdZU0lXWUcgVG9vbGJhciAodG9nZ2xlIGNvbW1hbmQgZGlyZWN0bHksIG5vdCB2aWEgY29tbWFuZGVyKVxuXHRcdFx0Ly8gQWx3YXlzIGNhbGwgdGhpcyB0byBlbnN1cmUgY01lbnVWaXNpYmlsaXR5IGlzIHNldCBjb3JyZWN0bHksIGV2ZW4gaWYgZGlzYWJsZWRcblx0XHRcdGNvbnNvbGUuZGVidWcoYEZpbmFsaXplU3RlcDogQ29uZmlndXJpbmcgZWRpdGluZyB0b29sYmFyLCBlbmFibGVXWVNJV1lHPSR7dGhpcy5zdGF0ZS5lbmFibGVXWVNJV1lHfWApO1xuXHRcdFx0YXdhaXQgdGhpcy5jb21tYW5kZXJDb25maWd1cmF0b3IudG9nZ2xlRWRpdGluZ1Rvb2xiYXJDb21tYW5kKHRoaXMuYXBwLCB0aGlzLnN0YXRlLmVuYWJsZVdZU0lXWUcpO1xuXG5cdFx0XHQvLyBDb25maWd1cmUgQ29tbWFuZGVyIChubyB0b29sYmFyIGJ1dHRvbilcblx0XHRcdGNvbnN0IGNvbW1hbmRlckNvbmZpZyA9IHRoaXMuY29tbWFuZGVyQ29uZmlndXJhdG9yLmdlbmVyYXRlQ29tbWFuZGVyQ29uZmlnKHRoaXMuc3RhdGUuZW5hYmxlV1lTSVdZRyk7XG5cdFx0XHR0aGlzLnN0YXRlLmNvbW1hbmRlckNvbmZpZyA9IGNvbW1hbmRlckNvbmZpZztcblx0XHRcdGF3YWl0IHRoaXMuY29tbWFuZGVyQ29uZmlndXJhdG9yLnNhdmVDb25maWcoY29tbWFuZGVyQ29uZmlnKTtcblxuXHRcdFx0Ly8gQ29uZmlndXJlIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lXG5cdFx0XHRjb25zdCBmaXJzdFR5cGUgPSB0aGlzLnN0YXRlLmNvbnRlbnRUeXBlcy5maW5kKGN0ID0+IGN0LmVuYWJsZWQpO1xuXHRcdFx0Y29uc3QgZmlyc3RQcm9wcyA9IGZpcnN0VHlwZSA/IHRoaXMuc3RhdGUuZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2ZpcnN0VHlwZS5pZF0gOiB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoZmlyc3RQcm9wcyAmJiBmaXJzdFByb3BzLnRpdGxlUHJvcGVydHkpIHtcblx0XHRcdFx0dGhpcy5zdGF0ZS5wcm9wZXJ0eU92ZXJGaWxlTmFtZS5wcm9wZXJ0eUtleSA9IGZpcnN0UHJvcHMudGl0bGVQcm9wZXJ0eTtcblx0XHRcdH1cblx0XHRcdC8vIFNldCBNRFggc3VwcG9ydCBiYXNlZCBvbiBzdGF0ZSAoQUxXQVlTIHNldCBleHBsaWNpdGx5LCBldmVuIGlmIGZhbHNlKVxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBDb25maWd1cmluZyBQcm9wZXJ0eSBPdmVyIEZpbGUgTmFtZScpO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiB0aGlzLnN0YXRlLmVuYWJsZU1keFN1cHBvcnQgPScsIHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IHRoaXMuc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUgYmVmb3JlID0nLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRlLnByb3BlcnR5T3ZlckZpbGVOYW1lKSk7XG5cdFx0XHRcblx0XHRcdC8vIEVuc3VyZSBlbmFibGVNZHhTdXBwb3J0IGlzIEFMV0FZUyBzZXQgKG5ldmVyIHVuZGVmaW5lZClcblx0XHRcdGNvbnN0IG1keFN1cHBvcnRWYWx1ZSA9IHRoaXMuc3RhdGUuZW5hYmxlTWR4U3VwcG9ydCA9PT0gdHJ1ZTtcblx0XHRcdHRoaXMuc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUuZW5hYmxlTWR4U3VwcG9ydCA9IG1keFN1cHBvcnRWYWx1ZTtcblx0XHRcdFxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBTZXQgZW5hYmxlTWR4U3VwcG9ydCB0bycsIG1keFN1cHBvcnRWYWx1ZSk7XG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IHRoaXMuc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUgYWZ0ZXIgPScsIEpTT04uc3RyaW5naWZ5KHRoaXMuc3RhdGUucHJvcGVydHlPdmVyRmlsZU5hbWUpKTtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQWJvdXQgdG8gY2FsbCBzYXZlQ29uZmlnIHdpdGg6JywgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGF0ZS5wcm9wZXJ0eU92ZXJGaWxlTmFtZSkpO1xuXHRcdFx0XG5cdFx0XHRhd2FpdCB0aGlzLnByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlndXJhdG9yLnNhdmVDb25maWcodGhpcy5zdGF0ZS5wcm9wZXJ0eU92ZXJGaWxlTmFtZSk7XG5cblx0XHRcdC8vIENvbmZpZ3VyZSBVSSBUd2Vha2VyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IENvbmZpZ3VyaW5nIFVJIFR3ZWFrZXInKTtcblx0XHRcdGF3YWl0IHRoaXMudWlUd2Vha2VyQ29uZmlndXJhdG9yLnNhdmVDb25maWcodGhpcy5zdGF0ZS5lbmFibGVNZHhTdXBwb3J0ID09PSB0cnVlKTtcblxuXHRcdFx0Ly8gQ29uZmlndXJlIFNpbXBsZSBCYW5uZXIgKGlmIGVuYWJsZWQpXG5cdFx0XHRjb25zdCBpbWFnZVByb3BlcnR5ID0gZmlyc3RQcm9wcz8uaW1hZ2VQcm9wZXJ0eTtcblx0XHRcdGlmIChpbWFnZVByb3BlcnR5ICYmIHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMoJ3NpbXBsZS1iYW5uZXInKSkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLnNpbXBsZUJhbm5lckNvbmZpZ3VyYXRvci5zYXZlQ29uZmlnKGltYWdlUHJvcGVydHkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb25maWd1cmUgSW1hZ2UgSW5zZXJ0ZXIgKGlmIGVuYWJsZWQpIC0gdXNlIGdsb2JhbCBhdHRhY2htZW50IGhhbmRsaW5nIG1vZGVcblx0XHRcdGlmIChpbWFnZVByb3BlcnR5ICYmIHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMoJ2luc2VydC11bnNwbGFzaC1pbWFnZScpKSB7XG5cdFx0XHRcdC8vIERldGVybWluZSBmb3JtYXQgYmFzZWQgb24gZ2xvYmFsIGF0dGFjaG1lbnQgaGFuZGxpbmcgbW9kZVxuXHRcdFx0XHRsZXQgaW1hZ2VJbnNlcnRlckNvbmZpZyA9IHsgLi4udGhpcy5zdGF0ZS5pbWFnZUluc2VydGVyIH07XG5cdFx0XHRcdC8vIElmIHNhbWUtZm9sZGVyLCB1c2Ugc2ltcGxlIGZvcm1hdDsgb3RoZXJ3aXNlIHVzZSBhdHRhY2htZW50cyBmb2xkZXIgZm9ybWF0XG5cdFx0XHRcdGlmICh0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzYW1lLWZvbGRlcicpIHtcblx0XHRcdFx0XHRpbWFnZUluc2VydGVyQ29uZmlnLnZhbHVlRm9ybWF0ID0gJ1tbe2ltYWdlLXVybH1dXSc7XG5cdFx0XHRcdFx0aW1hZ2VJbnNlcnRlckNvbmZpZy5pbnNlcnRGb3JtYXQgPSAnW1t7aW1hZ2UtdXJsfV1dJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBGb3Igc3ViZm9sZGVyIG9yIHNwZWNpZmllZC1mb2xkZXIsIHVzZSBhdHRhY2htZW50cyBmb2xkZXJcblx0XHRcdFx0XHRjb25zdCBmb2xkZXJOYW1lID0gdGhpcy5zdGF0ZS5hdHRhY2htZW50Rm9sZGVyTmFtZSB8fCAnYXR0YWNobWVudHMnO1xuXHRcdFx0XHRcdGltYWdlSW5zZXJ0ZXJDb25maWcudmFsdWVGb3JtYXQgPSBgW1ske2ZvbGRlck5hbWV9L3tpbWFnZS11cmx9XV1gO1xuXHRcdFx0XHRcdGltYWdlSW5zZXJ0ZXJDb25maWcuaW5zZXJ0Rm9ybWF0ID0gYFtbJHtmb2xkZXJOYW1lfS97aW1hZ2UtdXJsfV1dYDtcblx0XHRcdFx0fVxuXHRcdFx0XHRhd2FpdCB0aGlzLmltYWdlSW5zZXJ0ZXJDb25maWd1cmF0b3Iuc2F2ZUNvbmZpZyhpbWFnZUluc2VydGVyQ29uZmlnLCBpbWFnZVByb3BlcnR5KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29uZmlndXJlIEltYWdlIE1hbmFnZXIgKGlmIGVuYWJsZWQpXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5lbmFibGVkUGx1Z2lucy5pbmNsdWRlcygnaW1hZ2UtbWFuYWdlcicpKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuaW1hZ2VNYW5hZ2VyQ29uZmlndXJhdG9yLnNhdmVDb25maWcodGhpcy5zdGF0ZS5pbWFnZU1hbmFnZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb25maWd1cmUgSG9tZSBCYXNlIChpZiBlbmFibGVkKVxuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMoJ2hvbWUtYmFzZScpKSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuaG9tZUJhc2VDb25maWd1cmF0b3Iuc2F2ZUNvbmZpZyh0aGlzLnN0YXRlLmhvbWVCYXNlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29uZmlndXJlIEV4cGxvcmVyIEZvY3VzIChpZiBlbmFibGVkKVxuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZW5hYmxlZFBsdWdpbnMuaW5jbHVkZXMoJ2V4cGxvcmVyLWZvY3VzJykpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5leHBsb3JlckZvY3VzQ29uZmlndXJhdG9yLnNhdmVDb25maWcodGhpcy5zdGF0ZS5leHBsb3JlckZvY3VzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29uZmlndXJlIGRlZmF1bHQgY29udGVudCB0eXBlIGFuZCBPYnNpZGlhbiBzZXR0aW5ncyAoZm9sbG93aW5nIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgcGF0dGVybilcblx0XHRcdGlmICh0aGlzLnN0YXRlLmRlZmF1bHRDb250ZW50VHlwZUlkKSB7XG5cdFx0XHRcdGNvbnN0IGRlZmF1bHRUeXBlID0gdGhpcy5zdGF0ZS5jb250ZW50VHlwZXMuZmluZChjdCA9PiBjdC5pZCA9PT0gdGhpcy5zdGF0ZS5kZWZhdWx0Q29udGVudFR5cGVJZCk7XG5cdFx0XHRcdGlmIChkZWZhdWx0VHlwZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQ29uZmlndXJpbmcgT2JzaWRpYW4gc2V0dGluZ3MgZm9yIGRlZmF1bHQgY29udGVudCB0eXBlOicsIGRlZmF1bHRUeXBlLm5hbWUpO1xuXHRcdFx0XHRcdGNvbnN0IGFwcCA9IHRoaXMuYXBwIGFzIHsgc2V0dGluZz86IHsgc2V0PzogKGtleTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gUHJvbWlzZTx2b2lkPjsgc2F2ZT86ICgpID0+IFByb21pc2U8dm9pZD4gfSB9O1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIFNldCBhdHRhY2htZW50cyBmb2xkZXIgYmFzZWQgb24gZ2xvYmFsIGF0dGFjaG1lbnQgaGFuZGxpbmcgbW9kZVxuXHRcdFx0XHRcdGxldCB0YXJnZXRQYXRoID0gJy4vJztcblx0XHRcdFx0XHRpZiAodGhpcy5zdGF0ZS5hdHRhY2htZW50SGFuZGxpbmdNb2RlID09PSAnc2FtZS1mb2xkZXInKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRQYXRoID0gJy4vJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuc3RhdGUuYXR0YWNobWVudEhhbmRsaW5nTW9kZSA9PT0gJ3N1YmZvbGRlcicpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGZvbGRlck5hbWUgPSB0aGlzLnN0YXRlLmF0dGFjaG1lbnRGb2xkZXJOYW1lIHx8ICdhdHRhY2htZW50cyc7XG5cdFx0XHRcdFx0XHR0YXJnZXRQYXRoID0gYC4vJHtmb2xkZXJOYW1lfWA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnN0YXRlLmF0dGFjaG1lbnRIYW5kbGluZ01vZGUgPT09ICdzcGVjaWZpZWQtZm9sZGVyJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IHRoaXMuc3RhdGUuYXR0YWNobWVudEZvbGRlck5hbWUgfHwgJ2F0dGFjaG1lbnRzJztcblx0XHRcdFx0XHRcdHRhcmdldFBhdGggPSBmb2xkZXJOYW1lO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBNZXRob2QgMTogVHJ5IHRvIHVzZSB0aGUgYXBwJ3Mgc2V0dGluZ3MgbWFuYWdlciBpZiBhdmFpbGFibGUgKGZvbGxvd2luZyBhc3Ryby1tb2R1bGFyLXNldHRpbmdzIHBhdHRlcm4pXG5cdFx0XHRcdFx0aWYgKGFwcC5zZXR0aW5nICYmIHR5cGVvZiBhcHAuc2V0dGluZy5zZXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogVXNpbmcgYXBwLnNldHRpbmcgQVBJJyk7XG5cdFx0XHRcdFx0XHRhd2FpdCBhcHAuc2V0dGluZy5zZXQoJ25ld0ZpbGVMb2NhdGlvbicsICdmb2xkZXInKTtcblx0XHRcdFx0XHRcdGF3YWl0IGFwcC5zZXR0aW5nLnNldCgnbmV3RmlsZUZvbGRlclBhdGgnLCBkZWZhdWx0VHlwZS5mb2xkZXIpO1xuXHRcdFx0XHRcdFx0YXdhaXQgYXBwLnNldHRpbmcuc2V0KCdhdHRhY2htZW50Rm9sZGVyUGF0aCcsIHRhcmdldFBhdGgpO1xuXHRcdFx0XHRcdFx0YXdhaXQgYXBwLnNldHRpbmcuc2V0KCduZXdMaW5rRm9ybWF0JywgJ3JlbGF0aXZlJyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIFNhdmUgdGhlIHNldHRpbmdzXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGFwcC5zZXR0aW5nLnNhdmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgYXBwLnNldHRpbmcuc2F2ZSgpO1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IE9ic2lkaWFuIHNldHRpbmdzIHNhdmVkIHZpYSBhcHAuc2V0dGluZy5zYXZlKCknKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTWV0aG9kIDI6IEZhbGxiYWNrIHRvIHZhdWx0IGNvbmZpZyAoZm9sbG93aW5nIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgcGF0dGVybilcblx0XHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogVXNpbmcgdmF1bHQuY29uZmlnIEFQSScpO1xuXHRcdFx0XHRcdFx0Y29uc3QgdmF1bHQgPSB0aGlzLmFwcC52YXVsdCBhcyB7IGNvbmZpZz86IHsgbmV3RmlsZUxvY2F0aW9uPzogc3RyaW5nOyBuZXdGaWxlRm9sZGVyUGF0aD86IHN0cmluZzsgYXR0YWNobWVudEZvbGRlclBhdGg/OiBzdHJpbmc7IG5ld0xpbmtGb3JtYXQ/OiBzdHJpbmcgfTsgc2F2ZUNvbmZpZz86ICgpID0+IFByb21pc2U8dm9pZD4gfTtcblx0XHRcdFx0XHRcdGNvbnN0IG9ic2lkaWFuU2V0dGluZ3MgPSB2YXVsdC5jb25maWc7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGlmICghb2JzaWRpYW5TZXR0aW5ncykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdGaW5hbGl6ZVN0ZXA6IHZhdWx0LmNvbmZpZyBpcyBub3QgYXZhaWxhYmxlJyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRvYnNpZGlhblNldHRpbmdzLm5ld0ZpbGVMb2NhdGlvbiA9ICdmb2xkZXInO1xuXHRcdFx0XHRcdFx0XHRvYnNpZGlhblNldHRpbmdzLm5ld0ZpbGVGb2xkZXJQYXRoID0gZGVmYXVsdFR5cGUuZm9sZGVyO1xuXHRcdFx0XHRcdFx0XHRvYnNpZGlhblNldHRpbmdzLmF0dGFjaG1lbnRGb2xkZXJQYXRoID0gdGFyZ2V0UGF0aDtcblx0XHRcdFx0XHRcdFx0b2JzaWRpYW5TZXR0aW5ncy5uZXdMaW5rRm9ybWF0ID0gJ3JlbGF0aXZlJztcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdmF1bHQuc2F2ZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHZhdWx0LnNhdmVDb25maWcoKTtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdGaW5hbGl6ZVN0ZXA6IE9ic2lkaWFuIHNldHRpbmdzIHNhdmVkIHZpYSB2YXVsdC5zYXZlQ29uZmlnKCknKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdGaW5hbGl6ZVN0ZXA6IHZhdWx0LnNhdmVDb25maWcoKSBpcyBub3QgYXZhaWxhYmxlJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hcHBsaWVkID0gdHJ1ZTtcblx0XHRcdC8vIENyZWF0ZSBhIG5vdGljZSBiYXNlZCBvbiB3aGV0aGVyIHdlJ3JlIHJlc3RhcnRpbmdcblx0XHRcdGlmIChzaG91bGRSZXN0YXJ0KSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoJ0NvbmZpZ3VyYXRpb24gYXBwbGllZC4gT2JzaWRpYW4gd2lsbCBub3cgcmVzdGFydC4uLicsIDMwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3IE5vdGljZSgnQ29uZmlndXJhdGlvbiBhcHBsaWVkIHN1Y2Nlc3NmdWxseSEgWW91IG1heSBuZWVkIHRvIHJlc3RhcnQgT2JzaWRpYW4gdG8gc2VlIGFsbCBjaGFuZ2VzLicsIDgwMDApO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gYXBwbHkgY29uZmlndXJhdGlvbjonLCBlcnJvcik7XG5cdFx0XHRuZXcgTm90aWNlKCdGYWlsZWQgdG8gYXBwbHkgY29uZmlndXJhdGlvbi4gUGxlYXNlIGNoZWNrIHRoZSBjb25zb2xlIGZvciBkZXRhaWxzLicsIDYwMDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBGaW5kIGFueSBhY3RpdmUgQmFzZXMgdmlld3MgYW5kIHN3aXRjaCB0aGVtIHRvIHRoZSBuZXcgZGVmYXVsdCB2aWV3LlxuXHQgKiBDbG9zZXMgb2xkIHRhYnMgYW5kIHJlb3BlbnMgdGhlbSB0byBmb3JjZSBhIGNsZWFuIHJlbG9hZCBpZiBub3QgcmVzdGFydGluZy5cblx0ICovXG5cdHByaXZhdGUgYXN5bmMgdXBkYXRlQWN0aXZlQmFzZXNWaWV3cyhkZWZhdWx0Vmlld05hbWU6IHN0cmluZywgc2hvdWxkUmVzdGFydDogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGJhc2VGaWxlUGF0aCA9IGF3YWl0IHRoaXMuYmFzZXNDTVNDb25maWd1cmF0b3IucmVzb2x2ZUJhc2VGaWxlUGF0aCgpO1xuXHRcdGxldCB1cGRhdGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0Ly8gRmluZCBhbnkgYWN0aXZlIEJhc2VzIHZpZXdzIGFuZCB1cGRhdGUgdGhlbSBpbnN0ZWFkIG9mIGRldGFjaGluZ1xuXHRcdGludGVyZmFjZSBCYXNlc0xlYWZTdGF0ZSB7XG5cdFx0XHRsZWFmOiBXb3Jrc3BhY2VMZWFmO1xuXHRcdFx0c3RhdGU6IHtcblx0XHRcdFx0dHlwZTogc3RyaW5nO1xuXHRcdFx0XHRhY3RpdmU6IGJvb2xlYW47XG5cdFx0XHRcdHN0YXRlOiB7XG5cdFx0XHRcdFx0ZmlsZTogc3RyaW5nO1xuXHRcdFx0XHRcdHZpZXc/OiBzdHJpbmc7XG5cdFx0XHRcdFx0dmlld05hbWU/OiBzdHJpbmc7XG5cdFx0XHRcdFx0W2tleTogc3RyaW5nXTogdW5rbm93bjtcblx0XHRcdFx0fTtcblx0XHRcdFx0W2tleTogc3RyaW5nXTogdW5rbm93bjtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGNvbnN0IGxlYXZlc1RvVXBkYXRlOiBCYXNlc0xlYWZTdGF0ZVtdID0gW107XG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLml0ZXJhdGVBbGxMZWF2ZXMoKGxlYWYpID0+IHtcblx0XHRcdGNvbnN0IHZpZXdUeXBlID0gbGVhZi52aWV3LmdldFZpZXdUeXBlKCk7XG5cdFx0XHRpZiAodmlld1R5cGUgPT09ICdiYXNlcycgfHwgdmlld1R5cGUgPT09ICdiYXNlcy1jbXMnKSB7XG5cdFx0XHRcdGNvbnN0IHN0YXRlID0gbGVhZi5nZXRWaWV3U3RhdGUoKTtcblx0XHRcdFx0aWYgKHN0YXRlLnN0YXRlPy5maWxlID09PSBiYXNlRmlsZVBhdGgpIHtcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBGaW5hbGl6ZVN0ZXA6IEZvdW5kIEJhc2VzIGxlYWYgdG8gdXBkYXRlICh0eXBlOiAke3ZpZXdUeXBlfSlgKTtcblx0XHRcdFx0XHRsZWF2ZXNUb1VwZGF0ZS5wdXNoKHsgbGVhZiwgc3RhdGU6IHN0YXRlIGFzIEJhc2VzTGVhZlN0YXRlWydzdGF0ZSddIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBVcGRhdGUgZXhpc3RpbmcgbGVhdmVzXG5cdFx0Zm9yIChjb25zdCB7IGxlYWYsIHN0YXRlIH0gb2YgbGVhdmVzVG9VcGRhdGUpIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogVXBkYXRpbmcgZXhpc3RpbmcgQmFzZXMgbGVhZiBzdGF0ZScpO1xuXHRcdFx0Ly8gVXBkYXRlIGV4aXN0aW5nIGxlYWYgc3RhdGUgdG8gc3dpdGNoIHRvIHRoZSBuZXcgZGVmYXVsdCB2aWV3XG5cdFx0XHQvLyBTZXQgYm90aCAndmlldycgYW5kICd2aWV3TmFtZScgZm9yIGNvbXBhdGliaWxpdHkgYWNyb3NzIEJhc2VzIHZlcnNpb25zXG5cdFx0XHRhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7XG5cdFx0XHRcdC4uLnN0YXRlLFxuXHRcdFx0XHRzdGF0ZToge1xuXHRcdFx0XHRcdC4uLnN0YXRlLnN0YXRlLFxuXHRcdFx0XHRcdHZpZXc6IGRlZmF1bHRWaWV3TmFtZSxcblx0XHRcdFx0XHR2aWV3TmFtZTogZGVmYXVsdFZpZXdOYW1lXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbm8gQmFzZXMgdmlld3Mgd2VyZSBmb3VuZC91cGRhdGVkLCBvcGVuIGEgbmV3IG9uZVxuXHRcdGlmICghdXBkYXRlZCkge1xuXHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBPcGVuaW5nIG5ldyBCYXNlcyBsZWFmIHdpdGggZnJlc2ggc3RhdGUnKTtcblx0XHRcdFxuXHRcdFx0Ly8gVXNlICdiYXNlcy1jbXMnIGFzIHRoZSBwcmVmZXJyZWQgdHlwZSBmb3IgbmV3IGxlYXZlc1xuXHRcdFx0Y29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCd0YWInKTtcblx0XHRcdGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcblx0XHRcdFx0dHlwZTogJ2Jhc2VzLWNtcycsXG5cdFx0XHRcdGFjdGl2ZTogdHJ1ZSxcblx0XHRcdFx0c3RhdGU6IHtcblx0XHRcdFx0XHRmaWxlOiBiYXNlRmlsZVBhdGgsXG5cdFx0XHRcdFx0dmlldzogZGVmYXVsdFZpZXdOYW1lLFxuXHRcdFx0XHRcdHZpZXdOYW1lOiBkZWZhdWx0Vmlld05hbWVcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2Uuc2V0QWN0aXZlTGVhZihsZWFmLCB7IGZvY3VzOiB0cnVlIH0pO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gU1BFQ0lBTCBDQVNFOiBJZiByZXN0YXJ0aW5nLCBhbHNvIHRyeSB0byBtb2RpZnkgd29ya3NwYWNlLmpzb24gZGlyZWN0bHlcblx0XHQvLyBUaGlzIGlzIGEgXCJiZWx0IGFuZCBzdXNwZW5kZXJzXCIgYXBwcm9hY2ggYmVjYXVzZSBPYnNpZGlhbiBtaWdodCBvdmVyd3JpdGVcblx0XHQvLyB0aGUgaW4tbWVtb3J5IGNoYW5nZXMgd2hlbiBpdCBjbG9zZXMgaWYgdGhlIHZpZXcgaGFzbid0IGZ1bGx5IHN5bmNlZCB5ZXQuXG5cdFx0aWYgKHNob3VsZFJlc3RhcnQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdFx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XG5cdFx0XHRcdGNvbnN0IHdvcmtzcGFjZVBhdGggPSBgJHtjb25maWdEaXJ9L3dvcmtzcGFjZS5qc29uYDtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhd2FpdCBhZGFwdGVyLmV4aXN0cyh3b3Jrc3BhY2VQYXRoKSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ZpbmFsaXplU3RlcDogQXR0ZW1wdGluZyBkaXJlY3Qgd29ya3NwYWNlLmpzb24gbW9kaWZpY2F0aW9uJyk7XG5cdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IGFkYXB0ZXIucmVhZCh3b3Jrc3BhY2VQYXRoKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRpbnRlcmZhY2UgV29ya3NwYWNlTm9kZSB7XG5cdFx0XHRcdFx0XHR0eXBlPzogc3RyaW5nO1xuXHRcdFx0XHRcdFx0c3RhdGU/OiB7XG5cdFx0XHRcdFx0XHRcdHR5cGU/OiBzdHJpbmc7XG5cdFx0XHRcdFx0XHRcdHN0YXRlPzoge1xuXHRcdFx0XHRcdFx0XHRcdGZpbGU/OiBzdHJpbmc7XG5cdFx0XHRcdFx0XHRcdFx0dmlldz86IHN0cmluZztcblx0XHRcdFx0XHRcdFx0XHR2aWV3TmFtZT86IHN0cmluZztcblx0XHRcdFx0XHRcdFx0XHRba2V5OiBzdHJpbmddOiB1bmtub3duO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNoaWxkcmVuPzogV29ya3NwYWNlTm9kZVtdIHwgV29ya3NwYWNlTm9kZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnRlcmZhY2UgV29ya3NwYWNlRGF0YSB7XG5cdFx0XHRcdFx0XHRtYWluPzogV29ya3NwYWNlTm9kZTtcblx0XHRcdFx0XHRcdGxlZnQ/OiBXb3Jrc3BhY2VOb2RlO1xuXHRcdFx0XHRcdFx0cmlnaHQ/OiBXb3Jrc3BhY2VOb2RlO1xuXHRcdFx0XHRcdFx0W2tleTogc3RyaW5nXTogdW5rbm93bjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCB3b3Jrc3BhY2UgPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIFdvcmtzcGFjZURhdGE7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gUmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGZpbmQgYW5kIHVwZGF0ZSBCYXNlcyBsZWF2ZXMgaW4gd29ya3NwYWNlLmpzb25cblx0XHRcdFx0XHRjb25zdCB1cGRhdGVOb2RlID0gKG5vZGU6IFdvcmtzcGFjZU5vZGUgfCB1bmRlZmluZWQpID0+IHtcblx0XHRcdFx0XHRcdGlmICghbm9kZSkgcmV0dXJuO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAobm9kZS50eXBlID09PSAnbGVhZicgJiYgbm9kZS5zdGF0ZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoKG5vZGUuc3RhdGUudHlwZSA9PT0gJ2Jhc2VzJyB8fCBub2RlLnN0YXRlLnR5cGUgPT09ICdiYXNlcy1jbXMnKSAmJiBcblx0XHRcdFx0XHRcdFx0XHRub2RlLnN0YXRlLnN0YXRlPy5maWxlID09PSBiYXNlRmlsZVBhdGgpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKGBGaW5hbGl6ZVN0ZXA6IEZvdW5kIEJhc2VzIGxlYWYgaW4gd29ya3NwYWNlLmpzb24sIHVwZGF0aW5nIHRvICR7ZGVmYXVsdFZpZXdOYW1lfWApO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChub2RlLnN0YXRlLnN0YXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLnN0YXRlLnN0YXRlLnZpZXcgPSBkZWZhdWx0Vmlld05hbWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLnN0YXRlLnN0YXRlLnZpZXdOYW1lID0gZGVmYXVsdFZpZXdOYW1lO1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAobm9kZS5jaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHVwZGF0ZU5vZGUoY2hpbGQpKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR1cGRhdGVOb2RlKG5vZGUuY2hpbGRyZW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHdvcmtzcGFjZS5tYWluKTtcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHdvcmtzcGFjZS5sZWZ0KTtcblx0XHRcdFx0XHR1cGRhdGVOb2RlKHdvcmtzcGFjZS5yaWdodCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKG1vZGlmaWVkKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCBhZGFwdGVyLndyaXRlKHdvcmtzcGFjZVBhdGgsIEpTT04uc3RyaW5naWZ5KHdvcmtzcGFjZSwgbnVsbCwgMikpO1xuXHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnRmluYWxpemVTdGVwOiBTdWNjZXNzZnVsbHkgbW9kaWZpZWQgd29ya3NwYWNlLmpzb24nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmluYWxpemVTdGVwOiBGYWlsZWQgdG8gbW9kaWZ5IHdvcmtzcGFjZS5qc29uIGRpcmVjdGx5OicsIGVycm9yKTtcblx0XHRcdFx0Ly8gRG9uJ3QgdGhyb3csIHdlIHN0aWxsIGhhdmUgdGhlIGluLW1lbW9yeSB1cGRhdGVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YWxpZGF0ZSgpOiBib29sZWFuIHtcblx0XHQvLyBBbHdheXMgcmV0dXJuIHRydWUgZm9yIGZpbmFsaXplIHN0ZXAgLSB2YWxpZGF0aW9uIGhhcHBlbnMgd2hlbiBBcHBseSBpcyBjbGlja2VkXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRnZXRUaXRsZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiAnRmluYWxpemUnO1xuXHR9XG5cblx0Z2V0RGVzY3JpcHRpb24oKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gJ1JldmlldyBhbmQgYXBwbHkgY29uZmlndXJhdGlvbic7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBDb250ZW50VHlwZUNvbmZpZywgRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzLCBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgeWFtbCBmcm9tICd5YW1sJztcbmltcG9ydCB7IFBhdGhSZXNvbHZlciB9IGZyb20gJy4vUGF0aFJlc29sdmVyJztcblxuZXhwb3J0IGNsYXNzIEJhc2VzQ01TQ29uZmlndXJhdG9yIHtcblx0cHJpdmF0ZSBhcHA6IEFwcDtcblx0cHJpdmF0ZSBwYXRoUmVzb2x2ZXI6IFBhdGhSZXNvbHZlcjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMucGF0aFJlc29sdmVyID0gbmV3IFBhdGhSZXNvbHZlcihhcHApO1xuXHR9XG5cblx0YXN5bmMgcmVzb2x2ZUJhc2VGaWxlUGF0aCgpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRcdGNvbnN0IHByZWZlcnJlZFBhdGggPSAnX2Jhc2VzL0hvbWUuYmFzZSc7XG5cdFx0Y29uc3QgbGVnYWN5UGF0aCA9ICdiYXNlcy9Ib21lLmJhc2UnO1xuXHRcdFxuXHRcdGlmIChhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhwcmVmZXJyZWRQYXRoKSkge1xuXHRcdFx0cmV0dXJuIHByZWZlcnJlZFBhdGg7XG5cdFx0fVxuXHRcdGlmIChhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhsZWdhY3lQYXRoKSkge1xuXHRcdFx0cmV0dXJuIGxlZ2FjeVBhdGg7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIENoZWNrIGlmIGZvbGRlcnMgZXhpc3QgZXZlbiBpZiBmaWxlIGRvZXNuJ3Rcblx0XHRpZiAoYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMoJ19iYXNlcycpKSB7XG5cdFx0XHRyZXR1cm4gcHJlZmVycmVkUGF0aDtcblx0XHR9XG5cdFx0aWYgKGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIuZXhpc3RzKCdiYXNlcycpKSB7XG5cdFx0XHRyZXR1cm4gbGVnYWN5UGF0aDtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHByZWZlcnJlZFBhdGg7XG5cdH1cblxuXHRhc3luYyBjcmVhdGVPclVwZGF0ZUJhc2VGaWxlKFxuXHRcdGNvbnRlbnRUeXBlczogQ29udGVudFR5cGVDb25maWdbXSxcblx0XHRmcm9udG1hdHRlclByb3BlcnRpZXM6IHsgW2NvbnRlbnRUeXBlSWQ6IHN0cmluZ106IEZyb250bWF0dGVyUHJvcGVydGllcyB9LFxuXHRcdGRlZmF1bHRDb250ZW50VHlwZUlkPzogc3RyaW5nLFxuXHRcdHByb2plY3REZXRlY3Rpb24/OiBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0LFxuXHRcdGVuYWJsZU1keFN1cHBvcnQ/OiBib29sZWFuXG5cdCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGJhc2VGaWxlUGF0aCA9IGF3YWl0IHRoaXMucmVzb2x2ZUJhc2VGaWxlUGF0aCgpO1xuXHRcdGNvbnN0IGZvbGRlclBhdGggPSBiYXNlRmlsZVBhdGguc3BsaXQoJy8nKVswXTtcblx0XHRcblx0XHQvLyBFbnN1cmUgYmFzZXMgZGlyZWN0b3J5IGV4aXN0c1xuXHRcdGNvbnN0IGJhc2VzRm9sZGVyID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlclBhdGgpO1xuXHRcdGlmICghYmFzZXNGb2xkZXIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihmb2xkZXJQYXRoKTtcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRcdC8vIEZvbGRlciBtaWdodCBhbHJlYWR5IGV4aXN0LCBpZ25vcmUgZXJyb3Jcblx0XHRcdFx0Y29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuXHRcdFx0XHRpZiAoIWVycm9yTWVzc2FnZSB8fCAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKGBCYXNlc0NNU0NvbmZpZzogQ291bGQgbm90IGNyZWF0ZSAke2ZvbGRlclBhdGh9IGZvbGRlcjpgLCBlcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiBmaWxlIGV4aXN0cyAocmUtY2hlY2sgYWZ0ZXIgZm9sZGVyIGNyZWF0aW9uKVxuXHRcdGNvbnN0IGJhc2VGaWxlQWJzdHJhY3QgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYmFzZUZpbGVQYXRoKTtcblx0XHRsZXQgYmFzZUZpbGU6IFRGaWxlIHwgbnVsbCA9IGJhc2VGaWxlQWJzdHJhY3QgaW5zdGFuY2VvZiBURmlsZSA/IGJhc2VGaWxlQWJzdHJhY3QgOiBudWxsO1xuXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBiYXNlIGZpbGUgaWYgaXQgZXhpc3RzXG5cdFx0bGV0IGV4aXN0aW5nQmFzZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsID0gbnVsbDtcblx0XHRpZiAoYmFzZUZpbGUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGJhc2VGaWxlKTtcblx0XHRcdFx0ZXhpc3RpbmdCYXNlID0geWFtbC5wYXJzZShjb250ZW50KSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Jhc2VzQ01TQ29uZmlnOiBGYWlsZWQgdG8gcGFyc2UgZXhpc3RpbmcgYmFzZSBmaWxlOicsIGVycm9yKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBlbmFibGVkVHlwZXMgPSBjb250ZW50VHlwZXMuZmlsdGVyKGN0ID0+IGN0LmVuYWJsZWQpO1xuXHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBHZW5lcmF0aW5nIGJhc2UgY29udGVudCBmb3InLCBjb250ZW50VHlwZXMubGVuZ3RoLCAnY29udGVudCB0eXBlcycpO1xuXHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBFbmFibGVkIGNvbnRlbnQgdHlwZXM6JywgZW5hYmxlZFR5cGVzLm1hcChjdCA9PiBjdC5uYW1lKSk7XG5cdFx0XG5cdFx0Y29uc3QgYmFzZUNvbnRlbnQgPSB0aGlzLmdlbmVyYXRlQmFzZUNvbnRlbnQoY29udGVudFR5cGVzLCBmcm9udG1hdHRlclByb3BlcnRpZXMsIGRlZmF1bHRDb250ZW50VHlwZUlkLCBleGlzdGluZ0Jhc2UsIHByb2plY3REZXRlY3Rpb24sIGVuYWJsZU1keFN1cHBvcnQpO1xuXHRcdFxuXHRcdC8vIENvdW50IHZpZXdzIGluIGdlbmVyYXRlZCBjb250ZW50IHRvIHZlcmlmeSB0aGV5J3JlIGJlaW5nIGNyZWF0ZWRcblx0XHRjb25zdCB2aWV3TWF0Y2hlcyA9IGJhc2VDb250ZW50Lm1hdGNoKC9eXFxzKi1cXHMrdHlwZTpcXHMrYmFzZXMtY21zL2dtKTtcblx0XHRjb25zdCB2aWV3Q291bnQgPSB2aWV3TWF0Y2hlcyA/IHZpZXdNYXRjaGVzLmxlbmd0aCA6IDA7XG5cdFx0Y29uc29sZS5kZWJ1ZygnQmFzZXNDTVNDb25maWc6IEdlbmVyYXRlZCcsIHZpZXdDb3VudCwgJ3ZpZXdzIGluIGJhc2UgY29udGVudCcpO1xuXHRcdFxuXHRcdC8vIEFsd2F5cyB0cnkgdG8gbW9kaWZ5IGZpcnN0IC0gaWYgZmlsZSBkb2Vzbid0IGV4aXN0LCBtb2RpZnkgd2lsbCB0aHJvdywgdGhlbiB3ZSBjcmVhdGVcblx0XHQvLyBUaGlzIGF2b2lkcyByYWNlIGNvbmRpdGlvbnMgd2l0aCBnZXRBYnN0cmFjdEZpbGVCeVBhdGhcblx0XHRjb25zdCBiYXNlRmlsZUFic3RyYWN0MiA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChiYXNlRmlsZVBhdGgpO1xuXHRcdGJhc2VGaWxlID0gYmFzZUZpbGVBYnN0cmFjdDIgaW5zdGFuY2VvZiBURmlsZSA/IGJhc2VGaWxlQWJzdHJhY3QyIDogbnVsbDtcblx0XHRcblx0XHRpZiAoYmFzZUZpbGUpIHtcblx0XHRcdGNvbnNvbGUuZGVidWcoYEJhc2VzQ01TQ29uZmlnOiBNb2RpZnlpbmcgZXhpc3RpbmcgJHtiYXNlRmlsZVBhdGh9IGZpbGVgKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShiYXNlRmlsZSwgYmFzZUNvbnRlbnQpO1xuXHRcdFx0XHRjb25zb2xlLmRlYnVnKGBCYXNlc0NNU0NvbmZpZzogU3VjY2Vzc2Z1bGx5IG1vZGlmaWVkICR7YmFzZUZpbGVQYXRofSBmaWxlYCk7XG5cdFx0XHRcdHJldHVybjsgLy8gU3VjY2VzcywgZXhpdCBlYXJseVxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignQmFzZXNDTVNDb25maWc6IEZhaWxlZCB0byBtb2RpZnkgZmlsZTonLCBlcnJvcik7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBGaWxlIGRvZXNuJ3QgZXhpc3QgKG9yIGNhbid0IGJlIGZvdW5kKSwgdHJ5IHRvIGNyZWF0ZSBpdFxuXHRcdGNvbnNvbGUuZGVidWcoYEJhc2VzQ01TQ29uZmlnOiBDcmVhdGluZyBuZXcgJHtiYXNlRmlsZVBhdGh9IGZpbGVgKTtcblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKGJhc2VGaWxlUGF0aCwgYmFzZUNvbnRlbnQpO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZyhgQmFzZXNDTVNDb25maWc6IFN1Y2Nlc3NmdWxseSBjcmVhdGVkICR7YmFzZUZpbGVQYXRofSBmaWxlYCk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdC8vIElmIGNyZWF0ZSBmYWlscyBiZWNhdXNlIGZpbGUgZXhpc3RzLCB0aGUgZmlsZSB3YXMgY3JlYXRlZCBiZXR3ZWVuIGNoZWNrIGFuZCBjcmVhdGVcblx0XHRcdC8vIFRyeSB0byBtb2RpZnkgaXQgZGlyZWN0bHkgdXNpbmcgdGhlIHBhdGggc3RyaW5nXG5cdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG5cdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgfHwgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpKSB7XG5cdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0Jhc2VzQ01TQ29uZmlnOiBGaWxlIGV4aXN0ZWQsIGF0dGVtcHRpbmcgZGlyZWN0IG1vZGlmeSB2aWEgcGF0aCcpO1xuXHRcdFx0XHQvLyBVc2UgYWRhcHRlciB0byB3cml0ZSBkaXJlY3RseSAtIHRoaXMgYnlwYXNzZXMgdGhlIGluZGV4aW5nIGlzc3VlXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0XHRcdFx0aWYgKGFkYXB0ZXIgJiYgdHlwZW9mIGFkYXB0ZXIud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdGF3YWl0IGFkYXB0ZXIud3JpdGUoYmFzZUZpbGVQYXRoLCBiYXNlQ29udGVudCk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdCYXNlc0NNU0NvbmZpZzogU3VjY2Vzc2Z1bGx5IHdyb3RlIEhvbWUuYmFzZSBmaWxlIHZpYSBhZGFwdGVyJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrOiByZXRyeSBnZXRBYnN0cmFjdEZpbGVCeVBhdGggd2l0aCBsb25nZXIgZGVsYXlzXG5cdFx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdCYXNlc0NNU0NvbmZpZzogQWRhcHRlciB3cml0ZSBub3QgYXZhaWxhYmxlLCByZXRyeWluZyBnZXRBYnN0cmFjdEZpbGVCeVBhdGgnKTtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJldHJ5RmlsZUFic3RyYWN0ID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGJhc2VGaWxlUGF0aCk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJldHJ5RmlsZSA9IHJldHJ5RmlsZUFic3RyYWN0IGluc3RhbmNlb2YgVEZpbGUgPyByZXRyeUZpbGVBYnN0cmFjdCA6IG51bGw7XG5cdFx0XHRcdFx0XHRcdGlmIChyZXRyeUZpbGUpIHtcblx0XHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkocmV0cnlGaWxlLCBiYXNlQ29udGVudCk7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhgQmFzZXNDTVNDb25maWc6IFN1Y2Nlc3NmdWxseSBtb2RpZmllZCBIb21lLmJhc2UgZmlsZSBvbiByZXRyeSAke2kgKyAxfWApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignQmFzZXNDTVNDb25maWc6IEZpbGUgZXhpc3RzIGJ1dCBjYW5ub3QgYmUgZm91bmQgYWZ0ZXIgYWxsIHJldHJpZXMnKTtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgRmlsZSBleGlzdHMgYnV0IGNhbm5vdCBiZSBhY2Nlc3NlZC4gUGxlYXNlIHRyeSBhZ2FpbiBvciBtYW51YWxseSBlZGl0ICR7YmFzZUZpbGVQYXRofWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAod3JpdGVFcnJvcikge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Jhc2VzQ01TQ29uZmlnOiBGYWlsZWQgdG8gd3JpdGUgZmlsZSB2aWEgYWRhcHRlcjonLCB3cml0ZUVycm9yKTtcblx0XHRcdFx0XHR0aHJvdyB3cml0ZUVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdCYXNlc0NNU0NvbmZpZzogRmFpbGVkIHRvIGNyZWF0ZSBiYXNlIGZpbGU6JywgZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlQmFzZUNvbnRlbnQoXG5cdFx0Y29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdLFxuXHRcdGZyb250bWF0dGVyUHJvcGVydGllczogeyBbY29udGVudFR5cGVJZDogc3RyaW5nXTogRnJvbnRtYXR0ZXJQcm9wZXJ0aWVzIH0sXG5cdFx0ZGVmYXVsdENvbnRlbnRUeXBlSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcblx0XHRleGlzdGluZ0Jhc2U6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgbnVsbCxcblx0XHRwcm9qZWN0RGV0ZWN0aW9uPzogUHJvamVjdERldGVjdGlvblJlc3VsdCxcblx0XHRlbmFibGVNZHhTdXBwb3J0PzogYm9vbGVhblxuXHQpOiBzdHJpbmcge1xuXHRcdC8vIEJhc2VzIHVzZXMgYSBzcGVjaWZpYyBzeW50YXggLSB3ZSBuZWVkIHRvIGdlbmVyYXRlIGl0IG1hbnVhbGx5IHRvIG1hdGNoIHRoZSBmb3JtYXRcblx0XHRjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcblx0XHRcblx0XHQvLyBGaW5kIGRlZmF1bHQgY29udGVudCB0eXBlXG5cdFx0Y29uc3QgZGVmYXVsdENvbnRlbnRUeXBlID0gZGVmYXVsdENvbnRlbnRUeXBlSWQgPyBcblx0XHRcdGNvbnRlbnRUeXBlcy5maW5kKGN0ID0+IGN0LmlkID09PSBkZWZhdWx0Q29udGVudFR5cGVJZCAmJiBjdC5lbmFibGVkKSA6IG51bGw7XG5cblx0XHQvLyBBZGQgZGVmYXVsdFZpZXcgcHJvcGVydHkgYXQgdGhlIHRvcCBsZXZlbCBpZiBhIGRlZmF1bHQgY29udGVudCB0eXBlIGlzIHNlbGVjdGVkXG5cdFx0aWYgKGRlZmF1bHRDb250ZW50VHlwZSkge1xuXHRcdFx0bGluZXMucHVzaChgZGVmYXVsdFZpZXc6IFwiJHtkZWZhdWx0Q29udGVudFR5cGUubmFtZX1cImApO1xuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIGZvcm11bGFzIGlmIHRoZXkgZXhpc3Rcblx0XHRpZiAoZXhpc3RpbmdCYXNlPy5mb3JtdWxhcykge1xuXHRcdFx0bGluZXMucHVzaCgnZm9ybXVsYXM6Jyk7XG5cdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhleGlzdGluZ0Jhc2UuZm9ybXVsYXMpKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAke2tleX06IHwtYCk7XG5cdFx0XHRcdFx0Y29uc3QgZm9ybXVsYUxpbmVzID0gdmFsdWUuc3BsaXQoJ1xcbicpO1xuXHRcdFx0XHRcdGZvciAoY29uc3QgZm9ybXVsYUxpbmUgb2YgZm9ybXVsYUxpbmVzKSB7XG5cdFx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgJHtmb3JtdWxhTGluZX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpbmVzLnB1c2goJycpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBGaWx0ZXJzIHNlY3Rpb25cblx0XHRsaW5lcy5wdXNoKCdmaWx0ZXJzOicpO1xuXHRcdGlmIChlbmFibGVNZHhTdXBwb3J0KSB7XG5cdFx0XHRsaW5lcy5wdXNoKCcgIG9yOicpO1xuXHRcdFx0bGluZXMucHVzaCgnICAgIC0gZmlsZS5leHQgPT0gXCJtZFwiJyk7XG5cdFx0XHRsaW5lcy5wdXNoKCcgICAgLSBmaWxlLmV4dCA9PSBcIm1keFwiJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmVzLnB1c2goJyAgYW5kOicpO1xuXHRcdFx0bGluZXMucHVzaCgnICAgIC0gZmlsZS5leHQgPT0gXCJtZFwiJyk7XG5cdFx0fVxuXHRcdGxpbmVzLnB1c2goJycpO1xuXG5cdFx0Ly8gUHJvcGVydGllcyBzZWN0aW9uIC0gY29sbGVjdCBhbGwgcHJvcGVydGllcyBmcm9tIGNvbnRlbnQgdHlwZXNcblx0XHRjb25zdCBhbGxQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBjb250ZW50VHlwZXMpIHtcblx0XHRcdGNvbnN0IHByb3BzID0gZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzW2NvbnRlbnRUeXBlLmlkXTtcblx0XHRcdGlmIChwcm9wcykge1xuXHRcdFx0XHRhbGxQcm9wZXJ0aWVzLmFkZChgbm90ZS4ke3Byb3BzLnRpdGxlUHJvcGVydHl9YCk7XG5cdFx0XHRcdGFsbFByb3BlcnRpZXMuYWRkKGBub3RlLiR7cHJvcHMuZGF0ZVByb3BlcnR5fWApO1xuXHRcdFx0XHRpZiAocHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSkge1xuXHRcdFx0XHRcdGFsbFByb3BlcnRpZXMuYWRkKGBub3RlLiR7cHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvcHMudGFnc1Byb3BlcnR5KSB7XG5cdFx0XHRcdFx0YWxsUHJvcGVydGllcy5hZGQoYG5vdGUuJHtwcm9wcy50YWdzUHJvcGVydHl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdFx0XHRhbGxQcm9wZXJ0aWVzLmFkZChgbm90ZS4ke3Byb3BzLmRyYWZ0UHJvcGVydHl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3BzLmltYWdlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRhbGxQcm9wZXJ0aWVzLmFkZChgbm90ZS4ke3Byb3BzLmltYWdlUHJvcGVydHl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgY29tbW9uIHByb3BlcnRpZXNcblx0XHRhbGxQcm9wZXJ0aWVzLmFkZCgnbm90ZS50aXRsZScpO1xuXHRcdGFsbFByb3BlcnRpZXMuYWRkKCdub3RlLmRhdGUnKTtcblx0XHRhbGxQcm9wZXJ0aWVzLmFkZCgnbm90ZS5wdWJEYXRlJyk7XG5cdFx0YWxsUHJvcGVydGllcy5hZGQoJ25vdGUuZHJhZnQnKTtcblx0XHRhbGxQcm9wZXJ0aWVzLmFkZCgnZmlsZS5mdWxsbmFtZScpOyAvLyBBbHdheXMgaW5jbHVkZSBmdWxsIGZpbGUgbmFtZVxuXHRcdGFsbFByb3BlcnRpZXMuYWRkKCdmaWxlLm5hbWUnKTsgLy8gQWxzbyBpbmNsdWRlIGZpbGUgbmFtZSBmb3IgY29tcGF0aWJpbGl0eVxuXG5cdFx0Ly8gUHJlc2VydmUgZm9ybXVsYSBwcm9wZXJ0aWVzIGlmIHRoZXkgZXhpc3Rcblx0XHRpZiAoZXhpc3RpbmdCYXNlPy5wcm9wZXJ0aWVzKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoZXhpc3RpbmdCYXNlLnByb3BlcnRpZXMpKSB7XG5cdFx0XHRcdGlmIChwcm9wLnN0YXJ0c1dpdGgoJ2Zvcm11bGEuJykpIHtcblx0XHRcdFx0XHRhbGxQcm9wZXJ0aWVzLmFkZChwcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChhbGxQcm9wZXJ0aWVzLnNpemUgPiAwKSB7XG5cdFx0XHRsaW5lcy5wdXNoKCdwcm9wZXJ0aWVzOicpO1xuXHRcdFx0Ly8gUHJlc2VydmUgZXhpc3RpbmcgcHJvcGVydHkgZGlzcGxheU5hbWVzLCBlc3BlY2lhbGx5IGZvciBmaWxlLm5hbWUvZnVsbG5hbWVcblx0XHRcdGNvbnN0IGV4aXN0aW5nUHJvcHMgPSAoZXhpc3RpbmdCYXNlPy5wcm9wZXJ0aWVzIGFzIFJlY29yZDxzdHJpbmcsIHsgZGlzcGxheU5hbWU/OiBzdHJpbmcgfSB8IHVuZGVmaW5lZD4pIHx8IHt9O1xuXHRcdFx0Zm9yIChjb25zdCBwcm9wIG9mIEFycmF5LmZyb20oYWxsUHJvcGVydGllcykuc29ydCgpKSB7XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgJHtwcm9wfTpgKTtcblx0XHRcdFx0Ly8gUHJlc2VydmUgZXhpc3RpbmcgZGlzcGxheU5hbWUgaWYgaXQgZXhpc3RzLCBlc3BlY2lhbGx5IGZvciBmaWxlLm5hbWUvZnVsbG5hbWVcblx0XHRcdFx0Y29uc3QgZXhpc3RpbmdQcm9wID0gZXhpc3RpbmdQcm9wc1twcm9wXTtcblx0XHRcdFx0aWYgKGV4aXN0aW5nUHJvcD8uZGlzcGxheU5hbWUpIHtcblx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgZGlzcGxheU5hbWU6ICR7ZXhpc3RpbmdQcm9wLmRpc3BsYXlOYW1lfWApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByb3AgPT09ICdmaWxlLmZ1bGxuYW1lJykge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkaXNwbGF5TmFtZTogRnVsbCBGaWxlIE5hbWVgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBwcm9wTmFtZSA9IHByb3AucmVwbGFjZSgnbm90ZS4nLCAnJykucmVwbGFjZSgnZmlsZS4nLCAnJyk7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAgIGRpc3BsYXlOYW1lOiAke3RoaXMuY2FwaXRhbGl6ZUZpcnN0KHByb3BOYW1lKX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGluZXMucHVzaCgnJyk7XG5cdFx0fVxuXG5cdFx0Ly8gVmlld3Mgc2VjdGlvbiAtIHByZXNlcnZlIGV4aXN0aW5nIHZpZXdzIChleGNlcHQgXCJBbGwgQ29udGVudFwiKSBhbmQgYWRkIG5ldyBjb250ZW50IHR5cGUgdmlld3Ncblx0XHRsaW5lcy5wdXNoKCd2aWV3czonKTtcblx0XHRcblx0XHQvLyBTZXBhcmF0ZSBleGlzdGluZyB2aWV3czogY29udGVudCB0eXBlIHZpZXdzLCBcIkFsbCBDb250ZW50XCIsIFwiR3VpZGVcIiwgYW5kIG90aGVyc1xuXHRcdGNvbnN0IGV4aXN0aW5nVmlld3MgPSAoZXhpc3RpbmdCYXNlPy52aWV3cyBhcyBBcnJheTx7IG5hbWU/OiBzdHJpbmcgfT4pIHx8IFtdO1xuXHRcdGNvbnN0IGV4aXN0aW5nQ29udGVudFR5cGVOYW1lcyA9IG5ldyBTZXQoY29udGVudFR5cGVzLmZpbHRlcihjdCA9PiBjdC5lbmFibGVkKS5tYXAoY3QgPT4gY3QubmFtZSkpO1xuXHRcdGNvbnN0IGd1aWRlVmlldyA9IGV4aXN0aW5nVmlld3MuZmluZCgodikgPT4gdi5uYW1lID09PSAnR3VpZGUnKTtcblx0XHRjb25zdCBvdGhlclZpZXdzID0gZXhpc3RpbmdWaWV3cy5maWx0ZXIoKHYpID0+IFxuXHRcdFx0di5uYW1lICE9PSAnQWxsIENvbnRlbnQnICYmIFxuXHRcdFx0di5uYW1lICE9PSAnR3VpZGUnICYmIFxuXHRcdFx0IWV4aXN0aW5nQ29udGVudFR5cGVOYW1lcy5oYXModi5uYW1lIHx8ICcnKVxuXHRcdCk7XG5cdFx0XG5cdFx0Ly8gRklSU1Q6IEFkZCB0aGUgZGVmYXVsdCBjb250ZW50IHR5cGUncyB2aWV3IChpZiBpdCBleGlzdHMgYW5kIGlzIGVuYWJsZWQpXG5cdFx0aWYgKGRlZmF1bHRDb250ZW50VHlwZSkge1xuXHRcdFx0Y29uc3QgZGVmYXVsdFZpZXdQcm9wcyA9IGZyb250bWF0dGVyUHJvcGVydGllc1tkZWZhdWx0Q29udGVudFR5cGUuaWRdO1xuXHRcdFx0aWYgKGRlZmF1bHRWaWV3UHJvcHMpIHtcblx0XHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IHRoaXMucGF0aFJlc29sdmVyLmdldEJhc2VzQ01TRm9sZGVyUGF0aChkZWZhdWx0Q29udGVudFR5cGUuZm9sZGVyLCBwcm9qZWN0RGV0ZWN0aW9uKTtcblx0XHRcdFx0bGluZXMucHVzaCgnICAtIHR5cGU6IGJhc2VzLWNtcycpO1xuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgbmFtZTogXCIke2RlZmF1bHRDb250ZW50VHlwZS5uYW1lfVwiYCk7XG5cdFx0XHRcdGxpbmVzLnB1c2goJyAgICBmaWx0ZXJzOicpO1xuXHRcdFx0XHRsaW5lcy5wdXNoKCcgICAgICBhbmQ6Jyk7XG5cdFx0XHRcdGlmIChmb2xkZXJQYXRoID09PSAnJyB8fCBmb2xkZXJQYXRoID09PSAnLicpIHtcblx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgICAgIC0gZmlsZS5mb2xkZXIgPT0gXCIvXCJgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgICAgIC0gZmlsZS5mb2xkZXIuc3RhcnRzV2l0aChcIiR7Zm9sZGVyUGF0aH1cIilgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgaW1hZ2VGb3JtYXQ6IGNvdmVyYCk7XG5cdFx0XHRcdC8vIEhhbmRsZSBibGFuayB0aXRsZS9kYXRlIHByb3BlcnRpZXNcblx0XHRcdFx0aWYgKGRlZmF1bHRWaWV3UHJvcHMudGl0bGVQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICB0aXRsZVByb3BlcnR5OiBub3RlLiR7ZGVmYXVsdFZpZXdQcm9wcy50aXRsZVByb3BlcnR5fWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICB0aXRsZVByb3BlcnR5OiBmaWxlLmZ1bGxuYW1lYCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRlZmF1bHRWaWV3UHJvcHMuZGF0ZVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAgIGRhdGVQcm9wZXJ0eTogbm90ZS4ke2RlZmF1bHRWaWV3UHJvcHMuZGF0ZVByb3BlcnR5fWApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkYXRlUHJvcGVydHk6IGZpbGUuY3RpbWVgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGVmYXVsdFZpZXdQcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5KSB7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAgIGRlc2NyaXB0aW9uUHJvcGVydHk6IG5vdGUuJHtkZWZhdWx0Vmlld1Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9YCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRlZmF1bHRWaWV3UHJvcHMuaW1hZ2VQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBpbWFnZVByb3BlcnR5OiBub3RlLiR7ZGVmYXVsdFZpZXdQcm9wcy5pbWFnZVByb3BlcnR5fWApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICBzaG93VGFnczogJHtkZWZhdWx0Vmlld1Byb3BzLnRhZ3NQcm9wZXJ0eSA/ICd0cnVlJyA6ICdmYWxzZSd9YCk7XG5cdFx0XHRcdGlmIChkZWZhdWx0Vmlld1Byb3BzLnRhZ3NQcm9wZXJ0eSkge1xuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICB0YWdzUHJvcGVydHk6IG5vdGUuJHtkZWZhdWx0Vmlld1Byb3BzLnRhZ3NQcm9wZXJ0eX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgc2hvd0RhdGU6IHRydWVgKTtcblx0XHRcdFx0bGluZXMucHVzaChgICAgIHNob3dEcmFmdFN0YXR1czogJHtkZWZhdWx0Vmlld1Byb3BzLmhhc0RyYWZ0U3RhdHVzID8gJ3RydWUnIDogJ2ZhbHNlJ31gKTtcblx0XHRcdFx0aWYgKGRlZmF1bHRWaWV3UHJvcHMuaGFzRHJhZnRTdGF0dXMpIHtcblx0XHRcdFx0XHRpZiAoZGVmYXVsdFZpZXdQcm9wcy5kcmFmdFByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgZHJhZnRTdGF0dXNQcm9wZXJ0eTogbm90ZS4ke2RlZmF1bHRWaWV3UHJvcHMuZHJhZnRQcm9wZXJ0eX1gKTtcblx0XHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkcmFmdFN0YXR1c1JldmVyc2U6ICR7ZGVmYXVsdFZpZXdQcm9wcy5kcmFmdExvZ2ljID09PSAnZmFsc2UtZHJhZnQnID8gJ3RydWUnIDogJ2ZhbHNlJ31gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTm8gZHJhZnQgcHJvcGVydHkgbWVhbnMgdW5kZXJzY29yZSBwcmVmaXhcblx0XHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkcmFmdFN0YXR1c1VzZUZpbGVuYW1lUHJlZml4OiB0cnVlYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICBjdXN0b21pemVOZXdCdXR0b246IHRydWVgKTtcblx0XHRcdFx0bGluZXMucHVzaChgICAgIG5ld05vdGVMb2NhdGlvbjogXCIke2ZvbGRlclBhdGh9XCJgKTtcblx0XHRcdFx0bGluZXMucHVzaChgICAgIGZhbGxiYWNrVG9FbWJlZHM6IGlmLWVtcHR5YCk7XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICBwcm9wZXJ0eURpc3BsYXkxOiBmaWxlLmZ1bGxuYW1lYCk7XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICBzaG93VGV4dFByZXZpZXc6IHRydWVgKTtcblx0XHRcdFx0bGluZXMucHVzaChgICAgIHByb3BlcnR5TGFiZWxzOiBhYm92ZWApO1xuXHRcdFx0XHQvLyBTb3J0IGJ5IGRhdGUgcHJvcGVydHkgKG5ld2VzdCB0byBvbGRlc3QpXG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICBzb3J0OmApO1xuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgICAtIHByb3BlcnR5OiAke2RlZmF1bHRWaWV3UHJvcHMuZGF0ZVByb3BlcnR5ID8gYG5vdGUuJHtkZWZhdWx0Vmlld1Byb3BzLmRhdGVQcm9wZXJ0eX1gIDogJ2ZpbGUuY3RpbWUnfWApO1xuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgICAgIGRpcmVjdGlvbjogREVTQ2ApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBTRUNPTkQ6IEFkZCB2aWV3cyBmb3IgZWFjaCBlbmFibGVkIGNvbnRlbnQgdHlwZSAoZXhjbHVkaW5nIGRlZmF1bHQsIHdoaWNoIGlzIGFscmVhZHkgZmlyc3QpXG5cdFx0Zm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBjb250ZW50VHlwZXMpIHtcblx0XHRcdGlmICghY29udGVudFR5cGUuZW5hYmxlZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2tpcCBcIkFsbCBDb250ZW50XCIgdmlldyAtIGRvbid0IHByb2Nlc3MgaXRcblx0XHRcdGlmIChjb250ZW50VHlwZS5uYW1lID09PSAnQWxsIENvbnRlbnQnKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTa2lwIGRlZmF1bHQgY29udGVudCB0eXBlIC0gaXQncyBhbHJlYWR5IGNyZWF0ZWQgZmlyc3Rcblx0XHRcdGlmIChkZWZhdWx0Q29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaWQgPT09IGRlZmF1bHRDb250ZW50VHlwZS5pZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcHJvcHMgPSBmcm9udG1hdHRlclByb3BlcnRpZXNbY29udGVudFR5cGUuaWRdO1xuXHRcdFx0aWYgKCFwcm9wcykge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZm9sZGVyUGF0aCA9IHRoaXMucGF0aFJlc29sdmVyLmdldEJhc2VzQ01TRm9sZGVyUGF0aChjb250ZW50VHlwZS5mb2xkZXIsIHByb2plY3REZXRlY3Rpb24pO1xuXHRcdFx0bGluZXMucHVzaCgnICAtIHR5cGU6IGJhc2VzLWNtcycpO1xuXHRcdFx0bGluZXMucHVzaChgICAgIG5hbWU6IFwiJHtjb250ZW50VHlwZS5uYW1lfVwiYCk7XG5cdFx0XHRsaW5lcy5wdXNoKCcgICAgZmlsdGVyczonKTtcblx0XHRcdGxpbmVzLnB1c2goJyAgICAgIGFuZDonKTtcblx0XHRcdGlmIChmb2xkZXJQYXRoID09PSAnJyB8fCBmb2xkZXJQYXRoID09PSAnLicpIHtcblx0XHRcdFx0bGluZXMucHVzaChgICAgICAgICAtIGZpbGUuZm9sZGVyID09IFwiL1wiYCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgICAgIC0gZmlsZS5mb2xkZXIuc3RhcnRzV2l0aChcIiR7Zm9sZGVyUGF0aH1cIilgKTtcblx0XHRcdH1cblx0XHRcdGxpbmVzLnB1c2goYCAgICBpbWFnZUZvcm1hdDogY292ZXJgKTtcblx0XHRcdC8vIEhhbmRsZSBibGFuayB0aXRsZS9kYXRlIHByb3BlcnRpZXNcblx0XHRcdGlmIChwcm9wcy50aXRsZVByb3BlcnR5KSB7XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICB0aXRsZVByb3BlcnR5OiBub3RlLiR7cHJvcHMudGl0bGVQcm9wZXJ0eX1gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICB0aXRsZVByb3BlcnR5OiBmaWxlLmZ1bGxuYW1lYCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvcHMuZGF0ZVByb3BlcnR5KSB7XG5cdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkYXRlUHJvcGVydHk6IG5vdGUuJHtwcm9wcy5kYXRlUHJvcGVydHl9YCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgZGF0ZVByb3BlcnR5OiBmaWxlLmN0aW1lYCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvcHMuZGVzY3JpcHRpb25Qcm9wZXJ0eSkge1xuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgZGVzY3JpcHRpb25Qcm9wZXJ0eTogbm90ZS4ke3Byb3BzLmRlc2NyaXB0aW9uUHJvcGVydHl9YCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvcHMuaW1hZ2VQcm9wZXJ0eSkge1xuXHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgaW1hZ2VQcm9wZXJ0eTogbm90ZS4ke3Byb3BzLmltYWdlUHJvcGVydHl9YCk7XG5cdFx0XHR9XG5cdFx0XHRsaW5lcy5wdXNoKGAgICAgc2hvd1RhZ3M6ICR7cHJvcHMudGFnc1Byb3BlcnR5ID8gJ3RydWUnIDogJ2ZhbHNlJ31gKTtcblx0XHRcdGlmIChwcm9wcy50YWdzUHJvcGVydHkpIHtcblx0XHRcdFx0bGluZXMucHVzaChgICAgIHRhZ3NQcm9wZXJ0eTogbm90ZS4ke3Byb3BzLnRhZ3NQcm9wZXJ0eX1gKTtcblx0XHRcdH1cblx0XHRcdGxpbmVzLnB1c2goYCAgICBzaG93RGF0ZTogdHJ1ZWApO1xuXHRcdFx0bGluZXMucHVzaChgICAgIHNob3dEcmFmdFN0YXR1czogJHtwcm9wcy5oYXNEcmFmdFN0YXR1cyA/ICd0cnVlJyA6ICdmYWxzZSd9YCk7XG5cdFx0XHRpZiAocHJvcHMuaGFzRHJhZnRTdGF0dXMpIHtcblx0XHRcdFx0aWYgKHByb3BzLmRyYWZ0UHJvcGVydHkpIHtcblx0XHRcdFx0XHRsaW5lcy5wdXNoKGAgICAgZHJhZnRTdGF0dXNQcm9wZXJ0eTogbm90ZS4ke3Byb3BzLmRyYWZ0UHJvcGVydHl9YCk7XG5cdFx0XHRcdFx0bGluZXMucHVzaChgICAgIGRyYWZ0U3RhdHVzUmV2ZXJzZTogJHtwcm9wcy5kcmFmdExvZ2ljID09PSAnZmFsc2UtZHJhZnQnID8gJ3RydWUnIDogJ2ZhbHNlJ31gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBObyBkcmFmdCBwcm9wZXJ0eSBtZWFucyB1bmRlcnNjb3JlIHByZWZpeFxuXHRcdFx0XHRcdGxpbmVzLnB1c2goYCAgICBkcmFmdFN0YXR1c1VzZUZpbGVuYW1lUHJlZml4OiB0cnVlYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxpbmVzLnB1c2goYCAgICBjdXN0b21pemVOZXdCdXR0b246IHRydWVgKTtcblx0XHRcdGxpbmVzLnB1c2goYCAgICBuZXdOb3RlTG9jYXRpb246IFwiJHtmb2xkZXJQYXRofVwiYCk7XG5cdFx0XHRsaW5lcy5wdXNoKGAgICAgZmFsbGJhY2tUb0VtYmVkczogaWYtZW1wdHlgKTtcblx0XHRcdGxpbmVzLnB1c2goYCAgICBwcm9wZXJ0eURpc3BsYXkxOiBmaWxlLmZ1bGxuYW1lYCk7XG5cdFx0XHRsaW5lcy5wdXNoKGAgICAgc2hvd1RleHRQcmV2aWV3OiB0cnVlYCk7XG5cdFx0XHRsaW5lcy5wdXNoKGAgICAgcHJvcGVydHlMYWJlbHM6IGFib3ZlYCk7XG5cdFx0XHQvLyBTb3J0IGJ5IGRhdGUgcHJvcGVydHkgKG5ld2VzdCB0byBvbGRlc3QpXG5cdFx0XHRsaW5lcy5wdXNoKGAgICAgc29ydDpgKTtcblx0XHRcdGxpbmVzLnB1c2goYCAgICAgIC0gcHJvcGVydHk6ICR7cHJvcHMuZGF0ZVByb3BlcnR5ID8gYG5vdGUuJHtwcm9wcy5kYXRlUHJvcGVydHl9YCA6ICdmaWxlLmN0aW1lJ31gKTtcblx0XHRcdGxpbmVzLnB1c2goYCAgICAgICAgZGlyZWN0aW9uOiBERVNDYCk7XG5cdFx0fVxuXG5cdFx0Ly8gVEhJUkQ6IFByZXNlcnZlIG90aGVyIGV4aXN0aW5nIHZpZXdzIChleGNsdWRpbmcgXCJBbGwgQ29udGVudFwiLCBcIkd1aWRlXCIsIGFuZCBjb250ZW50IHR5cGUgdmlld3MpXG5cdFx0Zm9yIChjb25zdCB2aWV3IG9mIG90aGVyVmlld3MpIHtcblx0XHRcdGxpbmVzLnB1c2goLi4udGhpcy5zZXJpYWxpemVWaWV3KHZpZXcpKTtcblx0XHR9XG5cblx0XHQvLyBGT1VSVEg6IEFkZCBcIkd1aWRlXCIgdmlldyBsYXN0IChpZiBpdCBleGlzdHMpXG5cdFx0aWYgKGd1aWRlVmlldykge1xuXHRcdFx0bGluZXMucHVzaCguLi50aGlzLnNlcmlhbGl6ZVZpZXcoZ3VpZGVWaWV3KSk7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHByaXZhdGUgY2FwaXRhbGl6ZUZpcnN0KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZSBhIHZpZXcgb2JqZWN0IHRvIFlBTUwgbGluZXMgKHdpdGggcHJvcGVyIGluZGVudGF0aW9uKVxuXHQgKi9cblx0cHJpdmF0ZSBzZXJpYWxpemVWaWV3KHZpZXc6IHsgbmFtZT86IHN0cmluZzsgZmlsdGVycz86IHsgYW5kPzogQXJyYXk8c3RyaW5nIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+IH07IGdyb3VwQnk/OiB7IHByb3BlcnR5Pzogc3RyaW5nOyBkaXJlY3Rpb24/OiBzdHJpbmcgfSB8IHN0cmluZzsgb3JkZXI/OiBzdHJpbmdbXTsgc29ydD86IEFycmF5PHsgcHJvcGVydHk/OiBzdHJpbmc7IGRpcmVjdGlvbj86IHN0cmluZyB9PjsgW2tleTogc3RyaW5nXTogdW5rbm93biB9KTogc3RyaW5nW10ge1xuXHRcdGNvbnN0IHZpZXdMaW5lczogc3RyaW5nW10gPSBbXTtcblx0XHR2aWV3TGluZXMucHVzaCgnICAtIHR5cGU6IGJhc2VzLWNtcycpO1xuXHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgbmFtZTogXCIke3ZpZXcubmFtZX1cImApO1xuXHRcdFxuXHRcdGlmICh2aWV3LmZpbHRlcnMpIHtcblx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgZmlsdGVyczonKTtcblx0XHRcdGlmICh2aWV3LmZpbHRlcnMuYW5kKSB7XG5cdFx0XHRcdGlmICh2aWV3LmZpbHRlcnMuYW5kLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgICBhbmQ6IFtdJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICAgIGFuZDonKTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGZpbHRlciBvZiB2aWV3LmZpbHRlcnMuYW5kKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAgICAgLSAke2ZpbHRlcn1gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG9iamVjdCBmaWx0ZXJzIGxpa2UgeyBcImZpbGUuZm9sZGVyLnN0YXJ0c1dpdGhcIjogXCJwb3N0c1wiIH1cblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlU3RyID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IGBcIiR7dmFsdWV9XCJgIDogU3RyaW5nKHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICAgICAtICR7a2V5fTogJHt2YWx1ZVN0cn1gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAodmlldy5ncm91cEJ5KSB7XG5cdFx0XHR2aWV3TGluZXMucHVzaCgnICAgIGdyb3VwQnk6Jyk7XG5cdFx0XHRpZiAodHlwZW9mIHZpZXcuZ3JvdXBCeSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKHZpZXcuZ3JvdXBCeS5wcm9wZXJ0eSkgdmlld0xpbmVzLnB1c2goYCAgICAgIHByb3BlcnR5OiAke3ZpZXcuZ3JvdXBCeS5wcm9wZXJ0eX1gKTtcblx0XHRcdFx0aWYgKHZpZXcuZ3JvdXBCeS5kaXJlY3Rpb24pIHZpZXdMaW5lcy5wdXNoKGAgICAgICBkaXJlY3Rpb246ICR7dmlldy5ncm91cEJ5LmRpcmVjdGlvbn1gKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZpZXcuZ3JvdXBCeSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAgICR7dmlldy5ncm91cEJ5fWApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRpZiAodmlldy5vcmRlcikge1xuXHRcdFx0aWYgKHZpZXcub3JkZXIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHZpZXdMaW5lcy5wdXNoKCcgICAgb3JkZXI6IFtdJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2aWV3TGluZXMucHVzaCgnICAgIG9yZGVyOicpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG9yZGVySXRlbSBvZiB2aWV3Lm9yZGVyKSB7XG5cdFx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAgIC0gJHtvcmRlckl0ZW19YCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0aWYgKHZpZXcuc29ydCkge1xuXHRcdFx0aWYgKHZpZXcuc29ydC5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICBzb3J0OiBbXScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goJyAgICBzb3J0OicpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHNvcnRJdGVtIG9mIHZpZXcuc29ydCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygc29ydEl0ZW0gPT09ICdvYmplY3QnICYmIHNvcnRJdGVtLnByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICAgLSBwcm9wZXJ0eTogJHtzb3J0SXRlbS5wcm9wZXJ0eX1gKTtcblx0XHRcdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgICAgIGRpcmVjdGlvbjogJHtzb3J0SXRlbS5kaXJlY3Rpb24gfHwgJ0FTQyd9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFkZCBhbGwgb3RoZXIgcHJvcGVydGllcyAtIHByZXNlcnZlIEFMTCBwcm9wZXJ0aWVzIGZyb20gdGhlIG9yaWdpbmFsIHZpZXdcblx0XHQvLyBUaGlzIGVuc3VyZXMgd2UgZG9uJ3QgbG9zZSBhbnkgc2V0dGluZ3MgbGlrZSBoaWRlUXVpY2tFZGl0SWNvblxuXHRcdC8vIFNraXAgcHJvcGVydGllcyB0aGF0IGFyZSBhbHJlYWR5IGhhbmRsZWQgYWJvdmUgKHR5cGUsIG5hbWUsIGZpbHRlcnMsIGdyb3VwQnksIG9yZGVyLCBzb3J0KVxuXHRcdGNvbnN0IHNraXBQcm9wcyA9IFsndHlwZScsICduYW1lJywgJ2ZpbHRlcnMnLCAnZ3JvdXBCeScsICdvcmRlcicsICdzb3J0J107XG5cdFx0XG5cdFx0Ly8gU2VyaWFsaXplIGFsbCByZW1haW5pbmcgcHJvcGVydGllcyBmcm9tIHRoZSB2aWV3XG5cdFx0Zm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKHZpZXcpKSB7XG5cdFx0XHRpZiAoc2tpcFByb3BzLmluY2x1ZGVzKHByb3ApIHx8IHZpZXdbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Y29uc3QgdmFsdWUgPSB2aWV3W3Byb3BdO1xuXHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHZpZXdMaW5lcy5wdXNoKGAgICAgJHtwcm9wfTogbnVsbGApO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06ICR7dmFsdWV9YCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0dmlld0xpbmVzLnB1c2goYCAgICAke3Byb3B9OiAke3ZhbHVlfWApO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gJycpIHtcblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06IFwiXCJgKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBGb3IgcHJvcGVydGllcyB0aGF0IGFyZSBub3RlL2ZpbGUgcmVmZXJlbmNlcywgZG9uJ3QgcXVvdGUgdGhlbVxuXHRcdFx0XHQvLyBDaGVjayBmb3IgcHJvcGVydHlEaXNwbGF5TiBhcyB3ZWxsIGFzIGFueXRoaW5nIGVuZGluZyBpbiBQcm9wZXJ0eVxuXHRcdFx0XHRjb25zdCBpc1Byb3BlcnR5UmVmID0gKHByb3AuaW5jbHVkZXMoJ1Byb3BlcnR5JykgfHwgcHJvcC5zdGFydHNXaXRoKCdwcm9wZXJ0eURpc3BsYXknKSkgJiYgXG5cdFx0XHRcdFx0XHRcdFx0XHQgICh2YWx1ZS5zdGFydHNXaXRoKCdub3RlLicpIHx8IHZhbHVlLnN0YXJ0c1dpdGgoJ2ZpbGUuJykpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGlzUHJvcGVydHlSZWYpIHtcblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06ICR7dmFsdWV9YCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocHJvcCA9PT0gJ25ld05vdGVMb2NhdGlvbicpIHtcblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06IFwiJHt2YWx1ZX1cImApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFF1b3RlIG90aGVyIHN0cmluZ3Ncblx0XHRcdFx0XHR2aWV3TGluZXMucHVzaChgICAgICR7cHJvcH06IFwiJHt2YWx1ZX1cImApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiB2aWV3TGluZXM7XG5cdH1cbn1cblxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tICdvYnNpZGlhbic7XHJcbmltcG9ydCB7IFNFT0NvbmZpZywgQ29udGVudFR5cGVDb25maWcsIEZyb250bWF0dGVyUHJvcGVydGllcywgUHJvamVjdERldGVjdGlvblJlc3VsdCB9IGZyb20gJy4uL3R5cGVzJztcclxuaW1wb3J0IHsgUGF0aFJlc29sdmVyIH0gZnJvbSAnLi9QYXRoUmVzb2x2ZXInO1xyXG5cclxudHlwZSBTRU9QbHVnaW4gPSB7XHJcblx0c2V0dGluZ3M/OiB7XHJcblx0XHRzY2FuRGlyZWN0b3JpZXM/OiBzdHJpbmc7XHJcblx0XHR0aXRsZVByb3BlcnR5Pzogc3RyaW5nO1xyXG5cdFx0ZGVzY3JpcHRpb25Qcm9wZXJ0eT86IHN0cmluZztcclxuXHRcdFtrZXk6IHN0cmluZ106IHVua25vd247XHJcblx0fTtcclxuXHRzYXZlU2V0dGluZ3M/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59O1xyXG5cclxudHlwZSBQbHVnaW5zQVBJID0ge1xyXG5cdHBsdWdpbnM/OiBSZWNvcmQ8c3RyaW5nLCBTRU9QbHVnaW4+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFNFT0NvbmZpZ3VyYXRvciB7XHJcblx0cHJpdmF0ZSBhcHA6IEFwcDtcclxuXHRwcml2YXRlIHBhdGhSZXNvbHZlcjogUGF0aFJlc29sdmVyO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0XHR0aGlzLnBhdGhSZXNvbHZlciA9IG5ldyBQYXRoUmVzb2x2ZXIoYXBwKTtcclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlU0VPQ29uZmlnKFxyXG5cdFx0Y29udGVudFR5cGVzOiBDb250ZW50VHlwZUNvbmZpZ1tdLFxyXG5cdFx0ZnJvbnRtYXR0ZXJQcm9wZXJ0aWVzOiB7IFtjb250ZW50VHlwZUlkOiBzdHJpbmddOiBGcm9udG1hdHRlclByb3BlcnRpZXMgfSxcclxuXHRcdHByb2plY3REZXRlY3Rpb24/OiBQcm9qZWN0RGV0ZWN0aW9uUmVzdWx0LFxyXG5cdFx0ZW5hYmxlTWR4U3VwcG9ydD86IGJvb2xlYW5cclxuXHQpOiBTRU9Db25maWcge1xyXG5cdFx0Ly8gVXNlIHRoZSBmaXJzdCBjb250ZW50IHR5cGUncyBwcm9wZXJ0aWVzIGFzIGRlZmF1bHRzXHJcblx0XHRjb25zdCBmaXJzdFR5cGUgPSBjb250ZW50VHlwZXMuZmluZChjdCA9PiBjdC5lbmFibGVkKTtcclxuXHRcdGNvbnN0IGZpcnN0UHJvcHMgPSBmaXJzdFR5cGUgPyBmcm9udG1hdHRlclByb3BlcnRpZXNbZmlyc3RUeXBlLmlkXSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHQvLyBCdWlsZCBzY2FuIGRpcmVjdG9yaWVzIGZyb20gYWxsIGVuYWJsZWQgY29udGVudCB0eXBlc1xyXG5cdFx0Y29uc3Qgc2NhbkRpcmVjdG9yaWVzID0gY29udGVudFR5cGVzXHJcblx0XHRcdC5maWx0ZXIoY3QgPT4gY3QuZW5hYmxlZClcclxuXHRcdFx0Lm1hcChjdCA9PiB0aGlzLnBhdGhSZXNvbHZlci5nZXRGb2xkZXJQYXRoRnJvbVZhdWx0Um9vdChjdC5mb2xkZXIsIHByb2plY3REZXRlY3Rpb24pKVxyXG5cdFx0XHQuam9pbignLCcpO1xyXG5cclxuXHRcdGNvbnN0IGNvbmZpZzogU0VPQ29uZmlnID0ge1xyXG5cdFx0XHQvLyBPbmx5IHNldCB0aXRsZVByb3BlcnR5IGlmIGl0IGV4aXN0cyAobm90IGJsYW5rKSAtIHRoaXMgY29tZXMgZnJvbSB0aGUgd2l6YXJkXHJcblx0XHRcdHRpdGxlUHJvcGVydHk6IGZpcnN0UHJvcHM/LnRpdGxlUHJvcGVydHkgJiYgZmlyc3RQcm9wcy50aXRsZVByb3BlcnR5LnRyaW0oKSAhPT0gJycgXHJcblx0XHRcdFx0PyBmaXJzdFByb3BzLnRpdGxlUHJvcGVydHkgXHJcblx0XHRcdFx0OiAndGl0bGUnLCAvLyBEZWZhdWx0IGZhbGxiYWNrXHJcblx0XHRcdC8vIE9ubHkgc2V0IGRlc2NyaXB0aW9uUHJvcGVydHkgaWYgaXQgZXhpc3RzIChub3QgYmxhbmspIC0gdGhpcyBjb21lcyBmcm9tIHRoZSB3aXphcmRcclxuXHRcdFx0ZGVzY3JpcHRpb25Qcm9wZXJ0eTogZmlyc3RQcm9wcz8uZGVzY3JpcHRpb25Qcm9wZXJ0eSAmJiBmaXJzdFByb3BzLmRlc2NyaXB0aW9uUHJvcGVydHkudHJpbSgpICE9PSAnJ1xyXG5cdFx0XHRcdD8gZmlyc3RQcm9wcy5kZXNjcmlwdGlvblByb3BlcnR5XHJcblx0XHRcdFx0OiB1bmRlZmluZWQsXHJcblx0XHRcdHNjYW5EaXJlY3Rvcmllczogc2NhbkRpcmVjdG9yaWVzLFxyXG5cdFx0XHQvLyBEb24ndCBzZXQgdGhlc2UgLSB3ZSBkb24ndCBjb2xsZWN0IHRoZW0gaW4gdGhlIHdpemFyZFxyXG5cdFx0XHRrZXl3b3JkUHJvcGVydHk6IHVuZGVmaW5lZCxcclxuXHRcdFx0dXNlRmlsZW5hbWVBc1RpdGxlOiBmYWxzZSxcclxuXHRcdFx0dXNlRmlsZW5hbWVBc1NsdWc6IHRydWUsXHJcblx0XHRcdGVuYWJsZU1EWFN1cHBvcnQ6IGVuYWJsZU1keFN1cHBvcnQgPz8gZmFsc2VcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZztcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoY29uZmlnOiBTRU9Db25maWcpOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIFRyeSB0byB1c2UgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZCBmaXJzdCAobGlrZSBBc3RybyBDb21wb3NlcilcclxuXHRcdFx0Y29uc3QgcGx1Z2lucyA9ICh0aGlzLmFwcCBhcyB7IHBsdWdpbnM/OiBQbHVnaW5zQVBJIH0pLnBsdWdpbnM7XHJcblx0XHRcdGNvbnN0IHNlb1BsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/Llsnc2VvJ107XHJcblx0XHRcdFxyXG5cdFx0XHRpZiAoc2VvUGx1Z2luICYmIHNlb1BsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdGNvbnN0IHBsdWdpblNldHRpbmdzID0gc2VvUGx1Z2luLnNldHRpbmdzO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFVwZGF0ZSBzZXR0aW5ncyBmcm9tIGNvbmZpZyAtIG9ubHkgdXBkYXRlIHdoYXQgd2UgY29sbGVjdCBpbiB0aGUgd2l6YXJkXHJcblx0XHRcdFx0Ly8gMS4gc2NhbkRpcmVjdG9yaWVzIC0gYWx3YXlzIHVwZGF0ZSAoZ2VuZXJhdGVkIGZyb20gY29udGVudCB0eXBlcylcclxuXHRcdFx0XHRpZiAoY29uZmlnLnNjYW5EaXJlY3Rvcmllcykge1xyXG5cdFx0XHRcdFx0cGx1Z2luU2V0dGluZ3Muc2NhbkRpcmVjdG9yaWVzID0gY29uZmlnLnNjYW5EaXJlY3RvcmllcztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gMi4gdGl0bGVQcm9wZXJ0eSAtIHVwZGF0ZSBpZiBwcm92aWRlZCAoY29sbGVjdGVkIGluIHdpemFyZClcclxuXHRcdFx0XHRpZiAoY29uZmlnLnRpdGxlUHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0cGx1Z2luU2V0dGluZ3MudGl0bGVQcm9wZXJ0eSA9IGNvbmZpZy50aXRsZVByb3BlcnR5O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyAzLiBkZXNjcmlwdGlvblByb3BlcnR5IC0gdXBkYXRlIGlmIHByb3ZpZGVkIChjb2xsZWN0ZWQgaW4gd2l6YXJkKVxyXG5cdFx0XHRcdGlmIChjb25maWcuZGVzY3JpcHRpb25Qcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5kZXNjcmlwdGlvblByb3BlcnR5ID0gY29uZmlnLmRlc2NyaXB0aW9uUHJvcGVydHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIDQuIGVuYWJsZU1EWFN1cHBvcnQgLSB1cGRhdGUgaWYgcHJvdmlkZWQgKGNvbGxlY3RlZCBpbiB3aXphcmQpXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5lbmFibGVNRFhTdXBwb3J0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLmVuYWJsZU1EWFN1cHBvcnQgPSBjb25maWcuZW5hYmxlTURYU3VwcG9ydDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIGtleXdvcmRQcm9wZXJ0eSwgdXNlRmlsZW5hbWVBc1RpdGxlLCBvciB1c2VGaWxlbmFtZUFzU2x1Z1xyXG5cdFx0XHRcdC8vIC0gd2UgZG9uJ3QgY29sbGVjdCB0aGVzZSBpbiB0aGUgd2l6YXJkLCBsZXQgdXNlciBjb25maWd1cmUgaW4gU0VPIHBsdWdpbiBzZXR0aW5nc1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFNhdmUgdGhlIHNldHRpbmdzIHVzaW5nIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2RcclxuXHRcdFx0XHRpZiAodHlwZW9mIHNlb1BsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGF3YWl0IHNlb1BsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1NFT0NvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBTRU8gY29uZmlnIHZpYSBwbHVnaW4gbWV0aG9kOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZzogU0VPQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdzZW8nO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyBTRU8gZGF0YS5qc29uLCBzdGFydGluZyBmcmVzaDonLCBlcnJvcik7XHJcblx0XHRcdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIGV4aXN0aW5nIGRhdGEgKHByZXNlcnZlIGFsbCBleGlzdGluZyBzZXR0aW5ncylcclxuXHRcdFx0Ly8gT25seSB1cGRhdGUgdGhlIHByb3BlcnRpZXMgd2UgY29sbGVjdCBpbiB0aGUgd2l6YXJkOlxyXG5cdFx0XHQvLyAxLiBzY2FuRGlyZWN0b3JpZXMgKGdlbmVyYXRlZCBmcm9tIGNvbnRlbnQgdHlwZXMpXHJcblx0XHRcdC8vIDIuIHRpdGxlUHJvcGVydHkgKGNvbGxlY3RlZCBpbiB3aXphcmQpXHJcblx0XHRcdC8vIDMuIGRlc2NyaXB0aW9uUHJvcGVydHkgKGNvbGxlY3RlZCBpbiB3aXphcmQpXHJcblx0XHRcdC8vIERvbid0IHRvdWNoIGtleXdvcmRQcm9wZXJ0eSwgdXNlRmlsZW5hbWVBc1RpdGxlLCB1c2VGaWxlbmFtZUFzU2x1ZywgZXRjLlxyXG5cdFx0XHRjb25zdCBtZXJnZWREYXRhID0ge1xyXG5cdFx0XHRcdC4uLmV4aXN0aW5nRGF0YSxcclxuXHRcdFx0XHQvLyBBbHdheXMgdXBkYXRlIHNjYW5EaXJlY3Rvcmllc1xyXG5cdFx0XHRcdHNjYW5EaXJlY3RvcmllczogY29uZmlnLnNjYW5EaXJlY3RvcmllcyxcclxuXHRcdFx0XHQvLyBVcGRhdGUgdGl0bGVQcm9wZXJ0eSBpZiBwcm92aWRlZCAoZnJvbSB3aXphcmQpXHJcblx0XHRcdFx0Li4uKGNvbmZpZy50aXRsZVByb3BlcnR5ICE9PSB1bmRlZmluZWQgJiYgeyB0aXRsZVByb3BlcnR5OiBjb25maWcudGl0bGVQcm9wZXJ0eSB9KSxcclxuXHRcdFx0XHQvLyBVcGRhdGUgZGVzY3JpcHRpb25Qcm9wZXJ0eSBpZiBwcm92aWRlZCAoZnJvbSB3aXphcmQpXHJcblx0XHRcdFx0Li4uKGNvbmZpZy5kZXNjcmlwdGlvblByb3BlcnR5ICE9PSB1bmRlZmluZWQgJiYgeyBkZXNjcmlwdGlvblByb3BlcnR5OiBjb25maWcuZGVzY3JpcHRpb25Qcm9wZXJ0eSB9KSxcclxuXHRcdFx0XHQvLyBVcGRhdGUgZW5hYmxlTURYU3VwcG9ydCBpZiBwcm92aWRlZCAoZnJvbSB3aXphcmQpXHJcblx0XHRcdFx0Li4uKGNvbmZpZy5lbmFibGVNRFhTdXBwb3J0ICE9PSB1bmRlZmluZWQgJiYgeyBlbmFibGVNRFhTdXBwb3J0OiBjb25maWcuZW5hYmxlTURYU3VwcG9ydCB9KVxyXG5cdFx0XHRcdC8vIEFsbCBvdGhlciBwcm9wZXJ0aWVzIChrZXl3b3JkUHJvcGVydHksIHVzZUZpbGVuYW1lQXNUaXRsZSwgdXNlRmlsZW5hbWVBc1NsdWcsIGV0Yy4pXHJcblx0XHRcdFx0Ly8gYXJlIHByZXNlcnZlZCBmcm9tIGV4aXN0aW5nRGF0YSAtIHdlIGRvbid0IGNvbGxlY3QgdGhlbSBpbiB0aGUgd2l6YXJkXHJcblx0XHRcdH07XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBUcnkgdG8gbW9kaWZ5IGZpcnN0LCBpZiBmaWxlIGRvZXNuJ3QgZXhpc3QgaXQgd2lsbCB0aHJvdywgdGhlbiBjcmVhdGVcclxuXHRcdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdTRU9Db25maWc6IFN1Y2Nlc3NmdWxseSB1cGRhdGVkIFNFTyBwbHVnaW4gZGF0YS5qc29uICh2aWEgZmlsZSknKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0XHRjb25zdCBwbHVnaW5EaXIgPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH1gO1xyXG5cdFx0XHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdFx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGZpbGVcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdTRU9Db25maWc6IFN1Y2Nlc3NmdWxseSBjcmVhdGVkIFNFTyBwbHVnaW4gZGF0YS5qc29uICh2aWEgZmlsZSknKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgU0VPIGNvbmZpZyAoZmFsbGJhY2spOicsIGVycm9yKTtcclxuXHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuaW1wb3J0IHsgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoY29uZmlnOiBQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyIGFuZCBTRU8pXHJcblx0XHRcdHR5cGUgUGx1Z2luc0FQSSA9IHtcclxuXHRcdFx0XHRwbHVnaW5zPzogUmVjb3JkPHN0cmluZywge1xyXG5cdFx0XHRcdFx0c2V0dGluZ3M/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0XHRcdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcblx0XHRcdFx0fT47XHJcblx0XHRcdH07XHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbiA9IHBsdWdpbnM/LnBsdWdpbnM/LlsncHJvcGVydHktb3Zlci1maWxlLW5hbWUnXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbiAmJiBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbi5zZXR0aW5ncykge1xyXG5cdFx0XHRcdGNvbnN0IHBsdWdpblNldHRpbmdzID0gcHJvcGVydHlPdmVyRmlsZU5hbWVQbHVnaW4uc2V0dGluZ3M7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IFVzaW5nIHBsdWdpbi5zYXZlU2V0dGluZ3MoKSBtZXRob2QnKTtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogSW5wdXQgY29uZmlnLmVuYWJsZU1keFN1cHBvcnQgPScsIGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBVcGRhdGUgcHJvcGVydHlLZXkgaWYgcHJvdmlkZWRcclxuXHRcdFx0XHRpZiAoY29uZmlnLnByb3BlcnR5S2V5KSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5wcm9wZXJ0eUtleSA9IGNvbmZpZy5wcm9wZXJ0eUtleTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQUxXQVlTIHVwZGF0ZSBlbmFibGVNZHhTdXBwb3J0IGlmIHByb3ZpZGVkIChldmVuIGlmIGZhbHNlKVxyXG5cdFx0XHRcdGlmIChjb25maWcuZW5hYmxlTWR4U3VwcG9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRwbHVnaW5TZXR0aW5ncy5lbmFibGVNZHhTdXBwb3J0ID0gY29uZmlnLmVuYWJsZU1keFN1cHBvcnQ7XHJcblx0XHRcdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogU2V0IHBsdWdpblNldHRpbmdzLmVuYWJsZU1keFN1cHBvcnQgdG8nLCBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybignUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0IGlzIHVuZGVmaW5lZCEnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU2F2ZSB0aGUgc2V0dGluZ3MgdXNpbmcgcGx1Z2luJ3Mgc2F2ZVNldHRpbmdzIG1ldGhvZFxyXG5cdFx0XHRcdGlmICh0eXBlb2YgcHJvcGVydHlPdmVyRmlsZU5hbWVQbHVnaW4uc2F2ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRhd2FpdCBwcm9wZXJ0eU92ZXJGaWxlTmFtZVBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBQbHVnaW4gc2F2ZVNldHRpbmdzIG5vdCBhdmFpbGFibGUsIHVzaW5nIGZhbGxiYWNrJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IFBsdWdpbiBub3QgZm91bmQgb3Igc2V0dGluZ3Mgbm90IGF2YWlsYWJsZSwgdXNpbmcgZmFsbGJhY2snKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2RcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnKTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lIGNvbmZpZyB2aWEgcGx1Z2luIG1ldGhvZDonLCBlcnJvcik7XHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGFzeW5jIHNhdmVDb25maWdGYWxsYmFjayhjb25maWc6IFByb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdwcm9wZXJ0eS1vdmVyLWZpbGUtbmFtZSc7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHRsZXQgZXhpc3RpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xyXG5cdFx0XHRjb25zdCBkYXRhRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EYXRhUGF0aCk7XHJcblx0XHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKSkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBVc2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogSW5wdXQgY29uZmlnID0nLCBKU09OLnN0cmluZ2lmeShjb25maWcpKTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IElucHV0IGNvbmZpZy5lbmFibGVNZHhTdXBwb3J0ID0nLCBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1Byb3BlcnR5T3ZlckZpbGVOYW1lQ29uZmlnOiBFeGlzdGluZyBkYXRhID0nLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEpKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIE1lcmdlIGNvbmZpZywgcHJlc2VydmluZyBleGlzdGluZyBzZXR0aW5nc1xyXG5cdFx0XHQvLyBGaXJzdCBzcHJlYWQgZXhpc3RpbmcgZGF0YSwgdGhlbiBzcHJlYWQgY29uZmlnICh3aGljaCBtYXkgaW5jbHVkZSBlbmFibGVNZHhTdXBwb3J0KVxyXG5cdFx0XHRjb25zdCBtZXJnZWREYXRhID0geyBcclxuXHRcdFx0XHQuLi5leGlzdGluZ0RhdGEsIFxyXG5cdFx0XHRcdC4uLmNvbmZpZ1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQUxXQVlTIGV4cGxpY2l0bHkgc2V0IGVuYWJsZU1keFN1cHBvcnQgaWYgaXQncyBwcm92aWRlZCBpbiBjb25maWcgKGV2ZW4gaWYgZmFsc2UpXHJcblx0XHRcdC8vIFRoaXMgZW5zdXJlcyBpdCBvdmVycmlkZXMgYW55IGV4aXN0aW5nIHZhbHVlXHJcblx0XHRcdGlmIChjb25maWcuZW5hYmxlTWR4U3VwcG9ydCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0bWVyZ2VkRGF0YS5lbmFibGVNZHhTdXBwb3J0ID0gY29uZmlnLmVuYWJsZU1keFN1cHBvcnQ7XHJcblx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnUHJvcGVydHlPdmVyRmlsZU5hbWVDb25maWc6IEV4cGxpY2l0bHkgc2V0IGVuYWJsZU1keFN1cHBvcnQgdG8nLCBjb25maWcuZW5hYmxlTWR4U3VwcG9ydCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogY29uZmlnLmVuYWJsZU1keFN1cHBvcnQgaXMgdW5kZWZpbmVkIScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogRmluYWwgbWVyZ2VkRGF0YS5lbmFibGVNZHhTdXBwb3J0ID0nLCBtZXJnZWREYXRhLmVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0XHRjb25zb2xlLmRlYnVnKCdQcm9wZXJ0eU92ZXJGaWxlTmFtZUNvbmZpZzogRmluYWwgbWVyZ2VkRGF0YSA9JywgSlNPTi5zdHJpbmdpZnkobWVyZ2VkRGF0YSkpO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZGF0YUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0XHRjb25zdCBwbHVnaW5EaXIgPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH1gO1xyXG5cdFx0XHRcdGNvbnN0IHBsdWdpbkRpckZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGlyKTtcclxuXHRcdFx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihwbHVnaW5EaXIpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRcdFx0Ly8gRm9sZGVyIG1pZ2h0IGFscmVhZHkgZXhpc3QgKHJhY2UgY29uZGl0aW9uKSwgaWdub3JlIGVycm9yXHJcblx0XHRcdFx0XHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaWxlXHJcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHBsdWdpbkRhdGFQYXRoLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFByb3BlcnR5IE92ZXIgRmlsZSBOYW1lIGNvbmZpZyAoZmFsbGJhY2spOicsIGVycm9yKTtcclxuXHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4iLCAiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVUlUd2Vha2VyQ29tbWFuZCB7XHJcblx0aWQ6IHN0cmluZztcclxuXHRpY29uOiBzdHJpbmc7XHJcblx0bmFtZTogc3RyaW5nO1xyXG5cdGRpc3BsYXlOYW1lOiBzdHJpbmc7XHJcblx0bW9kZTogc3RyaW5nO1xyXG5cdHRvZ2dsZUljb24/OiBzdHJpbmc7XHJcblx0c2hvd09uRmlsZVR5cGVzPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVJVHdlYWtlckNvbmZpZyB7XHJcblx0dGFiQmFyQ29tbWFuZHM/OiBVSVR3ZWFrZXJDb21tYW5kW107XHJcbn1cclxuXHJcbnR5cGUgUGx1Z2luV2l0aFNldHRpbmdzID0ge1xyXG5cdHNldHRpbmdzPzogVUlUd2Vha2VyQ29uZmlnO1xyXG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIFBsdWdpbldpdGhTZXR0aW5ncz47XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgVUlUd2Vha2VyQ29uZmlndXJhdG9yIHtcclxuXHRwcml2YXRlIGFwcDogQXBwO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xyXG5cdFx0dGhpcy5hcHAgPSBhcHA7XHJcblx0fVxyXG5cclxuXHRhc3luYyBzYXZlQ29uZmlnKGVuYWJsZU1keFN1cHBvcnQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ3VpLXR3ZWFrZXInO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIGxpdmUgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCB1aVR3ZWFrZXJQbHVnaW4gPSBwbHVnaW5zPy5wbHVnaW5zPy5bcGx1Z2luSWRdO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYgKHVpVHdlYWtlclBsdWdpbiAmJiB1aVR3ZWFrZXJQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHRjb25zb2xlLmRlYnVnKCdVSVR3ZWFrZXJDb25maWc6IFVzaW5nIHBsdWdpbi5zZXR0aW5ncyBBUEknKTtcclxuXHRcdFx0XHRjb25zdCBzZXR0aW5ncyA9IHVpVHdlYWtlclBsdWdpbi5zZXR0aW5ncztcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBGb3JjZSB0aGUgTURYIHVwZGF0ZVxyXG5cdFx0XHRcdHRoaXMuZm9yY2VNZHhVcGRhdGUoc2V0dGluZ3MsIGVuYWJsZU1keFN1cHBvcnQpO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFNhdmUgc2V0dGluZ3MgdmlhIHBsdWdpbiBBUElcclxuXHRcdFx0XHRpZiAodHlwZW9mIHVpVHdlYWtlclBsdWdpbi5zYXZlU2V0dGluZ3MgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGF3YWl0IHVpVHdlYWtlclBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ1VJVHdlYWtlckNvbmZpZzogU3VjY2Vzc2Z1bGx5IHNhdmVkIHZpYSBwbHVnaW4uc2F2ZVNldHRpbmdzKCknKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEZhbGxiYWNrIHRvIGZpbGUgbWV0aG9kIGlmIHBsdWdpbiBub3QgYXZhaWxhYmxlXHJcblx0XHRcdGNvbnNvbGUuZGVidWcoJ1VJVHdlYWtlckNvbmZpZzogUGx1Z2luIEFQSSBub3QgYXZhaWxhYmxlLCB1c2luZyBmYWxsYmFjayBmaWxlIG1ldGhvZCcpO1xyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhlbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIFVJIFR3ZWFrZXIgY29uZmlnOicsIGVycm9yKTtcclxuXHRcdFx0Ly8gVHJ5IGZhbGxiYWNrIGFueXdheVxyXG5cdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhlbmFibGVNZHhTdXBwb3J0KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZm9yY2VNZHhVcGRhdGUoc2V0dGluZ3M6IFVJVHdlYWtlckNvbmZpZywgZW5hYmxlTWR4U3VwcG9ydDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgbWR4RmlsZVR5cGVzID0gZW5hYmxlTWR4U3VwcG9ydCA/ICdtZCxtZHgnIDogJ21kJztcclxuXHRcdFxyXG5cdFx0aWYgKCFzZXR0aW5ncy50YWJCYXJDb21tYW5kcyB8fCAhQXJyYXkuaXNBcnJheShzZXR0aW5ncy50YWJCYXJDb21tYW5kcykpIHtcclxuXHRcdFx0c2V0dGluZ3MudGFiQmFyQ29tbWFuZHMgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YWJCYXJDb21tYW5kcyA9IHNldHRpbmdzLnRhYkJhckNvbW1hbmRzIGFzIHVua25vd24gYXMgQXJyYXk8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+O1xyXG5cdFx0Y29uc3QgdG9vbGJhckNvbW1hbmRJbmRleCA9IHRhYkJhckNvbW1hbmRzLmZpbmRJbmRleChjbWQgPT4gY21kLmlkID09PSAnZWRpdGluZy10b29sYmFyOmhpZGUtc2hvdy1tZW51Jyk7XHJcblxyXG5cdFx0aWYgKHRvb2xiYXJDb21tYW5kSW5kZXggIT09IC0xKSB7XHJcblx0XHRcdC8vIE9OTFkgdXBkYXRlIHNob3dPbkZpbGVUeXBlcywgbGVhdmUgZXZlcnl0aGluZyBlbHNlIGFsb25lIVxyXG5cdFx0XHR0YWJCYXJDb21tYW5kc1t0b29sYmFyQ29tbWFuZEluZGV4XSA9IHtcclxuXHRcdFx0XHQuLi50YWJCYXJDb21tYW5kc1t0b29sYmFyQ29tbWFuZEluZGV4XSxcclxuXHRcdFx0XHRcInNob3dPbkZpbGVUeXBlc1wiOiBtZHhGaWxlVHlwZXNcclxuXHRcdFx0fTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhgVUlUd2Vha2VyQ29uZmlnOiBVcGRhdGVkIGV4aXN0aW5nIHRvb2xiYXIgY29tbWFuZCBzaG93T25GaWxlVHlwZXMgdG8gJHttZHhGaWxlVHlwZXN9YCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBPbmx5IGFkZCBpZiBtaXNzaW5nLCB1c2luZyB0aGUgdXNlcidzIHByZWZlcnJlZCBkZWZhdWx0c1xyXG5cdFx0XHR0YWJCYXJDb21tYW5kcy5wdXNoKHtcclxuXHRcdFx0XHRcImlkXCI6IFwiZWRpdGluZy10b29sYmFyOmhpZGUtc2hvdy1tZW51XCIsXHJcblx0XHRcdFx0XCJpY29uXCI6IFwibHVjaWRlLXBhbmVsLXRvcC1vcGVuXCIsXHJcblx0XHRcdFx0XCJuYW1lXCI6IFwiVG9nZ2xlIGVkaXRpbmcgdG9vbGJhclwiLFxyXG5cdFx0XHRcdFwiZGlzcGxheU5hbWVcIjogXCJFZGl0aW5nIFRvb2xiYXI6IEhpZGUvU2hvdyBcIixcclxuXHRcdFx0XHRcIm1vZGVcIjogXCJkZXNrdG9wXCIsXHJcblx0XHRcdFx0XCJ0b2dnbGVJY29uXCI6IFwibHVjaWRlLXBhbmVsLXRvcC1jbG9zZVwiLFxyXG5cdFx0XHRcdFwic2hvd09uRmlsZVR5cGVzXCI6IG1keEZpbGVUeXBlc1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y29uc29sZS5kZWJ1ZyhgVUlUd2Vha2VyQ29uZmlnOiBBZGRlZCBtaXNzaW5nIHRvb2xiYXIgY29tbWFuZCB3aXRoIHNob3dPbkZpbGVUeXBlcz0ke21keEZpbGVUeXBlc31gKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGVuYWJsZU1keFN1cHBvcnQ6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuXHRcdGNvbnN0IHBsdWdpbklkID0gJ3VpLXR3ZWFrZXInO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0aWYgKGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSBKU09OLnBhcnNlKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGF0YUZpbGUpKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBleGlzdGluZyB1aS10d2Vha2VyIGRhdGEuanNvbjonLCBlcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBGb3JjZSB0aGUgTURYIHVwZGF0ZSBvbiB0aGUgbWVyZ2VkIGRhdGFcclxuXHRcdHRoaXMuZm9yY2VNZHhVcGRhdGUoZXhpc3RpbmdEYXRhIGFzIHVua25vd24gYXMgVUlUd2Vha2VyQ29uZmlnLCBlbmFibGVNZHhTdXBwb3J0KTtcclxuXHJcblx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdGNvbnN0IHBsdWdpbkRpciA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfWA7XHJcblx0XHRjb25zdCBwbHVnaW5EaXJGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcblx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0ZpbGUgYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGb2xkZXIgYWxyZWFkeSBleGlzdHMnKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2F2ZSB0byBmaWxlXHJcblx0XHRjb25zdCBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKTtcclxuXHRcdGlmIChkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYXRhRmlsZSwgY29udGVudCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIGNvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0Y29uc29sZS5kZWJ1ZygnVUlUd2Vha2VyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdWktdHdlYWtlciBjb25maWcgdmlhIGZhbGxiYWNrJyk7XHJcblx0fVxyXG59XHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5pbXBvcnQgeyBJbWFnZUluc2VydGVyQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxudHlwZSBJbWFnZUluc2VydGVyUGx1Z2luID0ge1xyXG5cdHNldHRpbmdzPzoge1xyXG5cdFx0ZnJvbnRtYXR0ZXI/OiB7XHJcblx0XHRcdHZhbHVlRm9ybWF0Pzogc3RyaW5nO1xyXG5cdFx0XHRrZXk/OiBzdHJpbmc7XHJcblx0XHR9O1xyXG5cdFx0W2tleTogc3RyaW5nXTogdW5rbm93bjtcclxuXHR9O1xyXG5cdHNhdmVTZXR0aW5ncz86ICgpID0+IFByb21pc2U8dm9pZD47XHJcbn07XHJcblxyXG50eXBlIFBsdWdpbnNBUEkgPSB7XHJcblx0cGx1Z2lucz86IFJlY29yZDxzdHJpbmcsIEltYWdlSW5zZXJ0ZXJQbHVnaW4+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIEltYWdlSW5zZXJ0ZXJDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoY29uZmlnOiBJbWFnZUluc2VydGVyQ29uZmlnLCBpbWFnZVByb3BlcnR5Pzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbnNlcnQtdW5zcGxhc2gtaW1hZ2UnO1xyXG5cdFx0XHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBUcnkgdG8gdXNlIHBsdWdpbidzIHNhdmVTZXR0aW5ncyBtZXRob2QgZmlyc3QgKGxpa2UgQXN0cm8gQ29tcG9zZXIpXHJcblx0XHRcdGNvbnN0IHBsdWdpbnMgPSAodGhpcy5hcHAgYXMgeyBwbHVnaW5zPzogUGx1Z2luc0FQSSB9KS5wbHVnaW5zO1xyXG5cdFx0XHRjb25zdCBpbWFnZUluc2VydGVyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChpbWFnZUluc2VydGVyUGx1Z2luICYmIGltYWdlSW5zZXJ0ZXJQbHVnaW4uc2V0dGluZ3MpIHtcclxuXHRcdFx0XHQvLyBVcGRhdGUgdmlhIHBsdWdpbiBzZXR0aW5ncyBBUEkgKG1hdGNoaW5nIGFzdHJvLW1vZHVsYXItc2V0dGluZ3MgcGF0dGVybilcclxuXHRcdFx0XHRjb25zdCBwbHVnaW5TZXR0aW5ncyA9IGltYWdlSW5zZXJ0ZXJQbHVnaW4uc2V0dGluZ3M7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBmcm9udG1hdHRlciBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdFxyXG5cdFx0XHRcdGlmICghcGx1Z2luU2V0dGluZ3MuZnJvbnRtYXR0ZXIpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLmZyb250bWF0dGVyID0ge307XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFVwZGF0ZSBmcm9udG1hdHRlci52YWx1ZUZvcm1hdCAodGhpcyBpcyB0aGUgbWFpbiBzZXR0aW5nKVxyXG5cdFx0XHRcdGlmIChjb25maWcudmFsdWVGb3JtYXQpIHtcclxuXHRcdFx0XHRcdHBsdWdpblNldHRpbmdzLmZyb250bWF0dGVyLnZhbHVlRm9ybWF0ID0gY29uZmlnLnZhbHVlRm9ybWF0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBVcGRhdGUgZnJvbnRtYXR0ZXIua2V5IGlmIGltYWdlUHJvcGVydHkgaXMgcHJvdmlkZWRcclxuXHRcdFx0XHRpZiAoaW1hZ2VQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdFx0cGx1Z2luU2V0dGluZ3MuZnJvbnRtYXR0ZXIua2V5ID0gaW1hZ2VQcm9wZXJ0eTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBpbWFnZUluc2VydGVyUGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0YXdhaXQgaW1hZ2VJbnNlcnRlclBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZGVidWcoJ0ltYWdlSW5zZXJ0ZXJDb25maWc6IFN1Y2Nlc3NmdWxseSBzYXZlZCB2aWEgcGx1Z2luLnNhdmVTZXR0aW5ncygpJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGYWxsYmFjayB0byBmaWxlIG1ldGhvZCAobGlrZSBBc3RybyBDb21wb3NlciBmYWxsYmFjaylcclxuXHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnLCBpbWFnZVByb3BlcnR5KTtcclxuXHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIEltYWdlIEluc2VydGVyIGNvbmZpZzonLCBlcnJvcik7XHJcblx0XHRcdC8vIFRyeSBmYWxsYmFjayBldmVuIGlmIHBsdWdpbiBtZXRob2QgZmFpbHNcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLnNhdmVDb25maWdGYWxsYmFjayhjb25maWcsIGltYWdlUHJvcGVydHkpO1xyXG5cdFx0XHR9IGNhdGNoIChmYWxsYmFja0Vycm9yKSB7XHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgSW1hZ2UgSW5zZXJ0ZXIgY29uZmlnIHZpYSBmYWxsYmFjazonLCBmYWxsYmFja0Vycm9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBhc3luYyBzYXZlQ29uZmlnRmFsbGJhY2soY29uZmlnOiBJbWFnZUluc2VydGVyQ29uZmlnLCBpbWFnZVByb3BlcnR5Pzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdpbnNlcnQtdW5zcGxhc2gtaW1hZ2UnO1xyXG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xyXG5cdFx0Y29uc3QgcGx1Z2luRGF0YVBhdGggPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH0vZGF0YS5qc29uYDtcclxuXHRcdFxyXG5cdFx0bGV0IGV4aXN0aW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcclxuXHRcdGNvbnN0IGRhdGFGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFxyXG5cdFx0Ly8gUmVhZCBleGlzdGluZyBkYXRhIGlmIGZpbGUgZXhpc3RzXHJcblx0XHRpZiAoZGF0YUZpbGUgJiYgZGF0YUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChkYXRhRmlsZSkpIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG5cdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIGV4aXN0aW5nIEltYWdlIEluc2VydGVyIGRhdGEuanNvbiwgc3RhcnRpbmcgZnJlc2g6JywgZXJyb3IpO1xyXG5cdFx0XHRcdGV4aXN0aW5nRGF0YSA9IHt9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIE1lcmdlIGNvbmZpZyBpbnRvIGV4aXN0aW5nIGRhdGEgKG1hdGNoaW5nIHBsdWdpbiBzdHJ1Y3R1cmUpXHJcblx0XHRjb25zdCBtZXJnZWREYXRhID0ge1xyXG5cdFx0XHQuLi5leGlzdGluZ0RhdGFcclxuXHRcdH07XHJcblx0XHRcclxuXHRcdC8vIEluaXRpYWxpemUgZnJvbnRtYXR0ZXIgb2JqZWN0IGlmIGl0IGRvZXNuJ3QgZXhpc3RcclxuXHRcdGNvbnN0IGZyb250bWF0dGVyID0gKG1lcmdlZERhdGEuZnJvbnRtYXR0ZXIgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHx8IHt9O1xyXG5cdFx0aWYgKCFtZXJnZWREYXRhLmZyb250bWF0dGVyKSB7XHJcblx0XHRcdG1lcmdlZERhdGEuZnJvbnRtYXR0ZXIgPSBmcm9udG1hdHRlcjtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gVXBkYXRlIGZyb250bWF0dGVyLnZhbHVlRm9ybWF0XHJcblx0XHRpZiAoY29uZmlnLnZhbHVlRm9ybWF0KSB7XHJcblx0XHRcdGZyb250bWF0dGVyLnZhbHVlRm9ybWF0ID0gY29uZmlnLnZhbHVlRm9ybWF0O1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBVcGRhdGUgZnJvbnRtYXR0ZXIua2V5IGlmIGltYWdlUHJvcGVydHkgaXMgcHJvdmlkZWRcclxuXHRcdGlmIChpbWFnZVByb3BlcnR5KSB7XHJcblx0XHRcdGZyb250bWF0dGVyLmtleSA9IGltYWdlUHJvcGVydHk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdC8vIFRyeSB0byBtb2RpZnkgZmlyc3QsIGlmIGZpbGUgZG9lc24ndCBleGlzdCBpdCB3aWxsIHRocm93LCB0aGVuIHdlIGNyZWF0ZVxyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBKU09OLnN0cmluZ2lmeShtZXJnZWREYXRhLCBudWxsLCAyKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBFbnN1cmUgcGx1Z2luIGRpcmVjdG9yeSBleGlzdHNcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyID0gYCR7Y29uZmlnRGlyfS9wbHVnaW5zLyR7cGx1Z2luSWR9YDtcclxuXHRcdFx0Y29uc3QgcGx1Z2luRGlyRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwbHVnaW5EaXIpO1xyXG5cdFx0XHRpZiAoIXBsdWdpbkRpckZpbGUpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKHBsdWdpbkRpcik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHRcdC8vIElnbm9yZSBcImFscmVhZHkgZXhpc3RzXCIgZXJyb3JzXHJcblx0XHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmICFlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbGVcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGx1Z2luRGF0YVBhdGgsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0XHQvLyBJZiBmaWxlIHdhcyBjcmVhdGVkIGJldHdlZW4gY2hlY2sgYW5kIGNyZWF0ZSwgdHJ5IHRvIG1vZGlmeSBpdFxyXG5cdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRpZiAoZXJyb3JNZXNzYWdlICYmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ2FscmVhZHkgZXhpc3RzJykgfHwgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpKSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXRyeUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHRcdFx0aWYgKHJldHJ5RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShyZXRyeUZpbGUsIEpTT04uc3RyaW5naWZ5KG1lcmdlZERhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBBcHAsIFRGaWxlIH0gZnJvbSAnb2JzaWRpYW4nO1xyXG5cclxudHlwZSBTaW1wbGVCYW5uZXJQbHVnaW4gPSB7XHJcblx0c2V0dGluZ3M/OiB7XHJcblx0XHRwcm9wZXJ0aWVzPzoge1xyXG5cdFx0XHRpbWFnZT86IHN0cmluZztcclxuXHRcdH07XHJcblx0XHRba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG5cdH07XHJcblx0c2F2ZVNldHRpbmdzPzogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxufTtcclxuXHJcbnR5cGUgUGx1Z2luc0FQSSA9IHtcclxuXHRwbHVnaW5zPzogUmVjb3JkPHN0cmluZywgU2ltcGxlQmFubmVyUGx1Z2luPjtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBTaW1wbGVCYW5uZXJDb25maWd1cmF0b3Ige1xyXG5cdHByaXZhdGUgYXBwOiBBcHA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwKSB7XHJcblx0XHR0aGlzLmFwcCA9IGFwcDtcclxuXHR9XHJcblxyXG5cdGFzeW5jIHNhdmVDb25maWcoaW1hZ2VQcm9wZXJ0eTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcblx0XHRjb25zdCBwbHVnaW5JZCA9ICdzaW1wbGUtYmFubmVyJztcclxuXHRcdFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gVHJ5IHRvIHVzZSBwbHVnaW4ncyBzYXZlU2V0dGluZ3MgbWV0aG9kIGZpcnN0IChsaWtlIEFzdHJvIENvbXBvc2VyKVxyXG5cdFx0XHRjb25zdCBwbHVnaW5zID0gKHRoaXMuYXBwIGFzIHsgcGx1Z2lucz86IFBsdWdpbnNBUEkgfSkucGx1Z2lucztcclxuXHRcdFx0Y29uc3Qgc2ltcGxlQmFubmVyUGx1Z2luID0gcGx1Z2lucz8ucGx1Z2lucz8uW3BsdWdpbklkXTtcclxuXHRcdFx0XHJcblx0XHRcdGlmIChzaW1wbGVCYW5uZXJQbHVnaW4gJiYgc2ltcGxlQmFubmVyUGx1Z2luLnNldHRpbmdzKSB7XHJcblx0XHRcdFx0Ly8gVXBkYXRlIHZpYSBwbHVnaW4gc2V0dGluZ3MgQVBJXHJcblx0XHRcdFx0aWYgKCFzaW1wbGVCYW5uZXJQbHVnaW4uc2V0dGluZ3MucHJvcGVydGllcykge1xyXG5cdFx0XHRcdFx0c2ltcGxlQmFubmVyUGx1Z2luLnNldHRpbmdzLnByb3BlcnRpZXMgPSB7fTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c2ltcGxlQmFubmVyUGx1Z2luLnNldHRpbmdzLnByb3BlcnRpZXMuaW1hZ2UgPSBpbWFnZVByb3BlcnR5O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmICh0eXBlb2Ygc2ltcGxlQmFubmVyUGx1Z2luLnNhdmVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0YXdhaXQgc2ltcGxlQmFubmVyUGx1Z2luLnNhdmVTZXR0aW5ncygpO1xyXG5cdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZygnU2ltcGxlQmFubmVyQ29uZmlnOiBTdWNjZXNzZnVsbHkgc2F2ZWQgdmlhIHBsdWdpbi5zYXZlU2V0dGluZ3MoKScpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gZmlsZSBtZXRob2QgKGxpa2UgQXN0cm8gQ29tcG9zZXIgZmFsbGJhY2spXHJcblx0XHRcdGF3YWl0IHRoaXMuc2F2ZUNvbmZpZ0ZhbGxiYWNrKGltYWdlUHJvcGVydHkpO1xyXG5cdFx0fSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgU2ltcGxlIEJhbm5lciBjb25maWc6JywgZXJyb3IpO1xyXG5cdFx0XHQvLyBUcnkgZmFsbGJhY2sgZXZlbiBpZiBwbHVnaW4gbWV0aG9kIGZhaWxzXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0YXdhaXQgdGhpcy5zYXZlQ29uZmlnRmFsbGJhY2soaW1hZ2VQcm9wZXJ0eSk7XHJcblx0XHRcdH0gY2F0Y2ggKGZhbGxiYWNrRXJyb3IpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBTaW1wbGUgQmFubmVyIGNvbmZpZyB2aWEgZmFsbGJhY2s6JywgZmFsbGJhY2tFcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgYXN5bmMgc2F2ZUNvbmZpZ0ZhbGxiYWNrKGltYWdlUHJvcGVydHk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG5cdFx0Y29uc3QgcGx1Z2luSWQgPSAnc2ltcGxlLWJhbm5lcic7XHJcblx0XHRjb25zdCBjb25maWdEaXIgPSB0aGlzLmFwcC52YXVsdC5jb25maWdEaXI7XHJcblx0XHRjb25zdCBwbHVnaW5EYXRhUGF0aCA9IGAke2NvbmZpZ0Rpcn0vcGx1Z2lucy8ke3BsdWdpbklkfS9kYXRhLmpzb25gO1xyXG5cdFx0XHJcblx0XHRsZXQgZXhpc3RpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xyXG5cdFx0Y29uc3QgZGF0YUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGx1Z2luRGF0YVBhdGgpO1xyXG5cdFx0XHJcblx0XHQvLyBSZWFkIGV4aXN0aW5nIGRhdGEgaWYgZmlsZSBleGlzdHNcclxuXHRcdGlmIChkYXRhRmlsZSAmJiBkYXRhRmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdEYXRhID0gSlNPTi5wYXJzZShhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGRhdGFGaWxlKSkgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZXhpc3RpbmcgU2ltcGxlIEJhbm5lciBkYXRhLmpzb24sIHN0YXJ0aW5nIGZyZXNoOicsIGVycm9yKTtcclxuXHRcdFx0XHRleGlzdGluZ0RhdGEgPSB7fTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBVcGRhdGUgaW1hZ2UgcHJvcGVydHkgaW4gcHJvcGVydGllcyBzZWN0aW9uXHJcblx0XHRjb25zdCBwcm9wZXJ0aWVzID0gKGV4aXN0aW5nRGF0YS5wcm9wZXJ0aWVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB8fCB7fTtcclxuXHRcdGlmICghZXhpc3RpbmdEYXRhLnByb3BlcnRpZXMpIHtcclxuXHRcdFx0ZXhpc3RpbmdEYXRhLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG5cdFx0fVxyXG5cdFx0cHJvcGVydGllcy5pbWFnZSA9IGltYWdlUHJvcGVydHk7XHJcblx0XHRcclxuXHRcdC8vIFRyeSB0byBtb2RpZnkgZmlyc3QsIGlmIGZpbGUgZG9lc24ndCBleGlzdCBpdCB3aWxsIHRocm93LCB0aGVuIHdlIGNyZWF0ZVxyXG5cdFx0aWYgKGRhdGFGaWxlICYmIGRhdGFGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcclxuXHRcdFx0YXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGRhdGFGaWxlLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEsIG51bGwsIDIpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEVuc3VyZSBwbHVnaW4gZGlyZWN0b3J5IGV4aXN0c1xyXG5cdFx0XHRjb25zdCBwbHVnaW5EaXIgPSBgJHtjb25maWdEaXJ9L3BsdWdpbnMvJHtwbHVnaW5JZH1gO1xyXG5cdFx0XHRjb25zdCBwbHVnaW5EaXJGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRpcik7XHJcblx0XHRcdGlmICghcGx1Z2luRGlyRmlsZSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIocGx1Z2luRGlyKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xyXG5cdFx0XHRcdFx0Ly8gSWdub3JlIFwiYWxyZWFkeSBleGlzdHNcIiBlcnJvcnNcclxuXHRcdFx0XHRcdGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcclxuXHRcdFx0XHRcdGlmIChlcnJvck1lc3NhZ2UgJiYgIWVycm9yTWVzc2FnZS5pbmNsdWRlcygnYWxyZWFkeSBleGlzdHMnKSAmJiAhZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdGaWxlIGFscmVhZHkgZXhpc3RzJykpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIENyZWF0ZSB0aGUgZmlsZVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShwbHVnaW5EYXRhUGF0aCwgSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmdEYXRhLCBudWxsLCAyKSk7XHJcblx0XHRcdH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XHJcblx0XHRcdFx0Ly8gSWYgZmlsZSB3YXMgY3JlYXRlZCBiZXR3ZWVuIGNoZWNrIGFuZCBjcmVhdGUsIHRyeSB0byBtb2RpZnkgaXRcclxuXHRcdFx0XHRjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XHJcblx0XHRcdFx0aWYgKGVycm9yTWVzc2FnZSAmJiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdhbHJlYWR5IGV4aXN0cycpIHx8IGVycm9yTWVzc2FnZS5pbmNsdWRlcygnRmlsZSBhbHJlYWR5IGV4aXN0cycpKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcmV0cnlGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBsdWdpbkRhdGFQYXRoKTtcclxuXHRcdFx0XHRcdGlmIChyZXRyeUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xyXG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkocmV0cnlGaWxlLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ0RhdGEsIG51bGwsIDIpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbiIsICJpbXBvcnQgeyBTZXR0aW5nLCByZXF1aXJlQXBpVmVyc2lvbiB9IGZyb20gJ29ic2lkaWFuJztcclxuXHJcbi8qKlxyXG4gKiBUeXBlIGRlZmluaXRpb24gZm9yIFNldHRpbmdHcm91cCBjb25zdHJ1Y3RvclxyXG4gKiBOb3RlOiBTZXR0aW5nR3JvdXAgbWF5IGV4aXN0IGF0IHJ1bnRpbWUgaW4gMS4xMS4wKyBidXQgbWF5IG5vdCBiZSBpbiBUeXBlU2NyaXB0IGRlZmluaXRpb25zXHJcbiAqIFxyXG4gKiBJTVBPUlRBTlQ6IFRoaXMgdHlwZSBzaWduYXR1cmUgaXMgaW5mZXJyZWQgZnJvbSB1c2FnZSBwYXR0ZXJucy4gV2hlbiAucmVmL29ic2lkaWFuLWFwaS9vYnNpZGlhbi5kLnRzXHJcbiAqIGlzIGF2YWlsYWJsZSwgdmVyaWZ5IHRoZSBhY3R1YWwgc2lnbmF0dXJlIHRoZXJlLiBUaGUgc2lnbmF0dXJlIHNob3duIGhlcmUgbWF0Y2hlcyB0aGUgZXhwZWN0ZWRcclxuICogYmVoYXZpb3IgYmFzZWQgb24gT2JzaWRpYW4ncyBBUEkgZGVzaWduIHBhdHRlcm5zLlxyXG4gKi9cclxudHlwZSBTZXR0aW5nR3JvdXBDb25zdHJ1Y3RvciA9IG5ldyAoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KSA9PiB7XHJcblx0c2V0SGVhZGluZyhoZWFkaW5nOiBzdHJpbmcpOiB7XHJcblx0XHRhZGRTZXR0aW5nKGNiOiAoc2V0dGluZzogU2V0dGluZykgPT4gdm9pZCk6IHZvaWQ7XHJcblx0fTtcclxuXHRhZGRTZXR0aW5nKGNiOiAoc2V0dGluZzogU2V0dGluZykgPT4gdm9pZCk6IHZvaWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogSW50ZXJmYWNlIHRoYXQgd29ya3Mgd2l0aCBib3RoIFNldHRpbmdHcm91cCBhbmQgZmFsbGJhY2sgY29udGFpbmVyXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzQ29udGFpbmVyIHtcclxuXHRhZGRTZXR0aW5nKGNiOiAoc2V0dGluZzogU2V0dGluZykgPT4gdm9pZCk6IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0dGluZ3MgY29udGFpbmVyIHRoYXQgdXNlcyBTZXR0aW5nR3JvdXAgaWYgYXZhaWxhYmxlIChBUEkgMS4xMS4wKyksXHJcbiAqIG90aGVyd2lzZSBmYWxscyBiYWNrIHRvIGNyZWF0aW5nIGEgaGVhZGluZyBhbmQgdXNpbmcgdGhlIGNvbnRhaW5lciBkaXJlY3RseS5cclxuICogXHJcbiAqIFVzZXMgcmVxdWlyZUFwaVZlcnNpb24oJzEuMTEuMCcpIHRvIGNoZWNrIGlmIFNldHRpbmdHcm91cCBpcyBhdmFpbGFibGUuXHJcbiAqIFRoaXMgaXMgdGhlIG9mZmljaWFsIE9ic2lkaWFuIEFQSSBtZXRob2QgZm9yIHZlcnNpb24gY2hlY2tpbmcuXHJcbiAqIFxyXG4gKiBJTVBPUlRBTlQ6IFdlIHVzZSBkeW5hbWljIHJlcXVpcmUoKSBpbnN0ZWFkIG9mIGRpcmVjdCBpbXBvcnQgYmVjYXVzZSBTZXR0aW5nR3JvdXBcclxuICogbWF5IG5vdCBiZSBpbiBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgZXZlbiBpZiBpdCBleGlzdHMgYXQgcnVudGltZSBpbiAxLjExLjArLlxyXG4gKiBUaGlzIGF2b2lkcyBjb21waWxlLXRpbWUgVHlwZVNjcmlwdCBlcnJvcnMgd2hpbGUgc3RpbGwgd29ya2luZyBhdCBydW50aW1lLlxyXG4gKiBcclxuICogQHBhcmFtIGNvbnRhaW5lckVsIC0gVGhlIGNvbnRhaW5lciBlbGVtZW50IGZvciBzZXR0aW5nc1xyXG4gKiBAcGFyYW0gaGVhZGluZyAtIE9wdGlvbmFsIGhlYWRpbmcgdGV4dCBmb3IgdGhlIHNldHRpbmdzIGdyb3VwLiBJZiBvbWl0dGVkLCBubyBoZWFkaW5nIGlzIGNyZWF0ZWQuXHJcbiAqIEBwYXJhbSBtYW5pZmVzdElkIC0gVGhlIHBsdWdpbidzIG1hbmlmZXN0IElEIGZvciBDU1Mgc2NvcGluZyAocmVxdWlyZWQgZm9yIGZhbGxiYWNrIG1vZGUpXHJcbiAqIEByZXR1cm5zIEEgY29udGFpbmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIHNldHRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2V0dGluZ3NHcm91cChcclxuXHRjb250YWluZXJFbDogSFRNTEVsZW1lbnQsXHJcblx0aGVhZGluZz86IHN0cmluZyxcclxuXHRtYW5pZmVzdElkPzogc3RyaW5nXHJcbik6IFNldHRpbmdzQ29udGFpbmVyIHtcclxuXHQvLyBDaGVjayBpZiBTZXR0aW5nR3JvdXAgaXMgYXZhaWxhYmxlIChBUEkgMS4xMS4wKylcclxuXHQvLyByZXF1aXJlQXBpVmVyc2lvbiBpcyB0aGUgb2ZmaWNpYWwgT2JzaWRpYW4gQVBJIG1ldGhvZCBmb3IgdmVyc2lvbiBjaGVja2luZ1xyXG5cdGlmIChyZXF1aXJlQXBpVmVyc2lvbignMS4xMS4wJykpIHtcclxuXHRcdC8vIFVzZSBkeW5hbWljIHJlcXVpcmUoKSB0byBhY2Nlc3MgU2V0dGluZ0dyb3VwIGF0IHJ1bnRpbWVcclxuXHRcdC8vIFRoaXMgYXZvaWRzIFR5cGVTY3JpcHQgZXJyb3JzIHdoZW4gU2V0dGluZ0dyb3VwIGlzbid0IGluIHR5cGUgZGVmaW5pdGlvbnNcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBuby11bmRlZlxyXG5cdFx0Y29uc3Qgb2JzaWRpYW4gPSByZXF1aXJlKCdvYnNpZGlhbicpIGFzIHsgU2V0dGluZ0dyb3VwPzogU2V0dGluZ0dyb3VwQ29uc3RydWN0b3IgfTtcclxuXHRcdGNvbnN0IFNldHRpbmdHcm91cCA9IG9ic2lkaWFuLlNldHRpbmdHcm91cCBhcyBTZXR0aW5nR3JvdXBDb25zdHJ1Y3RvcjtcclxuXHRcdFxyXG5cdFx0Ly8gVXNlIFNldHRpbmdHcm91cCAtIGl0J3MgZ3VhcmFudGVlZCB0byBleGlzdCBpZiByZXF1aXJlQXBpVmVyc2lvbiByZXR1cm5zIHRydWVcclxuXHRcdC8vIElmIGhlYWRpbmcgaXMgcHJvdmlkZWQsIHVzZSBzZXRIZWFkaW5nKCk7IG90aGVyd2lzZSB1c2UgU2V0dGluZ0dyb3VwIGRpcmVjdGx5XHJcblx0XHRjb25zdCBncm91cCA9IGhlYWRpbmcgXHJcblx0XHRcdD8gbmV3IFNldHRpbmdHcm91cChjb250YWluZXJFbCkuc2V0SGVhZGluZyhoZWFkaW5nKVxyXG5cdFx0XHQ6IG5ldyBTZXR0aW5nR3JvdXAoY29udGFpbmVyRWwpO1xyXG5cdFx0XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRhZGRTZXR0aW5nKGNiOiAoc2V0dGluZzogU2V0dGluZykgPT4gdm9pZCkge1xyXG5cdFx0XHRcdGdyb3VwLmFkZFNldHRpbmcoY2IpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBGYWxsYmFjayBwYXRoIChlaXRoZXIgQVBJIDwgMS4xMS4wIG9yIFNldHRpbmdHcm91cCBub3QgZm91bmQpXHJcblx0XHQvLyBBZGQgc2NvcGluZyBjbGFzcyB0byBjb250YWluZXJFbCB0byBzY29wZSBDU1MgdG8gb25seSB0aGlzIHBsdWdpbidzIHNldHRpbmdzXHJcblx0XHRpZiAobWFuaWZlc3RJZCkge1xyXG5cdFx0XHRjb250YWluZXJFbC5hZGRDbGFzcyhgJHttYW5pZmVzdElkfS1zZXR0aW5ncy1jb21wYXRgKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gRmFsbGJhY2s6IENyZWF0ZSBhIGhlYWRpbmcgbWFudWFsbHkgKGlmIHByb3ZpZGVkKSBhbmQgdXNlIGNvbnRhaW5lciBkaXJlY3RseVxyXG5cdFx0aWYgKGhlYWRpbmcpIHtcclxuXHRcdFx0Y29uc3QgaGVhZGluZ0VsID0gY29udGFpbmVyRWwuY3JlYXRlRGl2KCdzZXR0aW5nLWdyb3VwLWhlYWRpbmcnKTtcclxuXHRcdFx0aGVhZGluZ0VsLmNyZWF0ZUVsKCdoMycsIHsgdGV4dDogaGVhZGluZyB9KTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWRkU2V0dGluZyhjYjogKHNldHRpbmc6IFNldHRpbmcpID0+IHZvaWQpIHtcclxuXHRcdFx0XHRjb25zdCBzZXR0aW5nID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpO1xyXG5cdFx0XHRcdGNiKHNldHRpbmcpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxufVxyXG5cclxuIiwgImltcG9ydCB7IEFwcCwgcmVxdWVzdFVybCwgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQXBwbHlQcmVzZXRNb2RhbCB9IGZyb20gJy4uL3VpL0FwcGx5UHJlc2V0TW9kYWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdpdEh1YkZpbGUge1xuXHRwYXRoOiBzdHJpbmc7XG5cdHR5cGU6ICdmaWxlJyB8ICdkaXInO1xuXHRkb3dubG9hZF91cmw6IHN0cmluZyB8IG51bGw7XG5cdHVybDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT2JzaWRpYW5BcHBXaXRoQ29tbWFuZHMgZXh0ZW5kcyBBcHAge1xuXHRjb21tYW5kczoge1xuXHRcdGV4ZWN1dGVDb21tYW5kQnlJZDogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XG5cdH07XG59XG5cbmV4cG9ydCBjbGFzcyBQcmVzZXRNYW5hZ2VyIHtcblx0cHJpdmF0ZSBhcHA6IEFwcDtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHR9XG5cblx0YXN5bmMgYXBwbHlQcmVzZXQocmVwbzogc3RyaW5nLCBwcmVzZXROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZiAoIXJlcG8gfHwgIXByZXNldE5hbWUpIHtcblx0XHRcdG5ldyBOb3RpY2UoJ1BsZWFzZSBjb25maWd1cmUgYm90aCByZXBvc2l0b3J5IGFuZCBwcmVzZXQgbmFtZSBpbiBzZXR0aW5ncy4nKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0bmV3IE5vdGljZShgRmV0Y2hpbmcgcHJlc2V0IFwiJHtwcmVzZXROYW1lfVwiIGZyb20gJHtyZXBvfS4uLmApO1xuXHRcdFx0Y29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmZldGNoUHJlc2V0RmlsZXNSZWN1cnNpdmUocmVwbywgcHJlc2V0TmFtZSk7XG5cdFx0XHRcblx0XHRcdGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0bmV3IE5vdGljZShgTm8gZmlsZXMgZm91bmQgZm9yIHByZXNldCBcIiR7cHJlc2V0TmFtZX1cIiBpbiByZXBvICR7cmVwb30uYCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bmV3IE5vdGljZSgnQmFja2luZyB1cCBjb25maWd1cmF0aW9uIGZvbGRlci4uLicpO1xuXHRcdFx0Y29uc3QgYmFja3VwUGF0aCA9IGF3YWl0IHRoaXMuYmFja3VwT2JzaWRpYW5Gb2xkZXIoKTtcblxuXHRcdFx0bmV3IE5vdGljZShgRG93bmxvYWRpbmcgYW5kIGFwcGx5aW5nICR7ZmlsZXMubGVuZ3RofSBmaWxlcy4uLmApO1xuXHRcdFx0bGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG5cdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcblx0XHRcdFx0aWYgKGZpbGUuZG93bmxvYWRfdXJsKSB7XG5cdFx0XHRcdFx0Ly8gTWFwIHBhdGg6IHJlbW92ZSBcInByZXNldE5hbWUvXCIgcHJlZml4XG5cdFx0XHRcdFx0Y29uc3QgcmVsYXRpdmVQYXRoID0gZmlsZS5wYXRoLnN1YnN0cmluZyhwcmVzZXROYW1lLmxlbmd0aCArIDEpO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmRvd25sb2FkQW5kV3JpdGVGaWxlKGZpbGUuZG93bmxvYWRfdXJsLCByZWxhdGl2ZVBhdGgpO1xuXHRcdFx0XHRcdFx0c3VjY2Vzc0NvdW50Kys7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRvd25sb2FkICR7cmVsYXRpdmVQYXRofTpgLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bmV3IE5vdGljZShgQXBwbGllZCAke3N1Y2Nlc3NDb3VudH0gZmlsZXMuYCk7XG5cblx0XHRcdG5ldyBBcHBseVByZXNldE1vZGFsKHRoaXMuYXBwLCBiYWNrdXBQYXRoLCAoZGVsZXRlQmFja3VwKSA9PiB7XG5cdFx0XHRcdHZvaWQgKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRpZiAoZGVsZXRlQmFja3VwKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJtZGlyKGJhY2t1cFBhdGgsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKCdCYWNrdXAgZGVsZXRlZC4nKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBiYWNrdXA6JywgZSk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ0ZhaWxlZCB0byBkZWxldGUgYmFja3VwIGZvbGRlci4gWW91IG1heSBuZWVkIHRvIHJlbW92ZSBpdCBtYW51YWxseS4nKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciByZWxvYWRcblx0XHRcdFx0XHRjb25zdCBhcHBXaXRoQ29tbWFuZHMgPSB0aGlzLmFwcCBhcyBPYnNpZGlhbkFwcFdpdGhDb21tYW5kcztcblx0XHRcdFx0XHRpZiAoYXBwV2l0aENvbW1hbmRzLmNvbW1hbmRzICYmIHR5cGVvZiBhcHBXaXRoQ29tbWFuZHMuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmRCeUlkID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRhcHBXaXRoQ29tbWFuZHMuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmRCeUlkKCdhcHA6cmVsb2FkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSgpO1xuXHRcdFx0fSkub3BlbigpO1xuXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhcHBseSBwcmVzZXQ6JywgZXJyb3IpO1xuXHRcdFx0Y29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcblx0XHRcdG5ldyBOb3RpY2UoYEZhaWxlZCB0byBhcHBseSBwcmVzZXQ6ICR7bWVzc2FnZX1gKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGZldGNoUHJlc2V0RmlsZXNSZWN1cnNpdmUocmVwbzogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPEdpdEh1YkZpbGVbXT4ge1xuXHRcdGNvbnN0IHVybCA9IGBodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zLyR7cmVwb30vY29udGVudHMvJHtwYXRofWA7XG5cdFx0XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybCh7IHVybCB9KTtcblx0XHRcdFxuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgR2l0SHViIEFQSSByZXR1cm5lZCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGl0ZW1zID0gcmVzcG9uc2UuanNvbiBhcyBHaXRIdWJGaWxlW107XG5cdFx0XHRsZXQgYWxsRmlsZXM6IEdpdEh1YkZpbGVbXSA9IFtdO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcblx0XHRcdFx0aWYgKGl0ZW0udHlwZSA9PT0gJ2RpcicpIHtcblx0XHRcdFx0XHRjb25zdCBzdWJGaWxlcyA9IGF3YWl0IHRoaXMuZmV0Y2hQcmVzZXRGaWxlc1JlY3Vyc2l2ZShyZXBvLCBpdGVtLnBhdGgpO1xuXHRcdFx0XHRcdGFsbEZpbGVzID0gYWxsRmlsZXMuY29uY2F0KHN1YkZpbGVzKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpdGVtLnR5cGUgPT09ICdmaWxlJykge1xuXHRcdFx0XHRcdGFsbEZpbGVzLnB1c2goaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFsbEZpbGVzO1xuXHRcdH0gY2F0Y2ggKGU6IHVua25vd24pIHtcblx0XHRcdGlmIChlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnc3RhdHVzJyBpbiBlICYmIGUuc3RhdHVzID09PSA0MDQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBQcmVzZXQgZm9sZGVyIFwiJHtwYXRofVwiIG5vdCBmb3VuZCBpbiByZXBvc2l0b3J5IFwiJHtyZXBvfVwiLmApO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGJhY2t1cE9ic2lkaWFuRm9sZGVyKCk6IFByb21pc2U8c3RyaW5nPiB7XG5cdFx0Y29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6Ll0vZywgJy0nKS5zcGxpdCgnVCcpWzBdICsgJy0nICsgTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG5cdFx0Y29uc3QgY29uZmlnRGlyID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyO1xuXHRcdGNvbnN0IGJhY2t1cFBhdGggPSBgJHtjb25maWdEaXJ9X2JhY2t1cF8ke3RpbWVzdGFtcH1gO1xuXHRcdGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuXHRcdFxuXHRcdC8vIENyZWF0ZSBiYWNrdXAgZGlyZWN0b3J5XG5cdFx0YXdhaXQgYWRhcHRlci5ta2RpcihiYWNrdXBQYXRoKTtcblx0XHRcblx0XHQvLyBDb3B5IGNvbmZpZ3VyYXRpb24gZGlyZWN0b3J5IHJlY3Vyc2l2ZWx5XG5cdFx0YXdhaXQgdGhpcy5jb3B5UmVjdXJzaXZlKGNvbmZpZ0RpciwgYCR7YmFja3VwUGF0aH0vJHtjb25maWdEaXJ9YCk7XG5cdFx0XG5cdFx0cmV0dXJuIGJhY2t1cFBhdGg7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNvcHlSZWN1cnNpdmUoc291cmNlOiBzdHJpbmcsIGRlc3RpbmF0aW9uOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBhZGFwdGVyID0gdGhpcy5hcHAudmF1bHQuYWRhcHRlcjtcblx0XHRcblx0XHRpZiAoIShhd2FpdCBhZGFwdGVyLmV4aXN0cyhzb3VyY2UpKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHN0YXRzID0gYXdhaXQgYWRhcHRlci5saXN0KHNvdXJjZSk7XG5cdFx0XG5cdFx0aWYgKCEoYXdhaXQgYWRhcHRlci5leGlzdHMoZGVzdGluYXRpb24pKSkge1xuXHRcdFx0YXdhaXQgYWRhcHRlci5ta2RpcihkZXN0aW5hdGlvbik7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIENvcHkgZmlsZXNcblx0XHRmb3IgKGNvbnN0IGZpbGUgb2Ygc3RhdHMuZmlsZXMpIHtcblx0XHRcdGNvbnN0IGZpbGVOYW1lID0gZmlsZS5zcGxpdCgnLycpLnBvcCgpO1xuXHRcdFx0aWYgKGZpbGVOYW1lKSB7XG5cdFx0XHRcdGNvbnN0IGRlc3RGaWxlID0gZGVzdGluYXRpb24gKyAnLycgKyBmaWxlTmFtZTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBhZGFwdGVyLmNvcHkoZmlsZSwgZGVzdEZpbGUpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNvcHkgZmlsZSAke2ZpbGV9IHRvICR7ZGVzdEZpbGV9OmAsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFJlY3Vyc2UgaW50byBmb2xkZXJzXG5cdFx0Zm9yIChjb25zdCBmb2xkZXIgb2Ygc3RhdHMuZm9sZGVycykge1xuXHRcdFx0Y29uc3QgZm9sZGVyTmFtZSA9IGZvbGRlci5zcGxpdCgnLycpLnBvcCgpO1xuXHRcdFx0aWYgKGZvbGRlck5hbWUpIHtcblx0XHRcdFx0Y29uc3QgZGVzdEZvbGRlciA9IGRlc3RpbmF0aW9uICsgJy8nICsgZm9sZGVyTmFtZTtcblx0XHRcdFx0YXdhaXQgdGhpcy5jb3B5UmVjdXJzaXZlKGZvbGRlciwgZGVzdEZvbGRlcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBkb3dubG9hZEFuZFdyaXRlRmlsZSh1cmw6IHN0cmluZywgcGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYWRhcHRlciA9IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXI7XG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0VXJsKHsgdXJsIH0pO1xuXHRcdFxuXHRcdGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZG93bmxvYWQgJHtwYXRofSBmcm9tICR7dXJsfWApO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSBwYXJlbnQgZGlyZWN0b3J5IGV4aXN0c1xuXHRcdGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGRpciA9IHBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oJy8nKTtcblx0XHRcdFx0aWYgKCEoYXdhaXQgYWRhcHRlci5leGlzdHMoZGlyKSkpIHtcblx0XHRcdFx0XHRhd2FpdCBhZGFwdGVyLm1rZGlyKGRpcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBXcml0ZSB0aGUgZmlsZSAodXNpbmcgYXJyYXlCdWZmZXIgdG8gaGFuZGxlIGJpbmFyeSBmaWxlcyBzYWZlbHkpXG5cdFx0YXdhaXQgYWRhcHRlci53cml0ZUJpbmFyeShwYXRoLCByZXNwb25zZS5hcnJheUJ1ZmZlcik7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5leHBvcnQgY2xhc3MgQXBwbHlQcmVzZXRNb2RhbCBleHRlbmRzIE1vZGFsIHtcblx0cHJpdmF0ZSBvbkNvbmZpcm06IChkZWxldGVCYWNrdXA6IGJvb2xlYW4pID0+IHZvaWQ7XG5cdHByaXZhdGUgYmFja3VwUGF0aDogc3RyaW5nO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBiYWNrdXBQYXRoOiBzdHJpbmcsIG9uQ29uZmlybTogKGRlbGV0ZUJhY2t1cDogYm9vbGVhbikgPT4gdm9pZCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdFx0dGhpcy5iYWNrdXBQYXRoID0gYmFja3VwUGF0aDtcblx0XHR0aGlzLm9uQ29uZmlybSA9IG9uQ29uZmlybTtcblx0fVxuXG5cdG9uT3BlbigpIHtcblx0XHRjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcblx0XHRjb250ZW50RWwuZW1wdHkoKTtcblxuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbCgnaDInLCB7IHRleHQ6ICdQcmVzZXQgYXBwbGllZCBzdWNjZXNzZnVsbHknIH0pO1xuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbCgncCcsIHsgdGV4dDogJ1RoZSBwcmVzZXQgaGFzIGJlZW4gYXBwbGllZCBzdWNjZXNzZnVsbHkuIFlvdSBuZWVkIHRvIHJlbG9hZCBPYnNpZGlhbiBmb3IgYWxsIGNoYW5nZXMgdG8gdGFrZSBlZmZlY3QuJyB9KTtcblx0XHRjb250ZW50RWwuY3JlYXRlRWwoJ3AnLCB7IHRleHQ6IGBBIGJhY2t1cCBvZiB5b3VyIG9yaWdpbmFsIGNvbmZpZ3VyYXRpb24gZm9sZGVyIHdhcyBjcmVhdGVkIGF0OiAke3RoaXMuYmFja3VwUGF0aH1gIH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGVudEVsKVxuXHRcdFx0LnNldE5hbWUoJ0RlbGV0ZSBiYWNrdXAgYW5kIHJlbG9hZCcpXG5cdFx0XHQuc2V0RGVzYygnUmVtb3ZlIHRoZSBiYWNrdXAgZm9sZGVyIGFuZCByZWxvYWQgT2JzaWRpYW4uIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIFwiY2xlYW5cIiBvcHRpb24uJylcblx0XHRcdC5hZGRCdXR0b24oYnV0dG9uID0+IGJ1dHRvblxuXHRcdFx0XHQuc2V0QnV0dG9uVGV4dCgnRGVsZXRlIGFuZCByZWxvYWQnKVxuXHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdFx0XHR0aGlzLm9uQ29uZmlybSh0cnVlKTtcblx0XHRcdFx0fSkpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGVudEVsKVxuXHRcdFx0LnNldE5hbWUoJ0tlZXAgYmFja3VwIGFuZCByZWxvYWQnKVxuXHRcdFx0LnNldERlc2MoJ0tlZXAgdGhlIGJhY2t1cCBmb2xkZXIgZm9yIHNhZmV0eSBhbmQgcmVsb2FkIE9ic2lkaWFuLicpXG5cdFx0XHQuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cblx0XHRcdFx0LnNldEJ1dHRvblRleHQoJ0tlZXAgYW5kIHJlbG9hZCcpXG5cdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHRcdFx0dGhpcy5vbkNvbmZpcm0oZmFsc2UpO1xuXHRcdFx0XHR9KSk7XG5cdH1cblxuXHRvbkNsb3NlKCkge1xuXHRcdGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5lbXB0eSgpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgU2V0dXBXaXphcmRNb2RhbCB9IGZyb20gJy4uL3VpL1NldHVwV2l6YXJkTW9kYWwnO1xyXG5pbXBvcnQgVmF1bHRDTVNQbHVnaW4gZnJvbSAnLi4vbWFpbic7XHJcbmltcG9ydCB7IFByZXNldE1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9QcmVzZXRNYW5hZ2VyJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbW1hbmRzKHBsdWdpbjogVmF1bHRDTVNQbHVnaW4pOiB2b2lkIHtcclxuXHRwbHVnaW4uYWRkQ29tbWFuZCh7XHJcblx0XHRpZDogJ29wZW4td2l6YXJkJyxcclxuXHRcdG5hbWU6ICdPcGVuIHNldHVwIHdpemFyZCcsXHJcblx0XHRjYWxsYmFjazogKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB3aXphcmQgPSBuZXcgU2V0dXBXaXphcmRNb2RhbChwbHVnaW4uYXBwLCBwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbik7XHJcblx0XHRcdC8vIE5vdGU6IHNldFNhdmVDYWxsYmFjayBpcyBkZXByZWNhdGVkIC0gc3RhdGUgaXMgbm93IG1hbmFnZWQgYXV0b21hdGljYWxseSBieSBTZXR1cFdpemFyZE1vZGFsXHJcblx0XHRcdHdpemFyZC5vcGVuKCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdHBsdWdpbi5hZGRDb21tYW5kKHtcclxuXHRcdGlkOiAnZG93bmxvYWQtYXBwbHktcHJlc2V0JyxcclxuXHRcdG5hbWU6ICdEb3dubG9hZCBhbmQgYXBwbHkgcHJlc2V0JyxcclxuXHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IG1hbmFnZXIgPSBuZXcgUHJlc2V0TWFuYWdlcihwbHVnaW4uYXBwKTtcclxuXHRcdFx0YXdhaXQgbWFuYWdlci5hcHBseVByZXNldChwbHVnaW4uc2V0dGluZ3MucHJlc2V0c1JlcG8sIHBsdWdpbi5zZXR0aW5ncy5wcmVzZXROYW1lKTtcclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQSxvQkFBdUI7OztBQ2dD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ZXMiOiBbImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJlc29sdmUiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiZnMiLCAicGF0aCIsICJmcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJmcyIsICJzZXRDc3NQcm9wcyIsICJyZXNvbHZlIiwgIl9hIiwgInJlbGF0aXZlIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJyZWxhdGl2ZSIsICJzZXRDc3NQcm9wcyIsICJwYXRoIiwgImltcG9ydGVkVHlwZXMiLCAiY29udGVudCIsICJkYXRhIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAicmVzIiwgInJlcyIsICJfYSIsICJtYXAiLCAic2NoZW1hIiwgIm5vZGUiLCAic2NoZW1hIiwgInBhdGgiLCAiaSIsICJlbmQiLCAiaXNCbG9jayIsICJfYSIsICJtYXAiLCAidmFsdWUiLCAibWFwIiwgInNjaGVtYSIsICJzdHJpbmdpZnkiLCAiY29tbWVudCIsICJzdHIiLCAic2NoZW1hIiwgIm1hcCIsICJtYXAiLCAic2NoZW1hIiwgInNjaGVtYSIsICJzZXEiLCAic2VxIiwgInNjaGVtYSIsICJpbnRJZGVudGlmeSIsICJzY2hlbWEiLCAic2VxIiwgInNjaGVtYSIsICJwYWlycyIsICJtYXAiLCAic2NoZW1hIiwgInBhaXJzIiwgIm9tYXAiLCAic2VxIiwgImZsb2F0TmFOIiwgImZsb2F0RXhwIiwgImZsb2F0IiwgImludElkZW50aWZ5IiwgImludFJlc29sdmUiLCAibiIsICJpbnRTdHJpbmdpZnkiLCAiaW50T2N0IiwgImludCIsICJpbnRIZXgiLCAic2NoZW1hIiwgInNldCIsICJtYXAiLCAicmVzIiwgInNjaGVtYSIsICJpbnRPY3QiLCAiaW50IiwgImludEhleCIsICJmbG9hdE5hTiIsICJmbG9hdEV4cCIsICJmbG9hdCIsICJzY2hlbWEiLCAidGFncyIsICJtZXJnZSIsICJzY2hlbWEiLCAicGF0aCIsICJyZXMiLCAiY29tcG9zZU5vZGUiLCAiY29tcG9zZUVtcHR5Tm9kZSIsICJtYXAiLCAic2VwIiwgImNvbXBvc2VOb2RlIiwgImNvbXBvc2VFbXB0eU5vZGUiLCAic2VxIiwgInNlcCIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgImlzTWFwIiwgInNlcCIsICJtYXAiLCAiQ04iLCAidmFsdWUiLCAiZW5kIiwgInNlcCIsICJzZXAiLCAic2NoZW1hIiwgInRhZyIsICJfYSIsICJCUkVBSyIsICJTS0lQIiwgIlJFTU9WRSIsICJ2aXNpdCIsICJwYXRoIiwgIlNDQUxBUiIsICJTQ0FMQVIiLCAiaSIsICJjaCIsICJTQ0FMQVIiLCAic2VwIiwgIm1hcCIsICJzdGFydCIsICJmcyIsICJzZXEiLCAicGFyc2UiLCAicGFyc2UiLCAic2V0Q3NzUHJvcHMiLCAiZXhhbXBsZSIsICJ2YWx1ZSIsICJkZXRlY3RlZCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInNldENzc1Byb3BzIiwgImltcG9ydF9vYnNpZGlhbiIsICJzZXRDc3NQcm9wcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAic2V0Q3NzUHJvcHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJwYXJzZSIsICJyZXNvbHZlIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAic2V0Q3NzUHJvcHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJ0aW1lc3RhbXAiXQp9Cg==
